/* tslint:disable */
/* eslint-disable */
/**
 * Vertex Platform API
 * The Vertex distributed cloud rendering platform includes a set of APIs and SDKs, which together allow easily integrating 3D product data into your business application.  See our [Developer Guides](https://developer.vertexvis.com/docs/guides/render-your-first-scene) to get started.  Notes about the Postman collection and API Reference code samples:   - They include all required and optional body parameters for completeness. Remove any optional parameters as desired.   - They use auto-generated IDs and other values that may share the same value for ease of documentation only. In actual requests and responses, the IDs should uniquely identify their corresponding resource.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@vertexvis.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setBasicAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI } from './base';

/**
 *
 * @export
 * @interface Account
 */
export interface Account {
  /**
   *
   * @type {AccountData}
   * @memberof Account
   */
  data: AccountData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof Account
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface AccountData
 */
export interface AccountData {
  /**
   *
   * @type {string}
   * @memberof AccountData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof AccountData
   */
  id: string;
  /**
   *
   * @type {AccountDataAttributes}
   * @memberof AccountData
   */
  attributes: AccountDataAttributes;
}
/**
 *
 * @export
 * @interface AccountDataAttributes
 */
export interface AccountDataAttributes {
  /**
   *
   * @type {string}
   * @memberof AccountDataAttributes
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof AccountDataAttributes
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof AccountDataAttributes
   */
  created: string;
}
/**
 * Relationship to an `account`.
 * @export
 * @interface AccountRelationship
 */
export interface AccountRelationship {
  /**
   *
   * @type {AccountRelationshipData}
   * @memberof AccountRelationship
   */
  data: AccountRelationshipData;
}
/**
 *
 * @export
 * @interface AccountRelationshipData
 */
export interface AccountRelationshipData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof AccountRelationshipData
   */
  type: AccountRelationshipDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof AccountRelationshipData
   */
  id: string;
}

export const AccountRelationshipDataTypeEnum = {
  Account: 'account',
} as const;

export type AccountRelationshipDataTypeEnum =
  (typeof AccountRelationshipDataTypeEnum)[keyof typeof AccountRelationshipDataTypeEnum];

/**
 *
 * @export
 * @interface AdminConsentAcceptRequest
 */
export interface AdminConsentAcceptRequest {
  /**
   *
   * @type {AdminConsentAcceptRequestData}
   * @memberof AdminConsentAcceptRequest
   */
  data: AdminConsentAcceptRequestData;
}
/**
 *
 * @export
 * @interface AdminConsentAcceptRequestData
 */
export interface AdminConsentAcceptRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof AdminConsentAcceptRequestData
   */
  type: string;
  /**
   *
   * @type {AdminConsentAcceptRequestDataAttributes}
   * @memberof AdminConsentAcceptRequestData
   */
  attributes: AdminConsentAcceptRequestDataAttributes;
}
/**
 *
 * @export
 * @interface AdminConsentAcceptRequestDataAttributes
 */
export interface AdminConsentAcceptRequestDataAttributes {
  /**
   *
   * @type {object}
   * @memberof AdminConsentAcceptRequestDataAttributes
   */
  session: object;
}
/**
 *
 * @export
 * @interface AdminCreateApplicationRequest
 */
export interface AdminCreateApplicationRequest {
  /**
   *
   * @type {AdminCreateApplicationRequestData}
   * @memberof AdminCreateApplicationRequest
   */
  data: AdminCreateApplicationRequestData;
}
/**
 *
 * @export
 * @interface AdminCreateApplicationRequestData
 */
export interface AdminCreateApplicationRequestData {
  /**
   *
   * @type {string}
   * @memberof AdminCreateApplicationRequestData
   */
  type: string;
  /**
   *
   * @type {AdminCreateApplicationRequestDataAttributes}
   * @memberof AdminCreateApplicationRequestData
   */
  attributes: AdminCreateApplicationRequestDataAttributes;
}
/**
 *
 * @export
 * @interface AdminCreateApplicationRequestDataAttributes
 */
export interface AdminCreateApplicationRequestDataAttributes {
  /**
   *
   * @type {string}
   * @memberof AdminCreateApplicationRequestDataAttributes
   */
  name: string;
  /**
   *
   * @type {Array<string>}
   * @memberof AdminCreateApplicationRequestDataAttributes
   */
  scopes?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof AdminCreateApplicationRequestDataAttributes
   */
  redirect_uris?: Array<string>;
}
/**
 *
 * @export
 * @interface AdminLoginAcceptRequest
 */
export interface AdminLoginAcceptRequest {
  /**
   *
   * @type {AdminLoginAcceptRequestData}
   * @memberof AdminLoginAcceptRequest
   */
  data: AdminLoginAcceptRequestData;
}
/**
 *
 * @export
 * @interface AdminLoginAcceptRequestData
 */
export interface AdminLoginAcceptRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof AdminLoginAcceptRequestData
   */
  type: string;
  /**
   *
   * @type {AdminLoginAcceptRequestDataAttributes}
   * @memberof AdminLoginAcceptRequestData
   */
  attributes: AdminLoginAcceptRequestDataAttributes;
}
/**
 *
 * @export
 * @interface AdminLoginAcceptRequestDataAttributes
 */
export interface AdminLoginAcceptRequestDataAttributes {
  /**
   *
   * @type {string}
   * @memberof AdminLoginAcceptRequestDataAttributes
   */
  subject: string;
}
/**
 *
 * @export
 * @interface AdminRedirectTo
 */
export interface AdminRedirectTo {
  /**
   *
   * @type {string}
   * @memberof AdminRedirectTo
   */
  redirectTo: string;
}
/**
 *
 * @export
 * @interface ApiError
 */
export interface ApiError {
  /**
   *
   * @type {string}
   * @memberof ApiError
   */
  id?: string;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof ApiError
   */
  links?: { [key: string]: Link };
  /**
   *
   * @type {string}
   * @memberof ApiError
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof ApiError
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ApiError
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof ApiError
   */
  detail?: string;
  /**
   *
   * @type {ApiErrorSource}
   * @memberof ApiError
   */
  source?: ApiErrorSource;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof ApiError
   */
  meta?: { [key: string]: string };
}
/**
 *
 * @export
 * @interface ApiErrorSource
 */
export interface ApiErrorSource {
  /**
   *
   * @type {string}
   * @memberof ApiErrorSource
   */
  pointer?: string;
  /**
   *
   * @type {string}
   * @memberof ApiErrorSource
   */
  parameter?: string;
}
/**
 *
 * @export
 * @interface Application
 */
export interface Application {
  /**
   *
   * @type {ApplicationData}
   * @memberof Application
   */
  data: ApplicationData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof Application
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface ApplicationData
 */
export interface ApplicationData {
  /**
   *
   * @type {string}
   * @memberof ApplicationData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof ApplicationData
   */
  id: string;
  /**
   *
   * @type {ApplicationDataAttributes}
   * @memberof ApplicationData
   */
  attributes: ApplicationDataAttributes;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof ApplicationData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface ApplicationDataAttributes
 */
export interface ApplicationDataAttributes {
  /**
   *
   * @type {string}
   * @memberof ApplicationDataAttributes
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationDataAttributes
   */
  clientId: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationDataAttributes
   */
  created: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ApplicationDataAttributes
   */
  scopes: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ApplicationDataAttributes
   */
  redirectUris: Array<string>;
}
/**
 *
 * @export
 * @interface ApplicationList
 */
export interface ApplicationList {
  /**
   *
   * @type {Array<ApplicationData>}
   * @memberof ApplicationList
   */
  data: Array<ApplicationData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof ApplicationList
   */
  links: { [key: string]: Link };
}
/**
 * Represents a file and directory within an archive.
 * @export
 * @interface ArchiveManifestEntry
 */
export interface ArchiveManifestEntry {
  /**
   * Represents a query to select a file.
   * @type {SelectFileById | SelectFileBySuppliedId}
   * @memberof ArchiveManifestEntry
   */
  selector: SelectFileById | SelectFileBySuppliedId;
  /**
   * The directory in the archive where the file will be placed.
   * @type {string}
   * @memberof ArchiveManifestEntry
   */
  directory?: string;
}
/**
 *
 * @export
 * @interface Attachment
 */
export interface Attachment {
  /**
   *
   * @type {AttachmentData}
   * @memberof Attachment
   */
  data: AttachmentData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof Attachment
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface AttachmentData
 */
export interface AttachmentData {
  /**
   *
   * @type {string}
   * @memberof AttachmentData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof AttachmentData
   */
  id: string;
  /**
   *
   * @type {AttachmentDataAttributes}
   * @memberof AttachmentData
   */
  attributes: AttachmentDataAttributes;
}
/**
 *
 * @export
 * @interface AttachmentDataAttributes
 */
export interface AttachmentDataAttributes {
  /**
   * The underlying content of the attachment
   * @type {FileAttachment}
   * @memberof AttachmentDataAttributes
   */
  content: FileAttachment;
}
/**
 *
 * @export
 * @interface AttachmentList
 */
export interface AttachmentList {
  /**
   *
   * @type {Array<AttachmentData>}
   * @memberof AttachmentList
   */
  data: Array<AttachmentData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof AttachmentList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface Batch
 */
export interface Batch {
  /**
   * List of operation results.
   * @type {Array<RelationshipData | ApiError>}
   * @memberof Batch
   */
  'vertexvis/batch:results': Array<RelationshipData | ApiError>;
}
/**
 *
 * @export
 * @interface BatchOperation
 */
export interface BatchOperation {
  /**
   * Operation\'s primary data.
   * @type {CreateSceneItemRequestData | RelationshipData}
   * @memberof BatchOperation
   */
  data: CreateSceneItemRequestData | RelationshipData;
  /**
   * Batch operation type type.
   * @type {string}
   * @memberof BatchOperation
   */
  op: BatchOperationOpEnum;
  /**
   *
   * @type {BatchOperationRef}
   * @memberof BatchOperation
   */
  ref: BatchOperationRef;
}

export const BatchOperationOpEnum = {
  Add: 'add',
  Remove: 'remove',
} as const;

export type BatchOperationOpEnum =
  (typeof BatchOperationOpEnum)[keyof typeof BatchOperationOpEnum];

/**
 * Target of batch operation.
 * @export
 * @interface BatchOperationRef
 */
export interface BatchOperationRef {
  /**
   * Resource object type.
   * @type {string}
   * @memberof BatchOperationRef
   */
  type: BatchOperationRefTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof BatchOperationRef
   */
  id: string;
}

export const BatchOperationRefTypeEnum = {
  Scene: 'scene',
} as const;

export type BatchOperationRefTypeEnum =
  (typeof BatchOperationRefTypeEnum)[keyof typeof BatchOperationRefTypeEnum];

/**
 * 3D bounding-box
 * @export
 * @interface BoundingBox
 */
export interface BoundingBox {
  /**
   *
   * @type {Vector3}
   * @memberof BoundingBox
   */
  min: Vector3;
  /**
   *
   * @type {Vector3}
   * @memberof BoundingBox
   */
  max: Vector3;
}
/**
 * Describes the options for configuring a CAD file export.
 * @export
 * @interface CADExportConfig
 */
export interface CADExportConfig extends ExportConfig {}
/**
 * Fit camera in 3D space based on items in scene.
 * @export
 * @interface CameraFit
 */
export interface CameraFit {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CameraFit
   */
  type: CameraFitTypeEnum;
}

export const CameraFitTypeEnum = {
  FitVisibleSceneItems: 'fit-visible-scene-items',
  Reset: 'reset',
} as const;

export type CameraFitTypeEnum =
  (typeof CameraFitTypeEnum)[keyof typeof CameraFitTypeEnum];

/**
 *
 * @export
 * @interface ChangeMaterialOp
 */
export interface ChangeMaterialOp {
  /**
   * Resource object type.
   * @type {string}
   * @memberof ChangeMaterialOp
   */
  type: ChangeMaterialOpTypeEnum;
  /**
   *
   * @type {ColorMaterial}
   * @memberof ChangeMaterialOp
   */
  material: ColorMaterial;
}

export const ChangeMaterialOpTypeEnum = {
  ChangeMaterial: 'change-material',
} as const;

export type ChangeMaterialOpTypeEnum =
  (typeof ChangeMaterialOpTypeEnum)[keyof typeof ChangeMaterialOpTypeEnum];

/**
 *
 * @export
 * @interface ChangeTransformOp
 */
export interface ChangeTransformOp {
  /**
   * Resource object type.
   * @type {string}
   * @memberof ChangeTransformOp
   */
  type: ChangeTransformOpTypeEnum;
  /**
   *
   * @type {Matrix4}
   * @memberof ChangeTransformOp
   */
  transform: Matrix4;
}

export const ChangeTransformOpTypeEnum = {
  ChangeTransform: 'change-transform',
} as const;

export type ChangeTransformOpTypeEnum =
  (typeof ChangeTransformOpTypeEnum)[keyof typeof ChangeTransformOpTypeEnum];

/**
 *
 * @export
 * @interface ChangeVisibilityOp
 */
export interface ChangeVisibilityOp {
  /**
   * Resource object type.
   * @type {string}
   * @memberof ChangeVisibilityOp
   */
  type: ChangeVisibilityOpTypeEnum;
  /**
   * Item visibility.
   * @type {boolean}
   * @memberof ChangeVisibilityOp
   */
  visible: boolean;
}

export const ChangeVisibilityOpTypeEnum = {
  ChangeVisibility: 'change-visibility',
} as const;

export type ChangeVisibilityOpTypeEnum =
  (typeof ChangeVisibilityOpTypeEnum)[keyof typeof ChangeVisibilityOpTypeEnum];

/**
 *
 * @export
 * @interface ClearMaterialOp
 */
export interface ClearMaterialOp {
  /**
   * Resource object type.
   * @type {string}
   * @memberof ClearMaterialOp
   */
  type: ClearMaterialOpTypeEnum;
}

export const ClearMaterialOpTypeEnum = {
  ClearMaterial: 'clear-material',
} as const;

export type ClearMaterialOpTypeEnum =
  (typeof ClearMaterialOpTypeEnum)[keyof typeof ClearMaterialOpTypeEnum];

/**
 *
 * @export
 * @interface ClearRenOp
 */
export interface ClearRenOp {
  /**
   * Resource object type.
   * @type {string}
   * @memberof ClearRenOp
   */
  type: ClearRenOpTypeEnum;
}

export const ClearRenOpTypeEnum = {
  ClearRendition: 'clear-rendition',
} as const;

export type ClearRenOpTypeEnum =
  (typeof ClearRenOpTypeEnum)[keyof typeof ClearRenOpTypeEnum];

/**
 *
 * @export
 * @interface ClearRepOp
 */
export interface ClearRepOp {
  /**
   * Resource object type.
   * @type {string}
   * @memberof ClearRepOp
   */
  type: ClearRepOpTypeEnum;
}

export const ClearRepOpTypeEnum = {
  ClearRepresentation: 'clear-representation',
} as const;

export type ClearRepOpTypeEnum =
  (typeof ClearRepOpTypeEnum)[keyof typeof ClearRepOpTypeEnum];

/**
 *
 * @export
 * @interface ClearTransformOp
 */
export interface ClearTransformOp {
  /**
   * Resource object type.
   * @type {string}
   * @memberof ClearTransformOp
   */
  type: ClearTransformOpTypeEnum;
}

export const ClearTransformOpTypeEnum = {
  ClearTransform: 'clear-transform',
} as const;

export type ClearTransformOpTypeEnum =
  (typeof ClearTransformOpTypeEnum)[keyof typeof ClearTransformOpTypeEnum];

/**
 *
 * @export
 * @interface CollaborationContext
 */
export interface CollaborationContext {
  /**
   *
   * @type {CollaborationContextData}
   * @memberof CollaborationContext
   */
  data: CollaborationContextData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof CollaborationContext
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface CollaborationContextData
 */
export interface CollaborationContextData {
  /**
   *
   * @type {string}
   * @memberof CollaborationContextData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof CollaborationContextData
   */
  id: string;
  /**
   *
   * @type {CollaborationContextDataAttributes}
   * @memberof CollaborationContextData
   */
  attributes: CollaborationContextDataAttributes;
  /**
   *
   * @type {CollaborationContextDataRelationships}
   * @memberof CollaborationContextData
   */
  relationships: CollaborationContextDataRelationships;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof CollaborationContextData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface CollaborationContextDataAttributes
 */
export interface CollaborationContextDataAttributes {
  /**
   *
   * @type {string}
   * @memberof CollaborationContextDataAttributes
   */
  createdAt: string;
}
/**
 *
 * @export
 * @interface CollaborationContextDataRelationships
 */
export interface CollaborationContextDataRelationships {
  /**
   *
   * @type {AccountRelationship}
   * @memberof CollaborationContextDataRelationships
   */
  account: AccountRelationship;
}
/**
 *
 * @export
 * @interface CollaborationContextList
 */
export interface CollaborationContextList {
  /**
   *
   * @type {Array<CollaborationContextData>}
   * @memberof CollaborationContextList
   */
  data: Array<CollaborationContextData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof CollaborationContextList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface CollaborationContextRelationship
 */
export interface CollaborationContextRelationship {
  /**
   *
   * @type {CollaborationContextRelationshipData}
   * @memberof CollaborationContextRelationship
   */
  data: CollaborationContextRelationshipData;
}
/**
 *
 * @export
 * @interface CollaborationContextRelationshipData
 */
export interface CollaborationContextRelationshipData {
  /**
   *
   * @type {string}
   * @memberof CollaborationContextRelationshipData
   */
  type: CollaborationContextRelationshipDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof CollaborationContextRelationshipData
   */
  id: string;
}

export const CollaborationContextRelationshipDataTypeEnum = {
  CollaborationContext: 'collaboration-context',
} as const;

export type CollaborationContextRelationshipDataTypeEnum =
  (typeof CollaborationContextRelationshipDataTypeEnum)[keyof typeof CollaborationContextRelationshipDataTypeEnum];

/**
 * RGB color.
 * @export
 * @interface Color3
 */
export interface Color3 {
  /**
   * Color value from 0 to 255.
   * @type {number}
   * @memberof Color3
   */
  r: number;
  /**
   * Color value from 0 to 255.
   * @type {number}
   * @memberof Color3
   */
  g: number;
  /**
   * Color value from 0 to 255.
   * @type {number}
   * @memberof Color3
   */
  b: number;
}
/**
 * Color properties describing how a material looks.
 * @export
 * @interface ColorMaterial
 */
export interface ColorMaterial {
  /**
   * An opacity value from 0 to 255.
   * @type {number}
   * @memberof ColorMaterial
   */
  opacity: number;
  /**
   * Glossiness from 0 to 128.
   * @type {number}
   * @memberof ColorMaterial
   */
  glossiness: number;
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterial
   */
  ambient: Color3;
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterial
   */
  diffuse: Color3;
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterial
   */
  specular: Color3;
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterial
   */
  emissive: Color3;
}
/**
 * Color properties describing how a material looks.
 * @export
 * @interface ColorMaterialNullable
 */
export interface ColorMaterialNullable {
  /**
   * An opacity value from 0 to 255.
   * @type {number}
   * @memberof ColorMaterialNullable
   */
  opacity: number;
  /**
   * Glossiness from 0 to 128.
   * @type {number}
   * @memberof ColorMaterialNullable
   */
  glossiness: number;
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterialNullable
   */
  ambient: Color3;
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterialNullable
   */
  diffuse: Color3;
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterialNullable
   */
  specular: Color3;
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterialNullable
   */
  emissive: Color3;
}
/**
 *
 * @export
 * @interface CreateAccountRequest
 */
export interface CreateAccountRequest {
  /**
   *
   * @type {CreateAccountRequestData}
   * @memberof CreateAccountRequest
   */
  data: CreateAccountRequestData;
}
/**
 *
 * @export
 * @interface CreateAccountRequestData
 */
export interface CreateAccountRequestData {
  /**
   *
   * @type {string}
   * @memberof CreateAccountRequestData
   */
  type: string;
  /**
   *
   * @type {CreateAccountRequestDataAttributes}
   * @memberof CreateAccountRequestData
   */
  attributes: CreateAccountRequestDataAttributes;
}
/**
 *
 * @export
 * @interface CreateAccountRequestDataAttributes
 */
export interface CreateAccountRequestDataAttributes {
  /**
   *
   * @type {string}
   * @memberof CreateAccountRequestDataAttributes
   */
  name: string;
}
/**
 *
 * @export
 * @interface CreateApplicationRequest
 */
export interface CreateApplicationRequest {
  /**
   *
   * @type {CreateAccountRequestData}
   * @memberof CreateApplicationRequest
   */
  data: CreateAccountRequestData;
}
/**
 *
 * @export
 * @interface CreateAttachmentRequest
 */
export interface CreateAttachmentRequest {
  /**
   *
   * @type {CreateAttachmentRequestData}
   * @memberof CreateAttachmentRequest
   */
  data: CreateAttachmentRequestData;
}
/**
 *
 * @export
 * @interface CreateAttachmentRequestData
 */
export interface CreateAttachmentRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateAttachmentRequestData
   */
  type: CreateAttachmentRequestDataTypeEnum;
  /**
   *
   * @type {CreateAttachmentRequestDataAttributes}
   * @memberof CreateAttachmentRequestData
   */
  attributes: CreateAttachmentRequestDataAttributes;
  /**
   *
   * @type {CreateAttachmentRequestDataRelationships}
   * @memberof CreateAttachmentRequestData
   */
  relationships: CreateAttachmentRequestDataRelationships;
}

export const CreateAttachmentRequestDataTypeEnum = {
  Attachment: 'attachment',
} as const;

export type CreateAttachmentRequestDataTypeEnum =
  (typeof CreateAttachmentRequestDataTypeEnum)[keyof typeof CreateAttachmentRequestDataTypeEnum];

/**
 *
 * @export
 * @interface CreateAttachmentRequestDataAttributes
 */
export interface CreateAttachmentRequestDataAttributes {
  /**
   *
   * @type {WithFileContent}
   * @memberof CreateAttachmentRequestDataAttributes
   */
  withContent: WithFileContent;
}
/**
 *
 * @export
 * @interface CreateAttachmentRequestDataRelationships
 */
export interface CreateAttachmentRequestDataRelationships {
  /**
   *
   * @type {WithThread | WithReply}
   * @memberof CreateAttachmentRequestDataRelationships
   */
  context: WithThread | WithReply;
}
/**
 *
 * @export
 * @interface CreateBatchRequest
 */
export interface CreateBatchRequest {
  /**
   * List of operations to perform as a batch.
   * @type {Array<BatchOperation>}
   * @memberof CreateBatchRequest
   */
  'vertexvis/batch:operations': Array<BatchOperation>;
}
/**
 *
 * @export
 * @interface CreateCollaborationContextRequest
 */
export interface CreateCollaborationContextRequest {
  /**
   *
   * @type {CreateCollaborationContextRequestData}
   * @memberof CreateCollaborationContextRequest
   */
  data: CreateCollaborationContextRequestData;
}
/**
 *
 * @export
 * @interface CreateCollaborationContextRequestData
 */
export interface CreateCollaborationContextRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateCollaborationContextRequestData
   */
  type: CreateCollaborationContextRequestDataTypeEnum;
}

export const CreateCollaborationContextRequestDataTypeEnum = {
  CollaborationContext: 'collaboration-context',
} as const;

export type CreateCollaborationContextRequestDataTypeEnum =
  (typeof CreateCollaborationContextRequestDataTypeEnum)[keyof typeof CreateCollaborationContextRequestDataTypeEnum];

/**
 *
 * @export
 * @interface CreateDownloadRequest
 */
export interface CreateDownloadRequest {
  /**
   *
   * @type {CreateDownloadRequestData}
   * @memberof CreateDownloadRequest
   */
  data: CreateDownloadRequestData;
}
/**
 *
 * @export
 * @interface CreateDownloadRequestData
 */
export interface CreateDownloadRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateDownloadRequestData
   */
  type: string;
  /**
   *
   * @type {CreateDownloadRequestDataAttributes}
   * @memberof CreateDownloadRequestData
   */
  attributes: CreateDownloadRequestDataAttributes;
}
/**
 *
 * @export
 * @interface CreateDownloadRequestDataAttributes
 */
export interface CreateDownloadRequestDataAttributes {
  /**
   * Specifies the duration for which this pre-signed request should be valid. After this time has expired, attempting to use the presigned request will fail. (Defaults to 1 hour, max value is 24 hours)
   * @type {number}
   * @memberof CreateDownloadRequestDataAttributes
   */
  expiry?: number;
}
/**
 *
 * @export
 * @interface CreateExportRequest
 */
export interface CreateExportRequest {
  /**
   *
   * @type {CreateExportRequestData}
   * @memberof CreateExportRequest
   */
  data: CreateExportRequestData;
}
/**
 *
 * @export
 * @interface CreateExportRequestData
 */
export interface CreateExportRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateExportRequestData
   */
  type: string;
  /**
   *
   * @type {CreateExportRequestDataAttributes}
   * @memberof CreateExportRequestData
   */
  attributes: CreateExportRequestDataAttributes;
  /**
   *
   * @type {CreateExportRequestDataRelationships}
   * @memberof CreateExportRequestData
   */
  relationships: CreateExportRequestDataRelationships;
}
/**
 *
 * @export
 * @interface CreateExportRequestDataAttributes
 */
export interface CreateExportRequestDataAttributes {
  /**
   * Specifies the export format and options to configure the export.
   * @type {CADExportConfig}
   * @memberof CreateExportRequestDataAttributes
   */
  config: CADExportConfig;
  /**
   * Optional file name to use for the resulting export
   * @type {string}
   * @memberof CreateExportRequestDataAttributes
   */
  fileName?: string;
  /**
   * Number of seconds before the download url for the export expires when retrieving a completed export. This expiry takes effect when retrieving the export and is valid for the specified time here.
   * @type {number}
   * @memberof CreateExportRequestDataAttributes
   */
  downloadUrlExpiry?: number;
}
/**
 *
 * @export
 * @interface CreateExportRequestDataRelationships
 */
export interface CreateExportRequestDataRelationships {
  /**
   *
   * @type {ExportRelationship}
   * @memberof CreateExportRequestDataRelationships
   */
  source: ExportRelationship;
  /**
   *
   * @type {ExportStateRelationship}
   * @memberof CreateExportRequestDataRelationships
   */
  state?: ExportStateRelationship;
}
/**
 *
 * @export
 * @interface CreateFileCollectionRequest
 */
export interface CreateFileCollectionRequest {
  /**
   *
   * @type {CreateFileCollectionRequestData}
   * @memberof CreateFileCollectionRequest
   */
  data: CreateFileCollectionRequestData;
}
/**
 *
 * @export
 * @interface CreateFileCollectionRequestData
 */
export interface CreateFileCollectionRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateFileCollectionRequestData
   */
  type: CreateFileCollectionRequestDataTypeEnum;
  /**
   *
   * @type {CreateFileCollectionRequestDataAttributes}
   * @memberof CreateFileCollectionRequestData
   */
  attributes: CreateFileCollectionRequestDataAttributes;
}

export const CreateFileCollectionRequestDataTypeEnum = {
  FileCollection: 'file-collection',
} as const;

export type CreateFileCollectionRequestDataTypeEnum =
  (typeof CreateFileCollectionRequestDataTypeEnum)[keyof typeof CreateFileCollectionRequestDataTypeEnum];

/**
 *
 * @export
 * @interface CreateFileCollectionRequestDataAttributes
 */
export interface CreateFileCollectionRequestDataAttributes {
  /**
   *
   * @type {string}
   * @memberof CreateFileCollectionRequestDataAttributes
   */
  name?: string;
  /**
   * ID provided for correlation with external systems, e.g. a PLM system.
   * @type {string}
   * @memberof CreateFileCollectionRequestDataAttributes
   */
  suppliedId?: string;
  /**
   * Number of seconds before expiration
   * @type {number}
   * @memberof CreateFileCollectionRequestDataAttributes
   */
  expiry?: number;
  /**
   * User supplied key-value pairs for a file-collection. You can supply up to 50 entries, with key names limited to 64 characters and values limited to 256 characters.
   * @type {{ [key: string]: string; }}
   * @memberof CreateFileCollectionRequestDataAttributes
   */
  metadata?: { [key: string]: string };
}
/**
 *
 * @export
 * @interface CreateFileJobRequest
 */
export interface CreateFileJobRequest {
  /**
   *
   * @type {CreateFileJobRequestData}
   * @memberof CreateFileJobRequest
   */
  data: CreateFileJobRequestData;
}
/**
 *
 * @export
 * @interface CreateFileJobRequestData
 */
export interface CreateFileJobRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateFileJobRequestData
   */
  type: CreateFileJobRequestDataTypeEnum;
  /**
   *
   * @type {CreateFileJobRequestDataAttributes}
   * @memberof CreateFileJobRequestData
   */
  attributes: CreateFileJobRequestDataAttributes;
}

export const CreateFileJobRequestDataTypeEnum = {
  FileJob: 'file-job',
} as const;

export type CreateFileJobRequestDataTypeEnum =
  (typeof CreateFileJobRequestDataTypeEnum)[keyof typeof CreateFileJobRequestDataTypeEnum];

/**
 *
 * @export
 * @interface CreateFileJobRequestDataAttributes
 */
export interface CreateFileJobRequestDataAttributes {
  /**
   * An object that describes the operation a file job will perform.
   * @type {FileJobArchiveOperation}
   * @memberof CreateFileJobRequestDataAttributes
   */
  operation: FileJobArchiveOperation;
}
/**
 *
 * @export
 * @interface CreateFileRequest
 */
export interface CreateFileRequest {
  /**
   *
   * @type {CreateFileRequestData}
   * @memberof CreateFileRequest
   */
  data: CreateFileRequestData;
}
/**
 *
 * @export
 * @interface CreateFileRequestData
 */
export interface CreateFileRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateFileRequestData
   */
  type: string;
  /**
   *
   * @type {CreateFileRequestDataAttributes}
   * @memberof CreateFileRequestData
   */
  attributes: CreateFileRequestDataAttributes;
}
/**
 *
 * @export
 * @interface CreateFileRequestDataAttributes
 */
export interface CreateFileRequestDataAttributes {
  /**
   * Name matching that of the file you are uploading, including file extension.
   * @type {string}
   * @memberof CreateFileRequestDataAttributes
   */
  name: string;
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof CreateFileRequestDataAttributes
   */
  suppliedId?: string;
  /**
   * File name of the root part or assembly, including file extension. Required if `name` references an archive file extension, ignored otherwise.
   * @type {string}
   * @memberof CreateFileRequestDataAttributes
   */
  rootFileName?: string;
  /**
   * Number of seconds before the file is deleted.
   * @type {number}
   * @memberof CreateFileRequestDataAttributes
   */
  expiry?: number;
  /**
   * User supplied key-value pairs for a file. You can supply up to 50 entries, with key names limited to 64 characters and values limited to 256 characters.
   * @type {{ [key: string]: string; }}
   * @memberof CreateFileRequestDataAttributes
   */
  metadata?: { [key: string]: string };
}
/**
 *
 * @export
 * @interface CreateGeometrySetRequest
 */
export interface CreateGeometrySetRequest {
  /**
   *
   * @type {CreateGeometrySetRequestData}
   * @memberof CreateGeometrySetRequest
   */
  data: CreateGeometrySetRequestData;
}
/**
 *
 * @export
 * @interface CreateGeometrySetRequestData
 */
export interface CreateGeometrySetRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateGeometrySetRequestData
   */
  type: string;
  /**
   *
   * @type {CreateGeometrySetRequestDataRelationships}
   * @memberof CreateGeometrySetRequestData
   */
  relationships: CreateGeometrySetRequestDataRelationships;
}
/**
 *
 * @export
 * @interface CreateGeometrySetRequestDataRelationships
 */
export interface CreateGeometrySetRequestDataRelationships {
  /**
   *
   * @type {FileRelationship}
   * @memberof CreateGeometrySetRequestDataRelationships
   */
  source: FileRelationship;
}
/**
 *
 * @export
 * @interface CreateHitRequest
 */
export interface CreateHitRequest {
  /**
   *
   * @type {CreateHitRequestData}
   * @memberof CreateHitRequest
   */
  data: CreateHitRequestData;
}
/**
 *
 * @export
 * @interface CreateHitRequestData
 */
export interface CreateHitRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateHitRequestData
   */
  type: string;
  /**
   *
   * @type {CreateHitRequestDataAttributes}
   * @memberof CreateHitRequestData
   */
  attributes: CreateHitRequestDataAttributes;
}
/**
 *
 * @export
 * @interface CreateHitRequestDataAttributes
 */
export interface CreateHitRequestDataAttributes {
  /**
   *
   * @type {Point}
   * @memberof CreateHitRequestDataAttributes
   */
  point: Point;
  /**
   *
   * @type {Dimensions}
   * @memberof CreateHitRequestDataAttributes
   */
  viewport: Dimensions;
}
/**
 *
 * @export
 * @interface CreatePartRenditionRequest
 */
export interface CreatePartRenditionRequest {
  /**
   *
   * @type {CreatePartRenditionRequestData}
   * @memberof CreatePartRenditionRequest
   */
  data: CreatePartRenditionRequestData;
}
/**
 * Create a new part rendition.  This endpoint includes multiple successful response codes: [`201`, `202`].  When not given a relationship, this endpoint will create a part rendition with an empty geometry and return a `201` status code.  When given a relationship to translate, this endpoint will return a `202` status code with the location of a `queued-translation`. The status of the translation can be queried via `getQueuedTranslation`. After the translation is complete, the returned value will include a `part-rendition` that references the translated geometry.
 * @export
 * @interface CreatePartRenditionRequestData
 */
export interface CreatePartRenditionRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreatePartRenditionRequestData
   */
  type: string;
  /**
   *
   * @type {CreatePartRenditionRequestDataAttributes}
   * @memberof CreatePartRenditionRequestData
   */
  attributes: CreatePartRenditionRequestDataAttributes;
  /**
   *
   * @type {CreateGeometrySetRequestDataRelationships}
   * @memberof CreatePartRenditionRequestData
   */
  relationships?: CreateGeometrySetRequestDataRelationships;
}
/**
 *
 * @export
 * @interface CreatePartRenditionRequestDataAttributes
 */
export interface CreatePartRenditionRequestDataAttributes {
  /**
   *
   * @type {string}
   * @memberof CreatePartRenditionRequestDataAttributes
   */
  name?: string;
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof CreatePartRenditionRequestDataAttributes
   */
  suppliedId?: string;
  /**
   * Whether or not to replace the default rendition for the part revision with the newly created rendition.
   * @type {boolean}
   * @memberof CreatePartRenditionRequestDataAttributes
   */
  makeDefault?: boolean;
}
/**
 *
 * @export
 * @interface CreatePartRequest
 */
export interface CreatePartRequest {
  /**
   *
   * @type {CreatePartRequestData}
   * @memberof CreatePartRequest
   */
  data: CreatePartRequestData;
}
/**
 *
 * @export
 * @interface CreatePartRequestData
 */
export interface CreatePartRequestData {
  /**
   * Resource object type. Specify one and only one of suppliedId or suppliedIdKey and one and only one of suppliedRevisionId or suppliedRevisionIdKey.
   * @type {string}
   * @memberof CreatePartRequestData
   */
  type: string;
  /**
   *
   * @type {CreatePartRequestDataAttributes}
   * @memberof CreatePartRequestData
   */
  attributes: CreatePartRequestDataAttributes;
  /**
   *
   * @type {CreatePartRequestDataRelationships}
   * @memberof CreatePartRequestData
   */
  relationships?: CreatePartRequestDataRelationships;
}
/**
 *
 * @export
 * @interface CreatePartRequestDataAttributes
 */
export interface CreatePartRequestDataAttributes {
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof CreatePartRequestDataAttributes
   */
  suppliedId?: string;
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system. Sending a new suppliedRevisionId combined with an existing suppliedId will create a new part revision for an existing part.
   * @type {string}
   * @memberof CreatePartRequestDataAttributes
   */
  suppliedRevisionId?: string;
  /**
   * ID provided for correlation of the revision. This is an optional ID to be able to create a version of a revision. For example, if and existing revision in a PLM system is modified, the suppliedIterationId can be used to allow creating a new part revision having an already existing suppliedId and suppliedRevisionId. This can be used when modification to an existing revision is made in the PLM system before the revision is released.
   * @type {string}
   * @memberof CreatePartRequestDataAttributes
   */
  suppliedIterationId?: string;
  /**
   * Whether or not to index metadata in the part file. To ignore metadata from the part file and add your own, pass `false` for `indexMetadata` and supply custom metadata using the `metadata` field.
   * @type {boolean}
   * @memberof CreatePartRequestDataAttributes
   */
  indexMetadata?: boolean;
  /**
   * Additional metadata about the `part` and/or `part-revision`. This metadata will take precedence over any metadata that belongs to the part file if `indexMetadata` is specified. This has been deprecated and replaced by the PATCH endpoint /property-entries
   * @type {{ [key: string]: MetadataLongType | MetadataFloatType | MetadataDateType | MetadataStringType | MetadataNullType; }}
   * @memberof CreatePartRequestDataAttributes
   * @deprecated
   */
  metadata?: {
    [key: string]:
      | MetadataLongType
      | MetadataFloatType
      | MetadataDateType
      | MetadataStringType
      | MetadataNullType;
  };
  /**
   * Name to be used for the root part.
   * @type {string}
   * @memberof CreatePartRequestDataAttributes
   */
  name?: string;
  /**
   * Optional name to be used for the part revision.
   * @type {string}
   * @memberof CreatePartRequestDataAttributes
   */
  revisionName?: string;
  /**
   * Metadata key used to extract an ID used for correlation.
   * @type {string}
   * @memberof CreatePartRequestDataAttributes
   */
  suppliedIdKey?: string;
  /**
   * Metadata key used to extract an ID used for correlation.
   * @type {string}
   * @memberof CreatePartRequestDataAttributes
   */
  suppliedRevisionIdKey?: string;
  /**
   * Metadata key used to extract an ID used for correlation.
   * @type {string}
   * @memberof CreatePartRequestDataAttributes
   */
  suppliedInstanceIdKey?: string;
}
/**
 *
 * @export
 * @interface CreatePartRequestDataRelationships
 */
export interface CreatePartRequestDataRelationships {
  /**
   *
   * @type {PartInstancesRelationship}
   * @memberof CreatePartRequestDataRelationships
   */
  instances?: PartInstancesRelationship;
  /**
   *
   * @type {FileRelationship | DeprecatedPartAssemblyRelationship}
   * @memberof CreatePartRequestDataRelationships
   */
  source?: FileRelationship | DeprecatedPartAssemblyRelationship;
}
/**
 *
 * @export
 * @interface CreatePermissionGrant
 */
export interface CreatePermissionGrant {
  /**
   *
   * @type {CreatePermissionGrantData}
   * @memberof CreatePermissionGrant
   */
  data: CreatePermissionGrantData;
}
/**
 *
 * @export
 * @interface CreatePermissionGrantData
 */
export interface CreatePermissionGrantData {
  /**
   *
   * @type {string}
   * @memberof CreatePermissionGrantData
   */
  type: CreatePermissionGrantDataTypeEnum;
  /**
   *
   * @type {CreatePermissionGrantDataAttributes}
   * @memberof CreatePermissionGrantData
   */
  attributes: CreatePermissionGrantDataAttributes;
}

export const CreatePermissionGrantDataTypeEnum = {
  PermissionGrant: 'permission-grant',
} as const;

export type CreatePermissionGrantDataTypeEnum =
  (typeof CreatePermissionGrantDataTypeEnum)[keyof typeof CreatePermissionGrantDataTypeEnum];

/**
 *
 * @export
 * @interface CreatePermissionGrantDataAttributes
 */
export interface CreatePermissionGrantDataAttributes {
  /**
   *
   * @type {PermissionGrantee}
   * @memberof CreatePermissionGrantDataAttributes
   */
  grantee: PermissionGrantee;
  /**
   *
   * @type {PermissionSubject}
   * @memberof CreatePermissionGrantDataAttributes
   */
  subject: PermissionSubject;
  /**
   *
   * @type {string}
   * @memberof CreatePermissionGrantDataAttributes
   */
  capability: CreatePermissionGrantDataAttributesCapabilityEnum;
}

export const CreatePermissionGrantDataAttributesCapabilityEnum = {
  Read: 'read',
} as const;

export type CreatePermissionGrantDataAttributesCapabilityEnum =
  (typeof CreatePermissionGrantDataAttributesCapabilityEnum)[keyof typeof CreatePermissionGrantDataAttributesCapabilityEnum];

/**
 *
 * @export
 * @interface CreateReplyRequest
 */
export interface CreateReplyRequest {
  /**
   *
   * @type {CreateReplyRequestData}
   * @memberof CreateReplyRequest
   */
  data: CreateReplyRequestData;
}
/**
 *
 * @export
 * @interface CreateReplyRequestData
 */
export interface CreateReplyRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateReplyRequestData
   */
  type: CreateReplyRequestDataTypeEnum;
  /**
   *
   * @type {CreateReplyRequestDataAttributes}
   * @memberof CreateReplyRequestData
   */
  attributes: CreateReplyRequestDataAttributes;
}

export const CreateReplyRequestDataTypeEnum = {
  Reply: 'reply',
} as const;

export type CreateReplyRequestDataTypeEnum =
  (typeof CreateReplyRequestDataTypeEnum)[keyof typeof CreateReplyRequestDataTypeEnum];

/**
 *
 * @export
 * @interface CreateReplyRequestDataAttributes
 */
export interface CreateReplyRequestDataAttributes {
  /**
   *
   * @type {string}
   * @memberof CreateReplyRequestDataAttributes
   */
  body: string;
  /**
   *
   * @type {boolean}
   * @memberof CreateReplyRequestDataAttributes
   */
  isDrafting?: boolean;
}
/**
 *
 * @export
 * @interface CreateSceneAlterationRequest
 */
export interface CreateSceneAlterationRequest {
  /**
   *
   * @type {CreateSceneAlterationRequestData}
   * @memberof CreateSceneAlterationRequest
   */
  data: CreateSceneAlterationRequestData;
}
/**
 *
 * @export
 * @interface CreateSceneAlterationRequestData
 */
export interface CreateSceneAlterationRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSceneAlterationRequestData
   */
  type: string;
  /**
   *
   * @type {CreateSceneAlterationRequestDataAttributes}
   * @memberof CreateSceneAlterationRequestData
   */
  attributes: CreateSceneAlterationRequestDataAttributes;
}
/**
 *
 * @export
 * @interface CreateSceneAlterationRequestDataAttributes
 */
export interface CreateSceneAlterationRequestDataAttributes {
  /**
   * List of alterations to apply.
   * @type {Array<SceneOperation>}
   * @memberof CreateSceneAlterationRequestDataAttributes
   */
  alterations: Array<SceneOperation>;
}
/**
 *
 * @export
 * @interface CreateSceneAnnotationRequest
 */
export interface CreateSceneAnnotationRequest {
  /**
   *
   * @type {CreateSceneAnnotationRequestData}
   * @memberof CreateSceneAnnotationRequest
   */
  data: CreateSceneAnnotationRequestData;
}
/**
 *
 * @export
 * @interface CreateSceneAnnotationRequestData
 */
export interface CreateSceneAnnotationRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSceneAnnotationRequestData
   */
  type: string;
  /**
   *
   * @type {CreateSceneAnnotationRequestDataAttributes}
   * @memberof CreateSceneAnnotationRequestData
   */
  attributes: CreateSceneAnnotationRequestDataAttributes;
}
/**
 *
 * @export
 * @interface CreateSceneAnnotationRequestDataAttributes
 */
export interface CreateSceneAnnotationRequestDataAttributes {
  /**
   * The data describing how to render this annotation.
   * @type {SceneAnnotationCalloutDataType | SceneAnnotationCustomDataType}
   * @memberof CreateSceneAnnotationRequestDataAttributes
   */
  data: SceneAnnotationCalloutDataType | SceneAnnotationCustomDataType;
  /**
   * A customer provided ID used for correlation.
   * @type {string}
   * @memberof CreateSceneAnnotationRequestDataAttributes
   */
  suppliedId?: string;
}
/**
 *
 * @export
 * @interface CreateSceneAnnotationSetRequest
 */
export interface CreateSceneAnnotationSetRequest {
  /**
   *
   * @type {CreateSceneAnnotationSetRequestData}
   * @memberof CreateSceneAnnotationSetRequest
   */
  data: CreateSceneAnnotationSetRequestData;
}
/**
 *
 * @export
 * @interface CreateSceneAnnotationSetRequestData
 */
export interface CreateSceneAnnotationSetRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSceneAnnotationSetRequestData
   */
  type: string;
  /**
   *
   * @type {CreateSceneAnnotationSetRequestDataAttributes}
   * @memberof CreateSceneAnnotationSetRequestData
   */
  attributes: CreateSceneAnnotationSetRequestDataAttributes;
}
/**
 *
 * @export
 * @interface CreateSceneAnnotationSetRequestDataAttributes
 */
export interface CreateSceneAnnotationSetRequestDataAttributes {
  /**
   *
   * @type {string}
   * @memberof CreateSceneAnnotationSetRequestDataAttributes
   */
  name?: string;
  /**
   * A customer provided ID used for correlation.
   * @type {string}
   * @memberof CreateSceneAnnotationSetRequestDataAttributes
   */
  suppliedId?: string;
}
/**
 * Support a query expression for a scene alteration.  To perform a standard item alteration: ```json {   \"data\" : {     \"type\" : \"scene-alteration-expression\",     \"attributes\" : {       \"operations\" : [         {           \"expression\" : {             \"type\" : \"query-operand\",             \"query\" : {               \"type\" : \"query-by-id\",               \"value\" : \"{SCENE_ITEM_ID}\"             }           },           \"changes\" : [             {               \"type\" : \"change-visibility\",               \"visible\" : false             }           ]         }       ]     }   } } ``` To perform a join of two metadata queries, i.e, an \"and\" query: ```json {   \"data\" : {     \"type\" : \"scene-alteration-expression\",     \"attributes\" : {       \"operations\" : [         {           \"expression\" : {             \"type\" : \"and\",             \"left\" : {               \"type\" : \"query-operand\",               \"query\" : {                 \"type\" : \"query-by-metadata\",                 \"filter\" : \"vdXUKl2pQr\",                 \"keys\" : [                   \"jxIuahIdXS\",                   \"9tegKF6acH\"                 ]               }             },             \"right\" : {               \"type\" : \"query-operand\",               \"query\" : {                 \"type\" : \"query-by-metadata\",                 \"filter\" : \"IE8P9JRPXC\",                 \"keys\" : [                   \"5ggPOzw4bT\",                   \"7xQrQE5Q67\"                 ]               }             }           },           \"changes\" : [             {               \"type\" : \"change-visibility\",               \"visible\" : false             }           ]         }       ]     }   } } ``` To provide more complex queries, the left/right also accept or/and expressions. Here\'s an example of a nested `or` item based query: ```json {   \"data\" : {     \"type\" : \"scene-alteration-expression\",     \"attributes\" : {       \"operations\" : [         {           \"expression\" : {             \"type\" : \"or\",             \"left\" : {               \"type\" : \"or\",               \"left\" : {                 \"type\" : \"query-operand\",                 \"query\" : {                   \"type\" : \"query-by-id\",                   \"value\" : \"{SCENE_ITEM_ID_1}\"                 }               },               \"right\" : {                 \"type\" : \"query-operand\",                 \"query\" : {                   \"type\" : \"query-by-id\",                   \"value\" : \"{SCENE_ITEM_ID_2}\"                 }               }             },             \"right\" : {               \"type\" : \"query-operand\",               \"query\" : {                 \"type\" : \"query-by-id\",                 \"value\" : \"{SCENE_ITEM_ID_3}\"               }             }           },           \"changes\" : [             {               \"type\" : \"change-visibility\",               \"visible\" : false             }           ]         }       ]     }   } } ```
 * @export
 * @interface CreateSceneExpressionAlterationRequest
 */
export interface CreateSceneExpressionAlterationRequest {
  /**
   *
   * @type {CreateSceneExpressionAlterationRequestData}
   * @memberof CreateSceneExpressionAlterationRequest
   */
  data: CreateSceneExpressionAlterationRequestData;
}
/**
 *
 * @export
 * @interface CreateSceneExpressionAlterationRequestData
 */
export interface CreateSceneExpressionAlterationRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSceneExpressionAlterationRequestData
   */
  type: CreateSceneExpressionAlterationRequestDataTypeEnum;
  /**
   *
   * @type {CreateSceneExpressionAlterationRequestDataAttributes}
   * @memberof CreateSceneExpressionAlterationRequestData
   */
  attributes: CreateSceneExpressionAlterationRequestDataAttributes;
}

export const CreateSceneExpressionAlterationRequestDataTypeEnum = {
  SceneAlterationExpression: 'scene-alteration-expression',
} as const;

export type CreateSceneExpressionAlterationRequestDataTypeEnum =
  (typeof CreateSceneExpressionAlterationRequestDataTypeEnum)[keyof typeof CreateSceneExpressionAlterationRequestDataTypeEnum];

/**
 *
 * @export
 * @interface CreateSceneExpressionAlterationRequestDataAttributes
 */
export interface CreateSceneExpressionAlterationRequestDataAttributes {
  /**
   * List of operations to apply for the alteration request
   * @type {Array<SceneItemExpressionOperation>}
   * @memberof CreateSceneExpressionAlterationRequestDataAttributes
   */
  operations: Array<SceneItemExpressionOperation>;
}
/**
 *
 * @export
 * @interface CreateSceneItemOverrideRequest
 */
export interface CreateSceneItemOverrideRequest {
  /**
   *
   * @type {CreateSceneItemOverrideRequestData}
   * @memberof CreateSceneItemOverrideRequest
   */
  data: CreateSceneItemOverrideRequestData;
}
/**
 *
 * @export
 * @interface CreateSceneItemOverrideRequestData
 */
export interface CreateSceneItemOverrideRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSceneItemOverrideRequestData
   */
  type: string;
  /**
   *
   * @type {CreateSceneItemOverrideRequestDataAttributes}
   * @memberof CreateSceneItemOverrideRequestData
   */
  attributes: CreateSceneItemOverrideRequestDataAttributes;
  /**
   *
   * @type {CreateSceneItemOverrideRequestDataRelationships}
   * @memberof CreateSceneItemOverrideRequestData
   */
  relationships: CreateSceneItemOverrideRequestDataRelationships;
}
/**
 *
 * @export
 * @interface CreateSceneItemOverrideRequestDataAttributes
 */
export interface CreateSceneItemOverrideRequestDataAttributes {
  /**
   * Item visibility.
   * @type {boolean}
   * @memberof CreateSceneItemOverrideRequestDataAttributes
   */
  visible?: boolean;
  /**
   *
   * @type {Matrix4}
   * @memberof CreateSceneItemOverrideRequestDataAttributes
   */
  transform?: Matrix4;
  /**
   *
   * @type {ColorMaterial}
   * @memberof CreateSceneItemOverrideRequestDataAttributes
   */
  material?: ColorMaterial;
  /**
   *
   * @type {boolean}
   * @memberof CreateSceneItemOverrideRequestDataAttributes
   */
  selected?: boolean;
  /**
   * Phantom state of the item.
   * @type {boolean}
   * @memberof CreateSceneItemOverrideRequestDataAttributes
   */
  phantom?: boolean;
  /**
   * Whether this item is an end item.
   * @type {boolean}
   * @memberof CreateSceneItemOverrideRequestDataAttributes
   */
  endItem?: boolean;
}
/**
 *
 * @export
 * @interface CreateSceneItemOverrideRequestDataRelationships
 */
export interface CreateSceneItemOverrideRequestDataRelationships {
  /**
   *
   * @type {SceneItemRelationship}
   * @memberof CreateSceneItemOverrideRequestDataRelationships
   */
  sceneItem: SceneItemRelationship;
}
/**
 *
 * @export
 * @interface CreateSceneItemRequest
 */
export interface CreateSceneItemRequest {
  /**
   *
   * @type {CreateSceneItemRequestData}
   * @memberof CreateSceneItemRequest
   */
  data: CreateSceneItemRequestData;
}
/**
 *
 * @export
 * @interface CreateSceneItemRequestData
 */
export interface CreateSceneItemRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSceneItemRequestData
   */
  type: string;
  /**
   *
   * @type {CreateSceneItemRequestDataAttributes}
   * @memberof CreateSceneItemRequestData
   */
  attributes: CreateSceneItemRequestDataAttributes;
  /**
   *
   * @type {CreateSceneItemRequestDataRelationships}
   * @memberof CreateSceneItemRequestData
   */
  relationships: CreateSceneItemRequestDataRelationships;
}
/**
 *
 * @export
 * @interface CreateSceneItemRequestDataAttributes
 */
export interface CreateSceneItemRequestDataAttributes {
  /**
   *
   * @type {ColorMaterial}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  materialOverride?: ColorMaterial;
  /**
   *
   * @type {string}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  name?: string;
  /**
   * A 0-based index used for defining a consistent ordering amongst sibling scene items.
   * @type {number}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  ordinal?: number;
  /**
   * Optional ability to specify a parent scene item by scene item supplied ID. For example, an existing ID from a PLM system. This approach is an alternative to providing a specific scene item ID with the relationship parent property.
   * @type {string}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  parent?: string;
  /**
   * Whether or not to use part instance supplied IDs as scene item supplied IDs.
   * @type {boolean}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  partInstanceSuppliedIdsAsSuppliedIds?: boolean;
  /**
   * Optional rule to guide the part-revision resolution algorithm in cases where required qualifiers are not explicitly specified by the query.  In the case of assembly parts, the resolution rule also applies recursively to the resolution of the child parts. \'as-specified\' (the default) directs the resolution algorithm to use only the ids specified in this query.  An incomplete specification will result in an error.  \'latest-iteration\' directs the resolution algorithm to select, within the scope of the specified part-revision, the iteration possessing the newest creation timestamp.  Any iteration identifiers specified by this query are ignored.  Failure to specify a part-revision will result in an error.  \'latest-revision\' directs the resolution algorithm to select the part-revision possessing the newest creation timestamp.  \'latest-revision\' implies \'latest-iteration\' resolution logic.
   * @type {string}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  resolutionRule?: CreateSceneItemRequestDataAttributesResolutionRuleEnum;
  /**
   *
   * @type {PartRevisionSuppliedId}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  source?: PartRevisionSuppliedId;
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  suppliedId?: string;
  /**
   *
   * @type {Matrix4}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  transform?: Matrix4;
  /**
   * Item visibility.
   * @type {boolean}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  visible?: boolean;
  /**
   * Phantom state of the item.
   * @type {boolean}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  phantom?: boolean;
  /**
   * Whether this item is an end item.
   * @type {boolean}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  endItem?: boolean;
  /**
   * Additional metadata for the scene-item. This metadata will take precedence over any metadata that belongs to the part file. This has been deprecated and replaced by the PATCH endpoint /property-entries.
   * @type {{ [key: string]: MetadataLongType | MetadataFloatType | MetadataDateType | MetadataStringType | MetadataNullType; }}
   * @memberof CreateSceneItemRequestDataAttributes
   * @deprecated
   */
  metadata?: {
    [key: string]:
      | MetadataLongType
      | MetadataFloatType
      | MetadataDateType
      | MetadataStringType
      | MetadataNullType;
  };
  /**
   * Specifies which metadata keys should be copied from the source item. Sending null will default to all keys. Sending an empty string will copy none of the sources\' metadata. Sending an array of [\"KEY1\", \"KEY2] will include KEY1 and KEY2 from the source in the scene item creation. This is marked experimental since future releases are expected to prevent copying metadata entirely.
   * @type {Array<string>}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  experimentalSourceMetadataKeys?: Array<string>;
}

export const CreateSceneItemRequestDataAttributesResolutionRuleEnum = {
  AsSpecified: 'as-specified',
  LatestIteration: 'latest-iteration',
  LatestRevision: 'latest-revision',
} as const;

export type CreateSceneItemRequestDataAttributesResolutionRuleEnum =
  (typeof CreateSceneItemRequestDataAttributesResolutionRuleEnum)[keyof typeof CreateSceneItemRequestDataAttributesResolutionRuleEnum];

/**
 *
 * @export
 * @interface CreateSceneItemRequestDataRelationships
 */
export interface CreateSceneItemRequestDataRelationships {
  /**
   *
   * @type {SceneItemRelationship}
   * @memberof CreateSceneItemRequestDataRelationships
   */
  parent?: SceneItemRelationship;
  /**
   * Relationship to a `geometry-set`, `part-revision`, `part-rendition`, or `scene`.
   * @type {GeometrySetRelationship | PartRevisionRelationship | SceneRelationship | PartRenditionRelationship}
   * @memberof CreateSceneItemRequestDataRelationships
   */
  source?:
    | GeometrySetRelationship
    | PartRevisionRelationship
    | SceneRelationship
    | PartRenditionRelationship;
  /**
   *
   * @type {SceneItemRelationship}
   * @memberof CreateSceneItemRequestDataRelationships
   */
  referenceTree?: SceneItemRelationship;
}
/**
 * A reference to a scene to be created for a thread.
 * @export
 * @interface CreateSceneReference
 */
export interface CreateSceneReference {
  /**
   *
   * @type {string}
   * @memberof CreateSceneReference
   */
  type: CreateSceneReferenceTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof CreateSceneReference
   */
  sceneId: string;
  /**
   *
   * @type {Vector3}
   * @memberof CreateSceneReference
   */
  position?: Vector3;
  /**
   *
   * @type {WithSceneViewId | WithSceneViewStateId}
   * @memberof CreateSceneReference
   */
  withSceneViewState?: WithSceneViewId | WithSceneViewStateId;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof CreateSceneReference
   */
  sceneItemId?: string;
}

export const CreateSceneReferenceTypeEnum = {
  SceneReference: 'scene-reference',
} as const;

export type CreateSceneReferenceTypeEnum =
  (typeof CreateSceneReferenceTypeEnum)[keyof typeof CreateSceneReferenceTypeEnum];

/**
 *
 * @export
 * @interface CreateSceneRequest
 */
export interface CreateSceneRequest {
  /**
   *
   * @type {CreateSceneRequestData}
   * @memberof CreateSceneRequest
   */
  data: CreateSceneRequestData;
}
/**
 *
 * @export
 * @interface CreateSceneRequestData
 */
export interface CreateSceneRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSceneRequestData
   */
  type: string;
  /**
   *
   * @type {CreateSceneRequestDataAttributes}
   * @memberof CreateSceneRequestData
   */
  attributes: CreateSceneRequestDataAttributes;
  /**
   *
   * @type {CreateSceneRequestDataRelationships}
   * @memberof CreateSceneRequestData
   */
  relationships?: CreateSceneRequestDataRelationships;
}
/**
 *
 * @export
 * @interface CreateSceneRequestDataAttributes
 */
export interface CreateSceneRequestDataAttributes {
  /**
   *
   * @type {PerspectiveCamera | OrthographicCamera}
   * @memberof CreateSceneRequestDataAttributes
   */
  camera?: PerspectiveCamera | OrthographicCamera;
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof CreateSceneRequestDataAttributes
   */
  suppliedId?: string;
  /**
   *
   * @type {string}
   * @memberof CreateSceneRequestDataAttributes
   */
  name?: string;
  /**
   *
   * @type {boolean}
   * @memberof CreateSceneRequestDataAttributes
   */
  treeEnabled?: boolean;
  /**
   *
   * @type {Orientation}
   * @memberof CreateSceneRequestDataAttributes
   */
  worldOrientation?: Orientation;
  /**
   * User supplied key-value pairs for a scene. You can supply up to 50 entries, with key names limited to 64 characters and values limited to 256 characters. A null value will delete the entry in the map, all other key/value pairs provided here will be inserted or updated into the existing scene metadata.
   * @type {{ [key: string]: string; }}
   * @memberof CreateSceneRequestDataAttributes
   */
  metadata?: { [key: string]: string };
  /**
   * Number of seconds before expiration
   * @type {number}
   * @memberof CreateSceneRequestDataAttributes
   */
  expiry?: number;
}
/**
 *
 * @export
 * @interface CreateSceneRequestDataRelationships
 */
export interface CreateSceneRequestDataRelationships {
  /**
   *
   * @type {SceneRelationship}
   * @memberof CreateSceneRequestDataRelationships
   */
  source: SceneRelationship;
}
/**
 * An operation to perform on a Scene.
 * @export
 * @interface CreateSceneSyncRequest
 */
export interface CreateSceneSyncRequest {
  /**
   *
   * @type {UpdateItemToDefaultRenditionOperation}
   * @memberof CreateSceneSyncRequest
   */
  operation: UpdateItemToDefaultRenditionOperation;
}
/**
 *
 * @export
 * @interface CreateSceneViewRequest
 */
export interface CreateSceneViewRequest {
  /**
   *
   * @type {CreateSceneViewRequestData}
   * @memberof CreateSceneViewRequest
   */
  data: CreateSceneViewRequestData;
}
/**
 *
 * @export
 * @interface CreateSceneViewRequestData
 */
export interface CreateSceneViewRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSceneViewRequestData
   */
  type: string;
  /**
   *
   * @type {CreateSceneViewRequestDataAttributes}
   * @memberof CreateSceneViewRequestData
   */
  attributes: CreateSceneViewRequestDataAttributes;
  /**
   *
   * @type {CreateSceneViewRequestDataRelationships}
   * @memberof CreateSceneViewRequestData
   */
  relationships?: CreateSceneViewRequestDataRelationships;
}
/**
 *
 * @export
 * @interface CreateSceneViewRequestDataAttributes
 */
export interface CreateSceneViewRequestDataAttributes {
  /**
   *
   * @type {PerspectiveCamera | OrthographicCamera}
   * @memberof CreateSceneViewRequestDataAttributes
   */
  camera?: PerspectiveCamera | OrthographicCamera;
  /**
   *
   * @type {CrossSectioning}
   * @memberof CreateSceneViewRequestDataAttributes
   */
  crossSectioning?: CrossSectioning | null;
  /**
   * Whether to exclude non-visible items in the view
   * @type {boolean}
   * @memberof CreateSceneViewRequestDataAttributes
   */
  excludePrunedItems?: boolean;
  /**
   * Number of seconds before expiration. Defaults to 24 hours in seconds. Max is 7 days in seconds
   * @type {number}
   * @memberof CreateSceneViewRequestDataAttributes
   */
  expiry?: number;
}
/**
 *
 * @export
 * @interface CreateSceneViewRequestDataRelationships
 */
export interface CreateSceneViewRequestDataRelationships {
  /**
   *
   * @type {SceneViewStateRelationship}
   * @memberof CreateSceneViewRequestDataRelationships
   */
  sceneViewState?: SceneViewStateRelationship;
}
/**
 *
 * @export
 * @interface CreateSceneViewStateRequest
 */
export interface CreateSceneViewStateRequest {
  /**
   *
   * @type {CreateSceneViewStateRequestData}
   * @memberof CreateSceneViewStateRequest
   */
  data: CreateSceneViewStateRequestData;
}
/**
 *
 * @export
 * @interface CreateSceneViewStateRequestData
 */
export interface CreateSceneViewStateRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSceneViewStateRequestData
   */
  type: string;
  /**
   *
   * @type {CreateSceneViewStateRequestDataAttributes}
   * @memberof CreateSceneViewStateRequestData
   */
  attributes: CreateSceneViewStateRequestDataAttributes;
  /**
   *
   * @type {CreateSceneViewStateRequestDataRelationships}
   * @memberof CreateSceneViewStateRequestData
   */
  relationships: CreateSceneViewStateRequestDataRelationships;
}
/**
 *
 * @export
 * @interface CreateSceneViewStateRequestDataAttributes
 */
export interface CreateSceneViewStateRequestDataAttributes {
  /**
   *
   * @type {string}
   * @memberof CreateSceneViewStateRequestDataAttributes
   */
  name?: string;
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof CreateSceneViewStateRequestDataAttributes
   */
  suppliedId?: string;
}
/**
 *
 * @export
 * @interface CreateSceneViewStateRequestDataRelationships
 */
export interface CreateSceneViewStateRequestDataRelationships {
  /**
   *
   * @type {SceneViewRelationship | SceneViewStateRelationship}
   * @memberof CreateSceneViewStateRequestDataRelationships
   */
  source: SceneViewRelationship | SceneViewStateRelationship;
}
/**
 *
 * @export
 * @interface CreateSearchSessionRequest
 */
export interface CreateSearchSessionRequest {
  /**
   *
   * @type {CreateSearchSessionRequestData}
   * @memberof CreateSearchSessionRequest
   */
  data: CreateSearchSessionRequestData;
}
/**
 *
 * @export
 * @interface CreateSearchSessionRequestData
 */
export interface CreateSearchSessionRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSearchSessionRequestData
   */
  type: CreateSearchSessionRequestDataTypeEnum;
  /**
   *
   * @type {CreateSearchSessionRequestDataAttributes}
   * @memberof CreateSearchSessionRequestData
   */
  attributes: CreateSearchSessionRequestDataAttributes;
  /**
   *
   * @type {CreateSearchSessionRequestDataRelationships}
   * @memberof CreateSearchSessionRequestData
   */
  relationships: CreateSearchSessionRequestDataRelationships;
}

export const CreateSearchSessionRequestDataTypeEnum = {
  SearchSession: 'search-session',
} as const;

export type CreateSearchSessionRequestDataTypeEnum =
  (typeof CreateSearchSessionRequestDataTypeEnum)[keyof typeof CreateSearchSessionRequestDataTypeEnum];

/**
 *
 * @export
 * @interface CreateSearchSessionRequestDataAttributes
 */
export interface CreateSearchSessionRequestDataAttributes {
  /**
   * Number of seconds before the search session is deleted.
   * @type {number}
   * @memberof CreateSearchSessionRequestDataAttributes
   */
  expiry?: number;
}
/**
 *
 * @export
 * @interface CreateSearchSessionRequestDataRelationships
 */
export interface CreateSearchSessionRequestDataRelationships {
  /**
   *
   * @type {SceneRelationship}
   * @memberof CreateSearchSessionRequestDataRelationships
   */
  scene?: SceneRelationship;
}
/**
 *
 * @export
 * @interface CreateStreamKeyRequest
 */
export interface CreateStreamKeyRequest {
  /**
   *
   * @type {CreateStreamKeyRequestData}
   * @memberof CreateStreamKeyRequest
   */
  data: CreateStreamKeyRequestData;
}
/**
 *
 * @export
 * @interface CreateStreamKeyRequestData
 */
export interface CreateStreamKeyRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateStreamKeyRequestData
   */
  type: string;
  /**
   *
   * @type {CreateStreamKeyRequestDataAttributes}
   * @memberof CreateStreamKeyRequestData
   */
  attributes: CreateStreamKeyRequestDataAttributes;
}
/**
 *
 * @export
 * @interface CreateStreamKeyRequestDataAttributes
 */
export interface CreateStreamKeyRequestDataAttributes {
  /**
   * Number of seconds before the `stream-key` expires.
   * @type {number}
   * @memberof CreateStreamKeyRequestDataAttributes
   */
  expiry?: number;
  /**
   * Whether to exclude non-visible items in the view.
   * @type {boolean}
   * @memberof CreateStreamKeyRequestDataAttributes
   */
  excludePrunedItems?: boolean;
  /**
   * An optional supplied ID specifying the `scene-view-state` to initialize `scene-view`s created using this `stream-key` to. Mutually exclusive with `sceneViewStateId`.
   * @type {string}
   * @memberof CreateStreamKeyRequestDataAttributes
   */
  sceneViewStateSuppliedId?: string;
  /**
   * An optional ID specifying the `scene-view-state` to initialize `scene-view`s created using this `stream-key` to. Mutually exclusive with `sceneViewStateSuppliedId`.
   * @type {string}
   * @memberof CreateStreamKeyRequestDataAttributes
   */
  sceneViewStateId?: string;
  /**
   * Optionally enables or disables the creation of a search session for the view. The default creates a session for the scene-view
   * @type {boolean}
   * @memberof CreateStreamKeyRequestDataAttributes
   */
  withSearchSession?: boolean;
}
/**
 *
 * @export
 * @interface CreateThreadRequest
 */
export interface CreateThreadRequest {
  /**
   *
   * @type {CreateThreadRequestData}
   * @memberof CreateThreadRequest
   */
  data: CreateThreadRequestData;
}
/**
 *
 * @export
 * @interface CreateThreadRequestData
 */
export interface CreateThreadRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateThreadRequestData
   */
  type: CreateThreadRequestDataTypeEnum;
  /**
   *
   * @type {CreateThreadRequestDataAttributes}
   * @memberof CreateThreadRequestData
   */
  attributes: CreateThreadRequestDataAttributes;
}

export const CreateThreadRequestDataTypeEnum = {
  Thread: 'thread',
} as const;

export type CreateThreadRequestDataTypeEnum =
  (typeof CreateThreadRequestDataTypeEnum)[keyof typeof CreateThreadRequestDataTypeEnum];

/**
 *
 * @export
 * @interface CreateThreadRequestDataAttributes
 */
export interface CreateThreadRequestDataAttributes {
  /**
   *
   * @type {ThreadType}
   * @memberof CreateThreadRequestDataAttributes
   */
  type: ThreadType;
  /**
   *
   * @type {ThreadStatus}
   * @memberof CreateThreadRequestDataAttributes
   */
  status: ThreadStatus;
  /**
   *
   * @type {string}
   * @memberof CreateThreadRequestDataAttributes
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof CreateThreadRequestDataAttributes
   */
  body?: string;
  /**
   *
   * @type {boolean}
   * @memberof CreateThreadRequestDataAttributes
   */
  isDrafting?: boolean;
  /**
   *
   * @type {CreateSceneReference}
   * @memberof CreateThreadRequestDataAttributes
   */
  reference?: CreateSceneReference;
}
/**
 *
 * @export
 * @interface CreateTranslationInspectionRequest
 */
export interface CreateTranslationInspectionRequest {
  /**
   *
   * @type {CreateTranslationInspectionRequestData}
   * @memberof CreateTranslationInspectionRequest
   */
  data: CreateTranslationInspectionRequestData;
}
/**
 *
 * @export
 * @interface CreateTranslationInspectionRequestData
 */
export interface CreateTranslationInspectionRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateTranslationInspectionRequestData
   */
  type: string;
  /**
   *
   * @type {CreateGeometrySetRequestDataRelationships}
   * @memberof CreateTranslationInspectionRequestData
   */
  relationships: CreateGeometrySetRequestDataRelationships;
}
/**
 *
 * @export
 * @interface CreateUploadRequest
 */
export interface CreateUploadRequest {
  /**
   *
   * @type {CreateUploadRequestData}
   * @memberof CreateUploadRequest
   */
  data: CreateUploadRequestData;
}
/**
 *
 * @export
 * @interface CreateUploadRequestData
 */
export interface CreateUploadRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateUploadRequestData
   */
  type: string;
  /**
   *
   * @type {CreateUploadRequestDataAttributes}
   * @memberof CreateUploadRequestData
   */
  attributes: CreateUploadRequestDataAttributes;
}
/**
 *
 * @export
 * @interface CreateUploadRequestDataAttributes
 */
export interface CreateUploadRequestDataAttributes {
  /**
   * Specifies the duration for which this pre-signed request should be valid for upload. After this time has expired, attempting to use the presigned request will fail. (Defaults to 1 hour, max value is 24 hours)
   * @type {number}
   * @memberof CreateUploadRequestDataAttributes
   */
  expiry?: number;
}
/**
 *
 * @export
 * @interface CreateUserGroupRequest
 */
export interface CreateUserGroupRequest {
  /**
   *
   * @type {CreateUserGroupRequestData}
   * @memberof CreateUserGroupRequest
   */
  data: CreateUserGroupRequestData;
}
/**
 *
 * @export
 * @interface CreateUserGroupRequestData
 */
export interface CreateUserGroupRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateUserGroupRequestData
   */
  type: CreateUserGroupRequestDataTypeEnum;
  /**
   *
   * @type {CreateUserGroupRequestDataAttributes}
   * @memberof CreateUserGroupRequestData
   */
  attributes: CreateUserGroupRequestDataAttributes;
}

export const CreateUserGroupRequestDataTypeEnum = {
  UserGroup: 'user-group',
} as const;

export type CreateUserGroupRequestDataTypeEnum =
  (typeof CreateUserGroupRequestDataTypeEnum)[keyof typeof CreateUserGroupRequestDataTypeEnum];

/**
 *
 * @export
 * @interface CreateUserGroupRequestDataAttributes
 */
export interface CreateUserGroupRequestDataAttributes {
  /**
   * Name of the user group.
   * @type {string}
   * @memberof CreateUserGroupRequestDataAttributes
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof CreateUserGroupRequestDataAttributes
   */
  suppliedId?: string;
}
/**
 *
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
  /**
   *
   * @type {CreateUserRequestData}
   * @memberof CreateUserRequest
   */
  data: CreateUserRequestData;
}
/**
 *
 * @export
 * @interface CreateUserRequestData
 */
export interface CreateUserRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateUserRequestData
   */
  type: CreateUserRequestDataTypeEnum;
  /**
   *
   * @type {CreateUserRequestDataAttributes}
   * @memberof CreateUserRequestData
   */
  attributes: CreateUserRequestDataAttributes;
}

export const CreateUserRequestDataTypeEnum = {
  User: 'user',
} as const;

export type CreateUserRequestDataTypeEnum =
  (typeof CreateUserRequestDataTypeEnum)[keyof typeof CreateUserRequestDataTypeEnum];

/**
 *
 * @export
 * @interface CreateUserRequestDataAttributes
 */
export interface CreateUserRequestDataAttributes {
  /**
   * Full name of the user.
   * @type {string}
   * @memberof CreateUserRequestDataAttributes
   */
  fullName: string;
  /**
   * Email of the user
   * @type {string}
   * @memberof CreateUserRequestDataAttributes
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof CreateUserRequestDataAttributes
   */
  idpId?: string;
}
/**
 *
 * @export
 * @interface CreateWebhookSubscriptionRequest
 */
export interface CreateWebhookSubscriptionRequest {
  /**
   *
   * @type {CreateWebhookSubscriptionRequestData}
   * @memberof CreateWebhookSubscriptionRequest
   */
  data: CreateWebhookSubscriptionRequestData;
}
/**
 *
 * @export
 * @interface CreateWebhookSubscriptionRequestData
 */
export interface CreateWebhookSubscriptionRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateWebhookSubscriptionRequestData
   */
  type: string;
  /**
   *
   * @type {CreateWebhookSubscriptionRequestDataAttributes}
   * @memberof CreateWebhookSubscriptionRequestData
   */
  attributes: CreateWebhookSubscriptionRequestDataAttributes;
}
/**
 *
 * @export
 * @interface CreateWebhookSubscriptionRequestDataAttributes
 */
export interface CreateWebhookSubscriptionRequestDataAttributes {
  /**
   *
   * @type {string}
   * @memberof CreateWebhookSubscriptionRequestDataAttributes
   */
  url: string;
  /**
   *
   * @type {Array<string>}
   * @memberof CreateWebhookSubscriptionRequestDataAttributes
   */
  topics: Array<string>;
}
/**
 *
 * @export
 * @interface CreatedApplication
 */
export interface CreatedApplication {
  /**
   *
   * @type {CreatedApplicationData}
   * @memberof CreatedApplication
   */
  data: CreatedApplicationData;
}
/**
 *
 * @export
 * @interface CreatedApplicationData
 */
export interface CreatedApplicationData {
  /**
   *
   * @type {string}
   * @memberof CreatedApplicationData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof CreatedApplicationData
   */
  id: string;
  /**
   *
   * @type {CreatedApplicationDataAttributes}
   * @memberof CreatedApplicationData
   */
  attributes: CreatedApplicationDataAttributes;
}
/**
 *
 * @export
 * @interface CreatedApplicationDataAttributes
 */
export interface CreatedApplicationDataAttributes {
  /**
   *
   * @type {string}
   * @memberof CreatedApplicationDataAttributes
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof CreatedApplicationDataAttributes
   */
  clientId: string;
  /**
   *
   * @type {string}
   * @memberof CreatedApplicationDataAttributes
   */
  secret: string;
  /**
   *
   * @type {string}
   * @memberof CreatedApplicationDataAttributes
   */
  created: string;
  /**
   *
   * @type {Array<string>}
   * @memberof CreatedApplicationDataAttributes
   */
  scopes: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof CreatedApplicationDataAttributes
   */
  redirect_uris: Array<string>;
}
/**
 *
 * @export
 * @interface CrossSectioning
 */
export interface CrossSectioning {
  /**
   *
   * @type {Array<SectionPlane>}
   * @memberof CrossSectioning
   */
  planes: Array<SectionPlane>;
}
/**
 * Create Part Assembly
 * @export
 * @interface DeprecatedPartAssemblyRelationship
 */
export interface DeprecatedPartAssemblyRelationship {
  /**
   *
   * @type {DeprecatedPartAssemblyRelationshipData}
   * @memberof DeprecatedPartAssemblyRelationship
   */
  data: DeprecatedPartAssemblyRelationshipData;
}
/**
 *
 * @export
 * @interface DeprecatedPartAssemblyRelationshipData
 */
export interface DeprecatedPartAssemblyRelationshipData {
  /**
   *
   * @type {Array<PartRevisionInstance>}
   * @memberof DeprecatedPartAssemblyRelationshipData
   */
  children: Array<PartRevisionInstance>;
  /**
   * Additional metadata about the `part` and/or `part-revision`. This has been deprecated and replaced by the PATCH endpoint /property-entries
   * @type {{ [key: string]: MetadataLongType | MetadataFloatType | MetadataDateType | MetadataStringType | MetadataNullType; }}
   * @memberof DeprecatedPartAssemblyRelationshipData
   * @deprecated
   */
  metadata?: {
    [key: string]:
      | MetadataLongType
      | MetadataFloatType
      | MetadataDateType
      | MetadataStringType
      | MetadataNullType;
  };
}
/**
 *
 * @export
 * @interface DeselectOperation
 */
export interface DeselectOperation {
  /**
   * Resource object type.
   * @type {string}
   * @memberof DeselectOperation
   */
  type: DeselectOperationTypeEnum;
}

export const DeselectOperationTypeEnum = {
  Deselect: 'deselect',
} as const;

export type DeselectOperationTypeEnum =
  (typeof DeselectOperationTypeEnum)[keyof typeof DeselectOperationTypeEnum];

/**
 * An item\'s height and width.
 * @export
 * @interface Dimensions
 */
export interface Dimensions {
  /**
   * Item\'s height.
   * @type {number}
   * @memberof Dimensions
   */
  height: number;
  /**
   * Item\'s width.
   * @type {number}
   * @memberof Dimensions
   */
  width: number;
}
/**
 *
 * @export
 * @interface DownloadUrl
 */
export interface DownloadUrl {
  /**
   *
   * @type {DownloadUrlData}
   * @memberof DownloadUrl
   */
  data: DownloadUrlData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof DownloadUrl
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface DownloadUrlData
 */
export interface DownloadUrlData {
  /**
   *
   * @type {string}
   * @memberof DownloadUrlData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof DownloadUrlData
   */
  id: string;
  /**
   *
   * @type {DownloadUrlDataAttributes}
   * @memberof DownloadUrlData
   */
  attributes: DownloadUrlDataAttributes;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof DownloadUrlData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface DownloadUrlDataAttributes
 */
export interface DownloadUrlDataAttributes {
  /**
   * Deprecated. Use `uri` instead.
   * @type {string}
   * @memberof DownloadUrlDataAttributes
   * @deprecated
   */
  downloadUrl: string;
  /**
   *
   * @type {string}
   * @memberof DownloadUrlDataAttributes
   */
  uri: string;
}
/**
 *
 * @export
 * @interface Export
 */
export interface Export {
  /**
   *
   * @type {ExportData}
   * @memberof Export
   */
  data: ExportData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof Export
   */
  links?: { [key: string]: Link };
}
/**
 * Describes the options for configuring a file export.
 * @export
 * @interface ExportConfig
 */
export interface ExportConfig {
  /**
   *
   * @type {string}
   * @memberof ExportConfig
   */
  format: string;
}
/**
 *
 * @export
 * @interface ExportData
 */
export interface ExportData {
  /**
   *
   * @type {string}
   * @memberof ExportData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof ExportData
   */
  id: string;
  /**
   *
   * @type {ExportDataAttributes}
   * @memberof ExportData
   */
  attributes: ExportDataAttributes;
  /**
   *
   * @type {ExportDataRelationships}
   * @memberof ExportData
   */
  relationships?: ExportDataRelationships;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof ExportData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface ExportDataAttributes
 */
export interface ExportDataAttributes {
  /**
   *
   * @type {string}
   * @memberof ExportDataAttributes
   */
  created: string;
  /**
   *
   * @type {string}
   * @memberof ExportDataAttributes
   */
  downloadUrl: string;
  /**
   * Number of seconds before the download url for the export expires when retrieving a completed export. The url can be recreated by re-fetching the export.
   * @type {number}
   * @memberof ExportDataAttributes
   */
  downloadUrlExpiry?: number;
}
/**
 *
 * @export
 * @interface ExportDataRelationships
 */
export interface ExportDataRelationships {
  /**
   *
   * @type {FileRelationship}
   * @memberof ExportDataRelationships
   */
  file: FileRelationship;
}
/**
 * Relationship to an `export`.
 * @export
 * @interface ExportRelationship
 */
export interface ExportRelationship {
  /**
   *
   * @type {ExportRelationshipData}
   * @memberof ExportRelationship
   */
  data: ExportRelationshipData;
}
/**
 *
 * @export
 * @interface ExportRelationshipData
 */
export interface ExportRelationshipData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof ExportRelationshipData
   */
  type: ExportRelationshipDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof ExportRelationshipData
   */
  id: string;
}

export const ExportRelationshipDataTypeEnum = {
  Scene: 'scene',
} as const;

export type ExportRelationshipDataTypeEnum =
  (typeof ExportRelationshipDataTypeEnum)[keyof typeof ExportRelationshipDataTypeEnum];

/**
 * Relationship to an `export`.
 * @export
 * @interface ExportStateRelationship
 */
export interface ExportStateRelationship {
  /**
   *
   * @type {ExportStateRelationshipData}
   * @memberof ExportStateRelationship
   */
  data: ExportStateRelationshipData;
}
/**
 *
 * @export
 * @interface ExportStateRelationshipData
 */
export interface ExportStateRelationshipData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof ExportStateRelationshipData
   */
  type: ExportStateRelationshipDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof ExportStateRelationshipData
   */
  id: string;
}

export const ExportStateRelationshipDataTypeEnum = {
  SceneViewState: 'scene-view-state',
} as const;

export type ExportStateRelationshipDataTypeEnum =
  (typeof ExportStateRelationshipDataTypeEnum)[keyof typeof ExportStateRelationshipDataTypeEnum];

/**
 *
 * @export
 * @interface Failure
 */
export interface Failure {
  /**
   *
   * @type {Set<ApiError>}
   * @memberof Failure
   */
  errors: Set<ApiError>;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof Failure
   */
  meta?: { [key: string]: string };
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof Failure
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface FeatureLines
 */
export interface FeatureLines {
  /**
   *
   * @type {Color3}
   * @memberof FeatureLines
   */
  color: Color3;
  /**
   *
   * @type {number}
   * @memberof FeatureLines
   */
  width: number;
}
/**
 *
 * @export
 * @interface FileAttachment
 */
export interface FileAttachment {
  /**
   *
   * @type {string}
   * @memberof FileAttachment
   */
  type: FileAttachmentTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof FileAttachment
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof FileAttachment
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof FileAttachment
   */
  status: string;
  /**
   *
   * @type {number}
   * @memberof FileAttachment
   */
  size?: number;
}

export const FileAttachmentTypeEnum = {
  File: 'file',
} as const;

export type FileAttachmentTypeEnum =
  (typeof FileAttachmentTypeEnum)[keyof typeof FileAttachmentTypeEnum];

/**
 *
 * @export
 * @interface FileCollectionList
 */
export interface FileCollectionList {
  /**
   *
   * @type {Array<FileCollectionMetadataData>}
   * @memberof FileCollectionList
   */
  data: Array<FileCollectionMetadataData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof FileCollectionList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface FileCollectionMetadata
 */
export interface FileCollectionMetadata {
  /**
   *
   * @type {FileCollectionMetadataData}
   * @memberof FileCollectionMetadata
   */
  data: FileCollectionMetadataData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof FileCollectionMetadata
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface FileCollectionMetadataData
 */
export interface FileCollectionMetadataData {
  /**
   *
   * @type {string}
   * @memberof FileCollectionMetadataData
   */
  type: FileCollectionMetadataDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof FileCollectionMetadataData
   */
  id: string;
  /**
   *
   * @type {FileCollectionMetadataDataAttributes}
   * @memberof FileCollectionMetadataData
   */
  attributes: FileCollectionMetadataDataAttributes;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof FileCollectionMetadataData
   */
  links?: { [key: string]: Link };
}

export const FileCollectionMetadataDataTypeEnum = {
  FileCollection: 'file-collection',
} as const;

export type FileCollectionMetadataDataTypeEnum =
  (typeof FileCollectionMetadataDataTypeEnum)[keyof typeof FileCollectionMetadataDataTypeEnum];

/**
 *
 * @export
 * @interface FileCollectionMetadataDataAttributes
 */
export interface FileCollectionMetadataDataAttributes {
  /**
   *
   * @type {string}
   * @memberof FileCollectionMetadataDataAttributes
   */
  name?: string;
  /**
   * ID provided for correlation with external systems, e.g. a PLM system.
   * @type {string}
   * @memberof FileCollectionMetadataDataAttributes
   */
  suppliedId?: string;
  /**
   *
   * @type {string}
   * @memberof FileCollectionMetadataDataAttributes
   */
  created: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof FileCollectionMetadataDataAttributes
   */
  metadata?: { [key: string]: string };
  /**
   *
   * @type {string}
   * @memberof FileCollectionMetadataDataAttributes
   */
  expiresAt?: string;
}
/**
 *
 * @export
 * @interface FileIdList
 */
export interface FileIdList {
  /**
   *
   * @type {Array<string>}
   * @memberof FileIdList
   */
  data: Array<string>;
}
/**
 * The operation for a file archival job.
 * @export
 * @interface FileJobArchiveOperation
 */
export interface FileJobArchiveOperation {
  /**
   *
   * @type {string}
   * @memberof FileJobArchiveOperation
   */
  type: FileJobArchiveOperationTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof FileJobArchiveOperation
   */
  fileId: string;
  /**
   *
   * @type {Array<ArchiveManifestEntry>}
   * @memberof FileJobArchiveOperation
   */
  manifest: Array<ArchiveManifestEntry>;
}

export const FileJobArchiveOperationTypeEnum = {
  FileArchiveOperation: 'file-archive-operation',
} as const;

export type FileJobArchiveOperationTypeEnum =
  (typeof FileJobArchiveOperationTypeEnum)[keyof typeof FileJobArchiveOperationTypeEnum];

/**
 *
 * @export
 * @interface FileList
 */
export interface FileList {
  /**
   *
   * @type {Array<FileMetadataData>}
   * @memberof FileList
   */
  data: Array<FileMetadataData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof FileList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface FileMetadata
 */
export interface FileMetadata {
  /**
   *
   * @type {FileMetadataData}
   * @memberof FileMetadata
   */
  data: FileMetadataData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof FileMetadata
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface FileMetadataData
 */
export interface FileMetadataData {
  /**
   *
   * @type {string}
   * @memberof FileMetadataData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof FileMetadataData
   */
  id: string;
  /**
   *
   * @type {FileMetadataDataAttributes}
   * @memberof FileMetadataData
   */
  attributes: FileMetadataDataAttributes;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof FileMetadataData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface FileMetadataDataAttributes
 */
export interface FileMetadataDataAttributes {
  /**
   *
   * @type {string}
   * @memberof FileMetadataDataAttributes
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof FileMetadataDataAttributes
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof FileMetadataDataAttributes
   */
  suppliedId?: string;
  /**
   *
   * @type {string}
   * @memberof FileMetadataDataAttributes
   */
  rootFileName?: string;
  /**
   *
   * @type {string}
   * @memberof FileMetadataDataAttributes
   */
  created: string;
  /**
   *
   * @type {string}
   * @memberof FileMetadataDataAttributes
   */
  uploaded?: string;
  /**
   *
   * @type {number}
   * @memberof FileMetadataDataAttributes
   */
  size?: number;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof FileMetadataDataAttributes
   */
  metadata?: { [key: string]: string };
  /**
   *
   * @type {string}
   * @memberof FileMetadataDataAttributes
   */
  expiresAt?: string;
}
/**
 * Relationship to a `file`.
 * @export
 * @interface FileRelationship
 */
export interface FileRelationship {
  /**
   *
   * @type {FileRelationshipData}
   * @memberof FileRelationship
   */
  data: FileRelationshipData;
}
/**
 *
 * @export
 * @interface FileRelationshipData
 */
export interface FileRelationshipData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof FileRelationshipData
   */
  type: FileRelationshipDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof FileRelationshipData
   */
  id: string;
}

export const FileRelationshipDataTypeEnum = {
  File: 'file',
} as const;

export type FileRelationshipDataTypeEnum =
  (typeof FileRelationshipDataTypeEnum)[keyof typeof FileRelationshipDataTypeEnum];

/**
 * Describes how an attribute should be filtered.
 * @export
 * @interface FilterExpression
 */
export interface FilterExpression {
  /**
   * A value of a filter.
   * @type {string}
   * @memberof FilterExpression
   */
  eq?: string;
  /**
   * A value of a filter.
   * @type {string}
   * @memberof FilterExpression
   */
  neq?: string;
  /**
   * A value of a filter.
   * @type {string}
   * @memberof FilterExpression
   */
  gt?: string;
  /**
   * A value of a filter.
   * @type {string}
   * @memberof FilterExpression
   */
  gte?: string;
  /**
   * A value of a filter.
   * @type {string}
   * @memberof FilterExpression
   */
  lt?: string;
  /**
   * A value of a filter.
   * @type {string}
   * @memberof FilterExpression
   */
  lte?: string;
  /**
   * A value of a filter.
   * @type {string}
   * @memberof FilterExpression
   */
  contains?: string;
}
/**
 *
 * @export
 * @interface GeometrySet
 */
export interface GeometrySet {
  /**
   *
   * @type {GeometrySetData}
   * @memberof GeometrySet
   */
  data: GeometrySetData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof GeometrySet
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface GeometrySetData
 */
export interface GeometrySetData {
  /**
   *
   * @type {string}
   * @memberof GeometrySetData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof GeometrySetData
   */
  id: string;
  /**
   *
   * @type {HitDataAttributes}
   * @memberof GeometrySetData
   */
  attributes: HitDataAttributes;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof GeometrySetData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface GeometrySetList
 */
export interface GeometrySetList {
  /**
   *
   * @type {Array<GeometrySetData>}
   * @memberof GeometrySetList
   */
  data: Array<GeometrySetData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof GeometrySetList
   */
  links: { [key: string]: Link };
}
/**
 * Relationship to a `geometry-set`.
 * @export
 * @interface GeometrySetRelationship
 */
export interface GeometrySetRelationship {
  /**
   *
   * @type {GeometrySetRelationshipData}
   * @memberof GeometrySetRelationship
   */
  data: GeometrySetRelationshipData;
}
/**
 *
 * @export
 * @interface GeometrySetRelationshipData
 */
export interface GeometrySetRelationshipData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof GeometrySetRelationshipData
   */
  type: GeometrySetRelationshipDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof GeometrySetRelationshipData
   */
  id: string;
}

export const GeometrySetRelationshipDataTypeEnum = {
  GeometrySet: 'geometry-set',
} as const;

export type GeometrySetRelationshipDataTypeEnum =
  (typeof GeometrySetRelationshipDataTypeEnum)[keyof typeof GeometrySetRelationshipDataTypeEnum];

/**
 * A reference to an account receiving a permission grant
 * @export
 * @interface GranteeAccount
 */
export interface GranteeAccount {
  /**
   *
   * @type {string}
   * @memberof GranteeAccount
   */
  type: GranteeAccountTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof GranteeAccount
   */
  id: string;
}

export const GranteeAccountTypeEnum = {
  Account: 'account',
} as const;

export type GranteeAccountTypeEnum =
  (typeof GranteeAccountTypeEnum)[keyof typeof GranteeAccountTypeEnum];

/**
 *
 * @export
 * @interface Hit
 */
export interface Hit {
  /**
   *
   * @type {HitData}
   * @memberof Hit
   */
  data: HitData;
  /**
   *
   * @type {Array<HitResultData | SceneItemData | PartRevisionData>}
   * @memberof Hit
   */
  included: Array<HitResultData | SceneItemData | PartRevisionData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof Hit
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface HitData
 */
export interface HitData {
  /**
   *
   * @type {string}
   * @memberof HitData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof HitData
   */
  id: string;
  /**
   *
   * @type {HitDataAttributes}
   * @memberof HitData
   */
  attributes: HitDataAttributes;
  /**
   *
   * @type {HitDataRelationships}
   * @memberof HitData
   */
  relationships: HitDataRelationships;
}
/**
 *
 * @export
 * @interface HitDataAttributes
 */
export interface HitDataAttributes {
  /**
   *
   * @type {string}
   * @memberof HitDataAttributes
   */
  created: string;
}
/**
 *
 * @export
 * @interface HitDataRelationships
 */
export interface HitDataRelationships {
  /**
   *
   * @type {Array<RelationshipData>}
   * @memberof HitDataRelationships
   */
  results: Array<RelationshipData>;
}
/**
 *
 * @export
 * @interface HitResultData
 */
export interface HitResultData {
  /**
   *
   * @type {string}
   * @memberof HitResultData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof HitResultData
   */
  id: string;
  /**
   *
   * @type {HitResultDataAttributes}
   * @memberof HitResultData
   */
  attributes: HitResultDataAttributes;
  /**
   *
   * @type {HitResultDataRelationships}
   * @memberof HitResultData
   */
  relationships: HitResultDataRelationships;
}
/**
 *
 * @export
 * @interface HitResultDataAttributes
 */
export interface HitResultDataAttributes {
  /**
   *
   * @type {Vector3}
   * @memberof HitResultDataAttributes
   */
  point: Vector3;
  /**
   *
   * @type {Vector3}
   * @memberof HitResultDataAttributes
   */
  normal: Vector3;
}
/**
 *
 * @export
 * @interface HitResultDataRelationships
 */
export interface HitResultDataRelationships {
  /**
   *
   * @type {RelationshipData}
   * @memberof HitResultDataRelationships
   */
  sceneItem: RelationshipData;
}
/**
 *
 * @export
 * @interface Link
 */
export interface Link {
  /**
   *
   * @type {string}
   * @memberof Link
   */
  href: string;
}
/**
 * Color material override.
 * @export
 * @interface MaterialOverride
 */
export interface MaterialOverride {
  /**
   *
   * @type {ColorMaterial}
   * @memberof MaterialOverride
   */
  value?: ColorMaterial;
}
/**
 * 4x4 affine transformation matrix, see [Matrix transformations](https://developer.vertexvis.com/docs/guides/matrix-transformations) for details.
 * @export
 * @interface Matrix4
 */
export interface Matrix4 {
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4
   */
  r0: Vector4;
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4
   */
  r1: Vector4;
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4
   */
  r2: Vector4;
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4
   */
  r3: Vector4;
}
/**
 * 4x4 affine transformation matrix, see [Matrix transformations](https://developer.vertexvis.com/docs/guides/matrix-transformations) for details.
 * @export
 * @interface Matrix4Nullable
 */
export interface Matrix4Nullable {
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4Nullable
   */
  r0: Vector4;
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4Nullable
   */
  r1: Vector4;
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4Nullable
   */
  r2: Vector4;
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4Nullable
   */
  r3: Vector4;
}
/**
 *
 * @export
 * @interface MetadataDateType
 */
export interface MetadataDateType {
  /**
   * Type of metadata value.
   * @type {string}
   * @memberof MetadataDateType
   */
  type: string;
  /**
   * A date value.
   * @type {string}
   * @memberof MetadataDateType
   */
  value: string;
}
/**
 *
 * @export
 * @interface MetadataFloatType
 */
export interface MetadataFloatType {
  /**
   * Type of metadata value.
   * @type {string}
   * @memberof MetadataFloatType
   */
  type: string;
  /**
   * A numerical floating-point value.
   * @type {number}
   * @memberof MetadataFloatType
   */
  value: number;
}
/**
 *
 * @export
 * @interface MetadataLongType
 */
export interface MetadataLongType {
  /**
   * Type of metadata value.
   * @type {string}
   * @memberof MetadataLongType
   */
  type: string;
  /**
   * A numerical long value.
   * @type {number}
   * @memberof MetadataLongType
   */
  value: number;
}
/**
 *
 * @export
 * @interface MetadataNullType
 */
export interface MetadataNullType {
  /**
   * Type of metadata value.
   * @type {string}
   * @memberof MetadataNullType
   */
  type: string;
}
/**
 *
 * @export
 * @interface MetadataStringType
 */
export interface MetadataStringType {
  /**
   * Type of metadata value.
   * @type {string}
   * @memberof MetadataStringType
   */
  type: string;
  /**
   * A string value.
   * @type {string}
   * @memberof MetadataStringType
   */
  value: string;
}
/**
 *
 * @export
 * @interface ModelView
 */
export interface ModelView {
  /**
   *
   * @type {ModelViewData}
   * @memberof ModelView
   */
  data: ModelViewData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof ModelView
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface ModelViewData
 */
export interface ModelViewData {
  /**
   *
   * @type {string}
   * @memberof ModelViewData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof ModelViewData
   */
  id: string;
  /**
   *
   * @type {CreateAccountRequestDataAttributes}
   * @memberof ModelViewData
   */
  attributes: CreateAccountRequestDataAttributes;
  /**
   *
   * @type {ModelViewDataRelationships}
   * @memberof ModelViewData
   */
  relationships: ModelViewDataRelationships;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof ModelViewData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface ModelViewDataRelationships
 */
export interface ModelViewDataRelationships {
  /**
   *
   * @type {PartRevisionRelationship}
   * @memberof ModelViewDataRelationships
   */
  partRevision: PartRevisionRelationship;
}
/**
 *
 * @export
 * @interface ModelViewList
 */
export interface ModelViewList {
  /**
   *
   * @type {Array<ModelViewData>}
   * @memberof ModelViewList
   */
  data: Array<ModelViewData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof ModelViewList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface OAuth2BadRequest
 */
export interface OAuth2BadRequest {
  /**
   *
   * @type {string}
   * @memberof OAuth2BadRequest
   */
  error: string;
}
/**
 *
 * @export
 * @interface OAuth2Token
 */
export interface OAuth2Token {
  /**
   *
   * @type {string}
   * @memberof OAuth2Token
   */
  access_token: string;
  /**
   *
   * @type {string}
   * @memberof OAuth2Token
   */
  token_type: string;
  /**
   *
   * @type {string}
   * @memberof OAuth2Token
   */
  account_id: string;
  /**
   *
   * @type {number}
   * @memberof OAuth2Token
   */
  expires_in: number;
  /**
   *
   * @type {Array<string>}
   * @memberof OAuth2Token
   */
  scopes: Array<string>;
  /**
   *
   * @type {string}
   * @memberof OAuth2Token
   */
  refresh_token?: string;
}
/**
 * Normals describing up & front directions
 * @export
 * @interface Orientation
 */
export interface Orientation {
  /**
   *
   * @type {Vector3}
   * @memberof Orientation
   */
  up: Vector3;
  /**
   *
   * @type {Vector3}
   * @memberof Orientation
   */
  front: Vector3;
}
/**
 * A camera type where an object\'s size stays consistent regardless of its distance to the camera.
 * @export
 * @interface OrthographicCamera
 */
export interface OrthographicCamera {
  /**
   *
   * @type {string}
   * @memberof OrthographicCamera
   */
  type?: string;
  /**
   *
   * @type {Vector3}
   * @memberof OrthographicCamera
   */
  viewVector: Vector3;
  /**
   *
   * @type {Vector3}
   * @memberof OrthographicCamera
   */
  lookAt: Vector3;
  /**
   *
   * @type {Vector3}
   * @memberof OrthographicCamera
   */
  up: Vector3;
  /**
   *
   * @type {number}
   * @memberof OrthographicCamera
   */
  fovHeight: number;
}
/**
 *
 * @export
 * @interface Part
 */
export interface Part {
  /**
   *
   * @type {PartData}
   * @memberof Part
   */
  data: PartData;
  /**
   *
   * @type {Array<PartRevisionData>}
   * @memberof Part
   */
  included?: Array<PartRevisionData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof Part
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface PartData
 */
export interface PartData {
  /**
   *
   * @type {string}
   * @memberof PartData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PartData
   */
  id: string;
  /**
   *
   * @type {PartDataAttributes}
   * @memberof PartData
   */
  attributes: PartDataAttributes;
  /**
   *
   * @type {PartDataRelationships}
   * @memberof PartData
   */
  relationships?: PartDataRelationships;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PartData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface PartDataAttributes
 */
export interface PartDataAttributes {
  /**
   *
   * @type {string}
   * @memberof PartDataAttributes
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof PartDataAttributes
   */
  suppliedId: string;
  /**
   *
   * @type {string}
   * @memberof PartDataAttributes
   */
  created: string;
}
/**
 *
 * @export
 * @interface PartDataRelationships
 */
export interface PartDataRelationships {
  /**
   *
   * @type {Array<PartDataRelationshipsPartRevisions>}
   * @memberof PartDataRelationships
   */
  partRevisions: Array<PartDataRelationshipsPartRevisions>;
  /**
   *
   * @type {AccountRelationship}
   * @memberof PartDataRelationships
   */
  owner?: AccountRelationship;
}
/**
 *
 * @export
 * @interface PartDataRelationshipsPartRevisions
 */
export interface PartDataRelationshipsPartRevisions {
  /**
   * Resource object type.
   * @type {string}
   * @memberof PartDataRelationshipsPartRevisions
   */
  type: PartDataRelationshipsPartRevisionsTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PartDataRelationshipsPartRevisions
   */
  id: string;
}

export const PartDataRelationshipsPartRevisionsTypeEnum = {
  PartRevision: 'part-revision',
} as const;

export type PartDataRelationshipsPartRevisionsTypeEnum =
  (typeof PartDataRelationshipsPartRevisionsTypeEnum)[keyof typeof PartDataRelationshipsPartRevisionsTypeEnum];

/**
 * Relationship to a `part-instance`.
 * @export
 * @interface PartInstanceRelationship
 */
export interface PartInstanceRelationship {
  /**
   *
   * @type {PartInstanceRelationshipData}
   * @memberof PartInstanceRelationship
   */
  data: PartInstanceRelationshipData;
}
/**
 *
 * @export
 * @interface PartInstanceRelationshipData
 */
export interface PartInstanceRelationshipData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof PartInstanceRelationshipData
   */
  type: PartInstanceRelationshipDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PartInstanceRelationshipData
   */
  id: string;
}

export const PartInstanceRelationshipDataTypeEnum = {
  PartInstance: 'part-instance',
} as const;

export type PartInstanceRelationshipDataTypeEnum =
  (typeof PartInstanceRelationshipDataTypeEnum)[keyof typeof PartInstanceRelationshipDataTypeEnum];

/**
 * Part Revision Assembly Instance Data
 * @export
 * @interface PartInstancesRelationship
 */
export interface PartInstancesRelationship {
  /**
   * Each child must include the UUID of the revision. The optional transform may be included to position the child relative to the parent. See the Matrix4 schema for details. Note: The children will be ordered as they appear in the array. Also, it is suggested to not include the transform for any that has identity transform to keep the payload size small. Example file content: {   \"children\": [     { \"id\": \"00000000-0000-0000-0000-000000000001\" },     { \"id\": \"00000000-0000-0000-0000-000000000002\", \"transform\": {       \"r0\": {\"x\": 1, \"y\": -1, \"z\": 0, \"w\": 123.4 },       \"r1\": {\"x\": 1, \"y\": 1, \"z\": 0, \"w\": 234.5 },       \"r2\": {\"x\": 0, \"y\": 0, \"z\": 1, \"w\": 345.6 },       \"r3\": {\"x\": 0, \"y\": 0, \"z\": 0, \"w\": 1 }     }}   ] }
   * @type {Array<PartInstancesRelationshipData>}
   * @memberof PartInstancesRelationship
   */
  data: Array<PartInstancesRelationshipData>;
}
/**
 *
 * @export
 * @interface PartInstancesRelationshipAttributes
 */
export interface PartInstancesRelationshipAttributes {
  /**
   *
   * @type {Matrix4}
   * @memberof PartInstancesRelationshipAttributes
   */
  transform?: Matrix4;
}
/**
 *
 * @export
 * @interface PartInstancesRelationshipData
 */
export interface PartInstancesRelationshipData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof PartInstancesRelationshipData
   */
  type: PartInstancesRelationshipDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PartInstancesRelationshipData
   */
  id: string;
  /**
   *
   * @type {PartInstancesRelationshipAttributes}
   * @memberof PartInstancesRelationshipData
   */
  attributes?: PartInstancesRelationshipAttributes;
}

export const PartInstancesRelationshipDataTypeEnum = {
  PartRevisionInstance: 'part-revision-instance',
} as const;

export type PartInstancesRelationshipDataTypeEnum =
  (typeof PartInstancesRelationshipDataTypeEnum)[keyof typeof PartInstancesRelationshipDataTypeEnum];

/**
 *
 * @export
 * @interface PartList
 */
export interface PartList {
  /**
   *
   * @type {Array<PartData>}
   * @memberof PartList
   */
  data: Array<PartData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PartList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface PartRelationshipData
 */
export interface PartRelationshipData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof PartRelationshipData
   */
  type: PartRelationshipDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PartRelationshipData
   */
  id: string;
}

export const PartRelationshipDataTypeEnum = {
  Part: 'part',
} as const;

export type PartRelationshipDataTypeEnum =
  (typeof PartRelationshipDataTypeEnum)[keyof typeof PartRelationshipDataTypeEnum];

/**
 *
 * @export
 * @interface PartRendition
 */
export interface PartRendition {
  /**
   *
   * @type {PartRenditionData}
   * @memberof PartRendition
   */
  data: PartRenditionData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PartRendition
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface PartRenditionData
 */
export interface PartRenditionData {
  /**
   *
   * @type {string}
   * @memberof PartRenditionData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PartRenditionData
   */
  id: string;
  /**
   *
   * @type {PartRenditionDataAttributes}
   * @memberof PartRenditionData
   */
  attributes: PartRenditionDataAttributes;
  /**
   *
   * @type {PartRenditionDataRelationships}
   * @memberof PartRenditionData
   */
  relationships: PartRenditionDataRelationships;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PartRenditionData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface PartRenditionDataAttributes
 */
export interface PartRenditionDataAttributes {
  /**
   *
   * @type {string}
   * @memberof PartRenditionDataAttributes
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof PartRenditionDataAttributes
   */
  suppliedId?: string;
  /**
   *
   * @type {string}
   * @memberof PartRenditionDataAttributes
   */
  name?: string;
}
/**
 *
 * @export
 * @interface PartRenditionDataRelationships
 */
export interface PartRenditionDataRelationships {
  /**
   *
   * @type {GeometrySetRelationshipData}
   * @memberof PartRenditionDataRelationships
   */
  geometrySet?: GeometrySetRelationshipData;
  /**
   *
   * @type {PartRevisionRelationship}
   * @memberof PartRenditionDataRelationships
   */
  partRevision?: PartRevisionRelationship;
}
/**
 *
 * @export
 * @interface PartRenditionList
 */
export interface PartRenditionList {
  /**
   *
   * @type {Array<PartRenditionData>}
   * @memberof PartRenditionList
   */
  data: Array<PartRenditionData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PartRenditionList
   */
  links: { [key: string]: Link };
}
/**
 * Relationship to a `part-rendition`.
 * @export
 * @interface PartRenditionRelationship
 */
export interface PartRenditionRelationship {
  /**
   *
   * @type {PartRenditionRelationshipData}
   * @memberof PartRenditionRelationship
   */
  data: PartRenditionRelationshipData;
}
/**
 *
 * @export
 * @interface PartRenditionRelationshipData
 */
export interface PartRenditionRelationshipData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof PartRenditionRelationshipData
   */
  type: PartRenditionRelationshipDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PartRenditionRelationshipData
   */
  id: string;
}

export const PartRenditionRelationshipDataTypeEnum = {
  PartRendition: 'part-rendition',
} as const;

export type PartRenditionRelationshipDataTypeEnum =
  (typeof PartRenditionRelationshipDataTypeEnum)[keyof typeof PartRenditionRelationshipDataTypeEnum];

/**
 *
 * @export
 * @interface PartRevision
 */
export interface PartRevision {
  /**
   *
   * @type {PartRevisionData}
   * @memberof PartRevision
   */
  data: PartRevisionData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PartRevision
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface PartRevisionChildren
 */
export interface PartRevisionChildren {
  /**
   * ID of a uploaded file that contains assembly children in JSON format. The file content MUST be a JSON object with a \"children\" array matching the PartAssemblyInstance schema. Each child must include the UUID of the revision. The optional transform may be included to position the child relative to the parent. See the Matrix4 schema for details. Note: The ordinal will not be used even if specified. The children will be ordered as they appear in the array. Also, the suppliedRevisionId will be ignored as it has been deprecated in the PartAssemblyInstance schema. Example file content: {   \"children\": [     { \"revisionId\": \"00000000-0000-0000-0000-000000000001\" },     { \"revisionId\": \"00000000-0000-0000-0000-000000000002\", \"transform\": {       \"r0\": {\"x\": 1, \"y\": 0, \"z\": 0, \"w\": 0 },       \"r1\": {\"x\": 0, \"y\": 1, \"z\": 0, \"w\": 0 },       \"r2\": {\"x\": 0, \"y\": 0, \"z\": 1, \"w\": 0 },       \"r3\": {\"x\": 0, \"y\": 0, \"z\": 0, \"w\": 1 }     }}   ] }
   * @type {FileRelationshipData}
   * @memberof PartRevisionChildren
   */
  data: FileRelationshipData;
}
/**
 *
 * @export
 * @interface PartRevisionData
 */
export interface PartRevisionData {
  /**
   *
   * @type {string}
   * @memberof PartRevisionData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PartRevisionData
   */
  id: string;
  /**
   *
   * @type {PartRevisionDataAttributes}
   * @memberof PartRevisionData
   */
  attributes: PartRevisionDataAttributes;
  /**
   *
   * @type {PartRevisionDataRelationships}
   * @memberof PartRevisionData
   */
  relationships: PartRevisionDataRelationships;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PartRevisionData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface PartRevisionDataAttributes
 */
export interface PartRevisionDataAttributes {
  /**
   *
   * @type {string}
   * @memberof PartRevisionDataAttributes
   */
  created?: string;
  /**
   * This has been deprecated and replaced by the GET endpoint /property-entries
   * @type {{ [key: string]: MetadataLongType | MetadataFloatType | MetadataDateType | MetadataStringType | MetadataNullType; }}
   * @memberof PartRevisionDataAttributes
   * @deprecated
   */
  metadata?: {
    [key: string]:
      | MetadataLongType
      | MetadataFloatType
      | MetadataDateType
      | MetadataStringType
      | MetadataNullType;
  };
  /**
   *
   * @type {string}
   * @memberof PartRevisionDataAttributes
   */
  suppliedId?: string;
  /**
   *
   * @type {string}
   * @memberof PartRevisionDataAttributes
   */
  suppliedIterationId?: string;
  /**
   *
   * @type {string}
   * @memberof PartRevisionDataAttributes
   */
  name?: string;
}
/**
 *
 * @export
 * @interface PartRevisionDataRelationships
 */
export interface PartRevisionDataRelationships {
  /**
   *
   * @type {GeometrySetRelationshipData}
   * @memberof PartRevisionDataRelationships
   */
  geometrySet?: GeometrySetRelationshipData;
  /**
   *
   * @type {PartRelationshipData}
   * @memberof PartRevisionDataRelationships
   */
  part?: PartRelationshipData;
  /**
   *
   * @type {PartRenditionRelationship}
   * @memberof PartRevisionDataRelationships
   */
  defaultPartRendition?: PartRenditionRelationship;
}
/**
 * A reference to an existing PartRevision. Specify one and only one of referenceId or suppliedReferenceId to refer to a revision.
 * @export
 * @interface PartRevisionInstance
 */
export interface PartRevisionInstance {
  /**
   * A 0-based index used for defining a consistent ordering for children of an assembly
   * @type {number}
   * @memberof PartRevisionInstance
   */
  ordinal: number;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PartRevisionInstance
   */
  revisionId?: string;
  /**
   * This has been deprecated. Use instead the revisionId to reference the revision instance. The revisionId can be found by using the [List Part Revisions](#tag/part-revisions/operation/getPartRevisions) endpoint.
   * @type {string}
   * @memberof PartRevisionInstance
   * @deprecated
   */
  suppliedRevisionId?: string;
  /**
   *
   * @type {Matrix4}
   * @memberof PartRevisionInstance
   */
  transform?: Matrix4;
}
/**
 *
 * @export
 * @interface PartRevisionInstanceData
 */
export interface PartRevisionInstanceData {
  /**
   *
   * @type {string}
   * @memberof PartRevisionInstanceData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PartRevisionInstanceData
   */
  id: string;
  /**
   *
   * @type {PartRevisionInstanceDataAttributes}
   * @memberof PartRevisionInstanceData
   */
  attributes: PartRevisionInstanceDataAttributes;
  /**
   *
   * @type {PartRevisionInstanceDataRelationships}
   * @memberof PartRevisionInstanceData
   */
  relationships: PartRevisionInstanceDataRelationships;
}
/**
 *
 * @export
 * @interface PartRevisionInstanceDataAttributes
 */
export interface PartRevisionInstanceDataAttributes {
  /**
   * A 0-based index used for defining a consistent ordering for children of an assembly
   * @type {number}
   * @memberof PartRevisionInstanceDataAttributes
   */
  ordinal?: number;
  /**
   *
   * @type {Matrix4}
   * @memberof PartRevisionInstanceDataAttributes
   */
  transform?: Matrix4;
}
/**
 * This is the relationship from the instance to the parent revision
 * @export
 * @interface PartRevisionInstanceDataRelationships
 */
export interface PartRevisionInstanceDataRelationships {
  /**
   *
   * @type {PartRevisionRelationship}
   * @memberof PartRevisionInstanceDataRelationships
   */
  partRevision: PartRevisionRelationship;
}
/**
 *
 * @export
 * @interface PartRevisionInstanceList
 */
export interface PartRevisionInstanceList {
  /**
   *
   * @type {Array<PartRevisionInstanceData>}
   * @memberof PartRevisionInstanceList
   */
  data: Array<PartRevisionInstanceData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PartRevisionInstanceList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface PartRevisionList
 */
export interface PartRevisionList {
  /**
   *
   * @type {Array<PartRevisionData>}
   * @memberof PartRevisionList
   */
  data: Array<PartRevisionData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PartRevisionList
   */
  links: { [key: string]: Link };
}
/**
 * Relationship to a `part-revision`.
 * @export
 * @interface PartRevisionRelationship
 */
export interface PartRevisionRelationship {
  /**
   *
   * @type {PartDataRelationshipsPartRevisions}
   * @memberof PartRevisionRelationship
   */
  data: PartDataRelationshipsPartRevisions;
}
/**
 *
 * @export
 * @interface PartRevisionSuppliedId
 */
export interface PartRevisionSuppliedId {
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof PartRevisionSuppliedId
   */
  suppliedPartId: string;
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof PartRevisionSuppliedId
   */
  suppliedRevisionId: string;
  /**
   * Optional iteration ID for the revision. For example, a generated version id from a PLM system to a specific revision. Used when a existing revision is modified.
   * @type {string}
   * @memberof PartRevisionSuppliedId
   */
  suppliedIterationId?: string;
}
/**
 * A subject domain encompassing all part resources
 * @export
 * @interface PartsDomainSubject
 */
export interface PartsDomainSubject {
  /**
   *
   * @type {string}
   * @memberof PartsDomainSubject
   */
  domain: PartsDomainSubjectDomainEnum;
}

export const PartsDomainSubjectDomainEnum = {
  Parts: 'parts',
} as const;

export type PartsDomainSubjectDomainEnum =
  (typeof PartsDomainSubjectDomainEnum)[keyof typeof PartsDomainSubjectDomainEnum];

/**
 *
 * @export
 * @interface PermissionGrant
 */
export interface PermissionGrant {
  /**
   *
   * @type {PermissionGrantData}
   * @memberof PermissionGrant
   */
  data: PermissionGrantData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PermissionGrant
   */
  links?: { [key: string]: Link };
}
/**
 * A permission grant tuple
 * @export
 * @interface PermissionGrantData
 */
export interface PermissionGrantData {
  /**
   *
   * @type {string}
   * @memberof PermissionGrantData
   */
  type: PermissionGrantDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PermissionGrantData
   */
  id: string;
  /**
   *
   * @type {CreatePermissionGrantDataAttributes}
   * @memberof PermissionGrantData
   */
  attributes: CreatePermissionGrantDataAttributes;
}

export const PermissionGrantDataTypeEnum = {
  PermissionGrant: 'permission-grant',
} as const;

export type PermissionGrantDataTypeEnum =
  (typeof PermissionGrantDataTypeEnum)[keyof typeof PermissionGrantDataTypeEnum];

/**
 * A list of permission grants
 * @export
 * @interface PermissionGrantList
 */
export interface PermissionGrantList {
  /**
   *
   * @type {Array<PermissionGrant>}
   * @memberof PermissionGrantList
   */
  data: Array<PermissionGrant>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PermissionGrantList
   */
  links: { [key: string]: Link };
}
/**
 * @type PermissionGrantee
 * The grantee portion of a permission grant tuple
 * @export
 */
export type PermissionGrantee = GranteeAccount;

/**
 * @type PermissionSubject
 * A resource category subject to a permission grant
 * @export
 */
export type PermissionSubject = PartsDomainSubject | PropertySetDomainSubject;

/**
 * A camera type that mimics the way the human eye sees.
 * @export
 * @interface PerspectiveCamera
 */
export interface PerspectiveCamera {
  /**
   *
   * @type {string}
   * @memberof PerspectiveCamera
   */
  type?: string;
  /**
   *
   * @type {Vector3}
   * @memberof PerspectiveCamera
   */
  position: Vector3;
  /**
   *
   * @type {Vector3}
   * @memberof PerspectiveCamera
   */
  lookAt: Vector3;
  /**
   *
   * @type {Vector3}
   * @memberof PerspectiveCamera
   */
  up: Vector3;
  /**
   * A numerical floating-point value representing the field of view
   * @type {number}
   * @memberof PerspectiveCamera
   */
  fovY?: number;
}
/**
 *
 * @export
 * @interface PmiAnnotationData
 */
export interface PmiAnnotationData {
  /**
   *
   * @type {string}
   * @memberof PmiAnnotationData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PmiAnnotationData
   */
  id: string;
  /**
   *
   * @type {CreateAccountRequestDataAttributes}
   * @memberof PmiAnnotationData
   */
  attributes: CreateAccountRequestDataAttributes;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PmiAnnotationData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface PmiAnnotationList
 */
export interface PmiAnnotationList {
  /**
   *
   * @type {Array<PmiAnnotationData>}
   * @memberof PmiAnnotationList
   */
  data: Array<PmiAnnotationData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PmiAnnotationList
   */
  links: { [key: string]: Link };
}
/**
 * 2D point.
 * @export
 * @interface Point
 */
export interface Point {
  /**
   * x-axis coordinate.
   * @type {number}
   * @memberof Point
   */
  dx: number;
  /**
   * y-axis coordinate.
   * @type {number}
   * @memberof Point
   */
  dy: number;
}
/**
 *
 * @export
 * @interface PresignedUrl
 */
export interface PresignedUrl {
  /**
   *
   * @type {PresignedUrlData}
   * @memberof PresignedUrl
   */
  data: PresignedUrlData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PresignedUrl
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface PresignedUrlData
 */
export interface PresignedUrlData {
  /**
   *
   * @type {string}
   * @memberof PresignedUrlData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PresignedUrlData
   */
  id: string;
  /**
   *
   * @type {PresignedUrlDataAttributes}
   * @memberof PresignedUrlData
   */
  attributes: PresignedUrlDataAttributes;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PresignedUrlData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface PresignedUrlDataAttributes
 */
export interface PresignedUrlDataAttributes {
  /**
   *
   * @type {string}
   * @memberof PresignedUrlDataAttributes
   */
  uri: string;
}
/**
 *
 * @export
 * @interface PropertyDateType
 */
export interface PropertyDateType {
  /**
   * Type of property value.
   * @type {string}
   * @memberof PropertyDateType
   */
  type: PropertyDateTypeTypeEnum;
  /**
   * A date value.
   * @type {string}
   * @memberof PropertyDateType
   */
  value: string;
}

export const PropertyDateTypeTypeEnum = {
  Date: 'date',
} as const;

export type PropertyDateTypeTypeEnum =
  (typeof PropertyDateTypeTypeEnum)[keyof typeof PropertyDateTypeTypeEnum];

/**
 *
 * @export
 * @interface PropertyDoubleType
 */
export interface PropertyDoubleType {
  /**
   * Type of property value.
   * @type {string}
   * @memberof PropertyDoubleType
   */
  type: PropertyDoubleTypeTypeEnum;
  /**
   *
   * @type {number}
   * @memberof PropertyDoubleType
   */
  value: number;
}

export const PropertyDoubleTypeTypeEnum = {
  Double: 'double',
} as const;

export type PropertyDoubleTypeTypeEnum =
  (typeof PropertyDoubleTypeTypeEnum)[keyof typeof PropertyDoubleTypeTypeEnum];

/**
 *
 * @export
 * @interface PropertyEntryData
 */
export interface PropertyEntryData {
  /**
   *
   * @type {string}
   * @memberof PropertyEntryData
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof PropertyEntryData
   */
  id: string;
  /**
   *
   * @type {PropertyEntryDataAttributes}
   * @memberof PropertyEntryData
   */
  attributes: PropertyEntryDataAttributes;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PropertyEntryData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface PropertyEntryDataAttributes
 */
export interface PropertyEntryDataAttributes {
  /**
   *
   * @type {PropertyStringType | PropertyDoubleType | PropertyLongType | PropertyDateType}
   * @memberof PropertyEntryDataAttributes
   */
  value:
    | PropertyStringType
    | PropertyDoubleType
    | PropertyLongType
    | PropertyDateType;
  /**
   *
   * @type {PropertyKeyType}
   * @memberof PropertyEntryDataAttributes
   */
  key: PropertyKeyType;
}
/**
 *
 * @export
 * @interface PropertyEntryList
 */
export interface PropertyEntryList {
  /**
   *
   * @type {Array<PropertyEntryData>}
   * @memberof PropertyEntryList
   */
  data: Array<PropertyEntryData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PropertyEntryList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface PropertyKeyType
 */
export interface PropertyKeyType {
  /**
   *
   * @type {string}
   * @memberof PropertyKeyType
   */
  name: string;
}
/**
 *
 * @export
 * @interface PropertyLongType
 */
export interface PropertyLongType {
  /**
   * Type of property-entry value.
   * @type {string}
   * @memberof PropertyLongType
   */
  type: PropertyLongTypeTypeEnum;
  /**
   * A numerical long value.
   * @type {number}
   * @memberof PropertyLongType
   */
  value: number;
}

export const PropertyLongTypeTypeEnum = {
  Long: 'long',
} as const;

export type PropertyLongTypeTypeEnum =
  (typeof PropertyLongTypeTypeEnum)[keyof typeof PropertyLongTypeTypeEnum];

/**
 * A subject domain encompassing all property set resources
 * @export
 * @interface PropertySetDomainSubject
 */
export interface PropertySetDomainSubject {
  /**
   *
   * @type {string}
   * @memberof PropertySetDomainSubject
   */
  domain: PropertySetDomainSubjectDomainEnum;
}

export const PropertySetDomainSubjectDomainEnum = {
  PropertySets: 'property-sets',
} as const;

export type PropertySetDomainSubjectDomainEnum =
  (typeof PropertySetDomainSubjectDomainEnum)[keyof typeof PropertySetDomainSubjectDomainEnum];

/**
 * Relationship to a `property-set`.
 * @export
 * @interface PropertySetRelationship
 */
export interface PropertySetRelationship {
  /**
   *
   * @type {PropertySetRelationshipData}
   * @memberof PropertySetRelationship
   */
  data: PropertySetRelationshipData;
}
/**
 *
 * @export
 * @interface PropertySetRelationshipData
 */
export interface PropertySetRelationshipData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof PropertySetRelationshipData
   */
  type: PropertySetRelationshipDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PropertySetRelationshipData
   */
  id: string;
}

export const PropertySetRelationshipDataTypeEnum = {
  PropertySet: 'property-set',
} as const;

export type PropertySetRelationshipDataTypeEnum =
  (typeof PropertySetRelationshipDataTypeEnum)[keyof typeof PropertySetRelationshipDataTypeEnum];

/**
 *
 * @export
 * @interface PropertyStringType
 */
export interface PropertyStringType {
  /**
   * Type of property-entry value.
   * @type {string}
   * @memberof PropertyStringType
   */
  type: PropertyStringTypeTypeEnum;
  /**
   * A string value.
   * @type {string}
   * @memberof PropertyStringType
   */
  value: string;
}

export const PropertyStringTypeTypeEnum = {
  String: 'string',
} as const;

export type PropertyStringTypeTypeEnum =
  (typeof PropertyStringTypeTypeEnum)[keyof typeof PropertyStringTypeTypeEnum];

/**
 * Resource object type.
 * @export
 * @enum {string}
 */

export const QueryAll = {
  All: 'all',
} as const;

export type QueryAll = (typeof QueryAll)[keyof typeof QueryAll];

/**
 *
 * @export
 * @interface QueryByCollection
 */
export interface QueryByCollection {
  /**
   *
   * @type {QueryByCollectionData}
   * @memberof QueryByCollection
   */
  data: QueryByCollectionData;
}
/**
 *
 * @export
 * @interface QueryByCollectionData
 */
export interface QueryByCollectionData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof QueryByCollectionData
   */
  type: QueryByCollectionDataTypeEnum;
  /**
   *
   * @type {QueryByCollectionDataAttributes}
   * @memberof QueryByCollectionData
   */
  attributes: QueryByCollectionDataAttributes;
}

export const QueryByCollectionDataTypeEnum = {
  QueryByCollection: 'query-by-collection',
} as const;

export type QueryByCollectionDataTypeEnum =
  (typeof QueryByCollectionDataTypeEnum)[keyof typeof QueryByCollectionDataTypeEnum];

/**
 *
 * @export
 * @interface QueryByCollectionDataAttributes
 */
export interface QueryByCollectionDataAttributes {
  /**
   * Resource object type.
   * @type {string}
   * @memberof QueryByCollectionDataAttributes
   */
  type: QueryByCollectionDataAttributesTypeEnum;
  /**
   * Query `scene-items`.
   * @type {Array<QueryById>}
   * @memberof QueryByCollectionDataAttributes
   */
  values: Array<QueryById>;
}

export const QueryByCollectionDataAttributesTypeEnum = {
  And: 'and',
  Or: 'or',
} as const;

export type QueryByCollectionDataAttributesTypeEnum =
  (typeof QueryByCollectionDataAttributesTypeEnum)[keyof typeof QueryByCollectionDataAttributesTypeEnum];

/**
 *
 * @export
 * @interface QueryById
 */
export interface QueryById {
  /**
   *
   * @type {QueryByIdData}
   * @memberof QueryById
   */
  data: QueryByIdData;
}
/**
 *
 * @export
 * @interface QueryByIdData
 */
export interface QueryByIdData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof QueryByIdData
   */
  type: QueryByIdDataTypeEnum;
  /**
   *
   * @type {QueryByIdDataAttributes}
   * @memberof QueryByIdData
   */
  attributes: QueryByIdDataAttributes;
}

export const QueryByIdDataTypeEnum = {
  QueryById: 'query-by-id',
} as const;

export type QueryByIdDataTypeEnum =
  (typeof QueryByIdDataTypeEnum)[keyof typeof QueryByIdDataTypeEnum];

/**
 *
 * @export
 * @interface QueryByIdDataAttributes
 */
export interface QueryByIdDataAttributes {
  /**
   * Resource object type.
   * @type {string}
   * @memberof QueryByIdDataAttributes
   */
  type: QueryByIdDataAttributesTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof QueryByIdDataAttributes
   */
  value: string;
}

export const QueryByIdDataAttributesTypeEnum = {
  Id: 'id',
  SuppliedId: 'suppliedId',
} as const;

export type QueryByIdDataAttributesTypeEnum =
  (typeof QueryByIdDataAttributesTypeEnum)[keyof typeof QueryByIdDataAttributesTypeEnum];

/**
 *
 * @export
 * @interface QueryByMetadata
 */
export interface QueryByMetadata {
  /**
   *
   * @type {QueryByMetadataData}
   * @memberof QueryByMetadata
   */
  data: QueryByMetadataData;
}
/**
 *
 * @export
 * @interface QueryByMetadataData
 */
export interface QueryByMetadataData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof QueryByMetadataData
   */
  type: QueryByMetadataDataTypeEnum;
  /**
   *
   * @type {QueryByMetadataDataAttributes}
   * @memberof QueryByMetadataData
   */
  attributes: QueryByMetadataDataAttributes;
}

export const QueryByMetadataDataTypeEnum = {
  QueryByMetadata: 'query-by-metadata',
} as const;

export type QueryByMetadataDataTypeEnum =
  (typeof QueryByMetadataDataTypeEnum)[keyof typeof QueryByMetadataDataTypeEnum];

/**
 *
 * @export
 * @interface QueryByMetadataDataAttributes
 */
export interface QueryByMetadataDataAttributes {
  /**
   *
   * @type {boolean}
   * @memberof QueryByMetadataDataAttributes
   */
  exactMatch?: boolean;
  /**
   *
   * @type {string}
   * @memberof QueryByMetadataDataAttributes
   */
  filter: string;
  /**
   * Query `metadata`.
   * @type {Array<string>}
   * @memberof QueryByMetadataDataAttributes
   */
  keys: Array<string>;
}
/**
 * Query the root items of a scene
 * @export
 * @interface QueryByRoot
 */
export interface QueryByRoot {
  /**
   * Resource object type.
   * @type {string}
   * @memberof QueryByRoot
   */
  type: QueryByRootTypeEnum;
}

export const QueryByRootTypeEnum = {
  QueryByRoot: 'query-by-root',
} as const;

export type QueryByRootTypeEnum =
  (typeof QueryByRootTypeEnum)[keyof typeof QueryByRootTypeEnum];

/**
 *
 * @export
 * @interface QueryBySceneItemId
 */
export interface QueryBySceneItemId {
  /**
   * Resource object type.
   * @type {string}
   * @memberof QueryBySceneItemId
   */
  type: QueryBySceneItemIdTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof QueryBySceneItemId
   */
  value: string;
}

export const QueryBySceneItemIdTypeEnum = {
  Id: 'query-by-id',
  SuppliedId: 'query-by-supplied-id',
} as const;

export type QueryBySceneItemIdTypeEnum =
  (typeof QueryBySceneItemIdTypeEnum)[keyof typeof QueryBySceneItemIdTypeEnum];

/**
 *
 * @export
 * @interface QueryBySceneItemIds
 */
export interface QueryBySceneItemIds {
  /**
   * Resource object type.
   * @type {string}
   * @memberof QueryBySceneItemIds
   */
  type: QueryBySceneItemIdsTypeEnum;
  /**
   * Query `scene-items`.
   * @type {Array<QueryBySceneItemId>}
   * @memberof QueryBySceneItemIds
   */
  values: Array<QueryBySceneItemId>;
}

export const QueryBySceneItemIdsTypeEnum = {
  QueryByCollection: 'query-by-collection',
} as const;

export type QueryBySceneItemIdsTypeEnum =
  (typeof QueryBySceneItemIdsTypeEnum)[keyof typeof QueryBySceneItemIdsTypeEnum];

/**
 *
 * @export
 * @interface QueryBySceneItemMetadata
 */
export interface QueryBySceneItemMetadata {
  /**
   * Resource object type.
   * @type {string}
   * @memberof QueryBySceneItemMetadata
   */
  type: QueryBySceneItemMetadataTypeEnum;
  /**
   *
   * @type {boolean}
   * @memberof QueryBySceneItemMetadata
   */
  exactMatch?: boolean;
  /**
   *
   * @type {string}
   * @memberof QueryBySceneItemMetadata
   */
  filter: string;
  /**
   * Query `metadata`.
   * @type {Array<string>}
   * @memberof QueryBySceneItemMetadata
   */
  keys: Array<string>;
}

export const QueryBySceneItemMetadataTypeEnum = {
  QueryByMetadata: 'query-by-metadata',
} as const;

export type QueryBySceneItemMetadataTypeEnum =
  (typeof QueryBySceneItemMetadataTypeEnum)[keyof typeof QueryBySceneItemMetadataTypeEnum];

/**
 *
 * @export
 * @interface QueryTranslationJobs
 */
export interface QueryTranslationJobs {
  /**
   *
   * @type {QueryTranslationJobsFilter}
   * @memberof QueryTranslationJobs
   */
  filter: QueryTranslationJobsFilter;
}
/**
 *
 * @export
 * @interface QueryTranslationJobsFilter
 */
export interface QueryTranslationJobsFilter {
  /**
   *
   * @type {Array<string>}
   * @memberof QueryTranslationJobsFilter
   */
  jobId: Array<string>;
}
/**
 *
 * @export
 * @interface QueuedJob
 */
export interface QueuedJob {
  /**
   *
   * @type {QueuedJobData}
   * @memberof QueuedJob
   */
  data: QueuedJobData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof QueuedJob
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface QueuedJobData
 */
export interface QueuedJobData {
  /**
   *
   * @type {string}
   * @memberof QueuedJobData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof QueuedJobData
   */
  id: string;
  /**
   *
   * @type {QueuedJobDataAttributes}
   * @memberof QueuedJobData
   */
  attributes: QueuedJobDataAttributes;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof QueuedJobData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface QueuedJobDataAttributes
 */
export interface QueuedJobDataAttributes {
  /**
   *
   * @type {string}
   * @memberof QueuedJobDataAttributes
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof QueuedJobDataAttributes
   */
  created: string;
  /**
   *
   * @type {Set<ApiError>}
   * @memberof QueuedJobDataAttributes
   */
  errors?: Set<ApiError>;
}
/**
 *
 * @export
 * @interface QueuedJobList
 */
export interface QueuedJobList {
  /**
   *
   * @type {Array<QueuedJobData>}
   * @memberof QueuedJobList
   */
  data: Array<QueuedJobData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof QueuedJobList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface QueuedTranslationJob
 */
export interface QueuedTranslationJob {
  /**
   *
   * @type {QueuedTranslationJobData}
   * @memberof QueuedTranslationJob
   */
  data: QueuedTranslationJobData;
  /**
   *
   * @type {Array<GeometrySetData | PartRevisionData | PartRenditionData>}
   * @memberof QueuedTranslationJob
   */
  included?: Array<GeometrySetData | PartRevisionData | PartRenditionData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof QueuedTranslationJob
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface QueuedTranslationJobData
 */
export interface QueuedTranslationJobData {
  /**
   *
   * @type {string}
   * @memberof QueuedTranslationJobData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof QueuedTranslationJobData
   */
  id: string;
  /**
   *
   * @type {QueuedTranslationJobDataAttributes}
   * @memberof QueuedTranslationJobData
   */
  attributes: QueuedTranslationJobDataAttributes;
  /**
   *
   * @type {QueuedTranslationJobDataRelationships}
   * @memberof QueuedTranslationJobData
   */
  relationships?: QueuedTranslationJobDataRelationships;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof QueuedTranslationJobData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface QueuedTranslationJobDataAttributes
 */
export interface QueuedTranslationJobDataAttributes {
  /**
   *
   * @type {string}
   * @memberof QueuedTranslationJobDataAttributes
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof QueuedTranslationJobDataAttributes
   */
  created: string;
  /**
   *
   * @type {string}
   * @memberof QueuedTranslationJobDataAttributes
   */
  completed?: string;
  /**
   *
   * @type {Set<ApiError>}
   * @memberof QueuedTranslationJobDataAttributes
   */
  errors?: Set<ApiError>;
}
/**
 *
 * @export
 * @interface QueuedTranslationJobDataRelationships
 */
export interface QueuedTranslationJobDataRelationships {
  /**
   *
   * @type {GeometrySetRelationship}
   * @memberof QueuedTranslationJobDataRelationships
   */
  geometrySet?: GeometrySetRelationship;
  /**
   *
   * @type {PartRevisionRelationship}
   * @memberof QueuedTranslationJobDataRelationships
   */
  partRevision?: PartRevisionRelationship;
  /**
   *
   * @type {PartRenditionRelationship}
   * @memberof QueuedTranslationJobDataRelationships
   */
  partRendition?: PartRenditionRelationship;
}
/**
 *
 * @export
 * @interface QueuedTranslationJobList
 */
export interface QueuedTranslationJobList {
  /**
   *
   * @type {Array<QueuedTranslationJob>}
   * @memberof QueuedTranslationJobList
   */
  data: Array<QueuedTranslationJob>;
}
/**
 *
 * @export
 * @interface RelationshipData
 */
export interface RelationshipData {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof RelationshipData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof RelationshipData
   */
  type: string;
}
/**
 *
 * @export
 * @interface RelationshipLinks
 */
export interface RelationshipLinks {
  /**
   *
   * @type {string}
   * @memberof RelationshipLinks
   */
  related: string;
}
/**
 *
 * @export
 * @interface Reply
 */
export interface Reply {
  /**
   *
   * @type {ReplyData}
   * @memberof Reply
   */
  data: ReplyData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof Reply
   */
  links?: { [key: string]: Link };
  /**
   *
   * @type {Array<UserData>}
   * @memberof Reply
   */
  included?: Array<UserData>;
}
/**
 *
 * @export
 * @interface ReplyData
 */
export interface ReplyData {
  /**
   *
   * @type {string}
   * @memberof ReplyData
   */
  type: ReplyDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof ReplyData
   */
  id: string;
  /**
   *
   * @type {ReplyDataAttributes}
   * @memberof ReplyData
   */
  attributes: ReplyDataAttributes;
  /**
   *
   * @type {ReplyDataRelationships}
   * @memberof ReplyData
   */
  relationships: ReplyDataRelationships;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof ReplyData
   */
  links?: { [key: string]: Link };
}

export const ReplyDataTypeEnum = {
  Reply: 'reply',
} as const;

export type ReplyDataTypeEnum =
  (typeof ReplyDataTypeEnum)[keyof typeof ReplyDataTypeEnum];

/**
 *
 * @export
 * @interface ReplyDataAttributes
 */
export interface ReplyDataAttributes {
  /**
   *
   * @type {string}
   * @memberof ReplyDataAttributes
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof ReplyDataAttributes
   */
  modifiedAt: string;
  /**
   *
   * @type {string}
   * @memberof ReplyDataAttributes
   */
  editedAt?: string;
  /**
   *
   * @type {string}
   * @memberof ReplyDataAttributes
   */
  body: string;
  /**
   * Indicates whether or not the thread is in a drafted state
   * @type {boolean}
   * @memberof ReplyDataAttributes
   */
  isDrafting: boolean;
}
/**
 *
 * @export
 * @interface ReplyDataRelationships
 */
export interface ReplyDataRelationships {
  /**
   *
   * @type {ThreadRelationship}
   * @memberof ReplyDataRelationships
   */
  thread: ThreadRelationship;
  /**
   *
   * @type {UserRelationship}
   * @memberof ReplyDataRelationships
   */
  user: UserRelationship;
}
/**
 *
 * @export
 * @interface ReplyList
 */
export interface ReplyList {
  /**
   *
   * @type {Array<ReplyData>}
   * @memberof ReplyList
   */
  data: Array<ReplyData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof ReplyList
   */
  links: { [key: string]: Link };
  /**
   *
   * @type {Array<UserData>}
   * @memberof ReplyList
   */
  included?: Array<UserData>;
}
/**
 *
 * @export
 * @interface RevokeOAuth2TokenRequest
 */
export interface RevokeOAuth2TokenRequest {
  /**
   *
   * @type {RevokeOAuth2TokenRequestData}
   * @memberof RevokeOAuth2TokenRequest
   */
  data: RevokeOAuth2TokenRequestData;
}
/**
 *
 * @export
 * @interface RevokeOAuth2TokenRequestData
 */
export interface RevokeOAuth2TokenRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof RevokeOAuth2TokenRequestData
   */
  type: string;
  /**
   *
   * @type {RevokeOAuth2TokenRequestDataAttributes}
   * @memberof RevokeOAuth2TokenRequestData
   */
  attributes: RevokeOAuth2TokenRequestDataAttributes;
}
/**
 *
 * @export
 * @interface RevokeOAuth2TokenRequestDataAttributes
 */
export interface RevokeOAuth2TokenRequestDataAttributes {
  /**
   * Token to revoke.
   * @type {string}
   * @memberof RevokeOAuth2TokenRequestDataAttributes
   */
  token: string;
}
/**
 *
 * @export
 * @interface Scene
 */
export interface Scene {
  /**
   *
   * @type {SceneData}
   * @memberof Scene
   */
  data: SceneData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof Scene
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneAlteration
 */
export interface SceneAlteration {
  /**
   *
   * @type {SceneAlterationData}
   * @memberof SceneAlteration
   */
  data: SceneAlterationData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneAlteration
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneAlterationData
 */
export interface SceneAlterationData {
  /**
   *
   * @type {string}
   * @memberof SceneAlterationData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneAlterationData
   */
  id: string;
  /**
   *
   * @type {HitDataAttributes}
   * @memberof SceneAlterationData
   */
  attributes: HitDataAttributes;
  /**
   *
   * @type {SceneAlterationDataRelationships}
   * @memberof SceneAlterationData
   */
  relationships: SceneAlterationDataRelationships;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneAlterationData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneAlterationDataRelationships
 */
export interface SceneAlterationDataRelationships {
  /**
   *
   * @type {SceneViewRelationship}
   * @memberof SceneAlterationDataRelationships
   */
  sceneView: SceneViewRelationship;
}
/**
 *
 * @export
 * @interface SceneAlterationList
 */
export interface SceneAlterationList {
  /**
   *
   * @type {Array<SceneAlterationData>}
   * @memberof SceneAlterationList
   */
  data: Array<SceneAlterationData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneAlterationList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneAnnotation
 */
export interface SceneAnnotation {
  /**
   *
   * @type {SceneAnnotationData}
   * @memberof SceneAnnotation
   */
  data: SceneAnnotationData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneAnnotation
   */
  links?: { [key: string]: Link };
}
/**
 * A type that describes a callout annotation.
 * @export
 * @interface SceneAnnotationCalloutDataType
 */
export interface SceneAnnotationCalloutDataType {
  /**
   * The type of annotation.
   * @type {string}
   * @memberof SceneAnnotationCalloutDataType
   */
  type: string;
  /**
   *
   * @type {Vector3}
   * @memberof SceneAnnotationCalloutDataType
   */
  position: Vector3;
  /**
   * An optional icon to display for this annotation. See [documentation](https://github.com/Vertexvis/vertex-web-sdk/tree/master/packages/viewer/src/components/viewer-icon#properties) for possible values.
   * @type {string}
   * @memberof SceneAnnotationCalloutDataType
   */
  icon?: string;
  /**
   * A hex color value.
   * @type {string}
   * @memberof SceneAnnotationCalloutDataType
   */
  primaryColor?: string;
  /**
   * A hex color value.
   * @type {string}
   * @memberof SceneAnnotationCalloutDataType
   */
  accentColor?: string;
}
/**
 * A type that describes a custom user provided annotation.
 * @export
 * @interface SceneAnnotationCustomDataType
 */
export interface SceneAnnotationCustomDataType {
  /**
   * The type of annotation.
   * @type {string}
   * @memberof SceneAnnotationCustomDataType
   */
  type: string;
  /**
   * The type of annotation.
   * @type {string}
   * @memberof SceneAnnotationCustomDataType
   */
  jsonType: string;
  /**
   * An encoded JSON string associated with the custom annotation.
   * @type {string}
   * @memberof SceneAnnotationCustomDataType
   */
  json: string;
}
/**
 *
 * @export
 * @interface SceneAnnotationData
 */
export interface SceneAnnotationData {
  /**
   *
   * @type {string}
   * @memberof SceneAnnotationData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneAnnotationData
   */
  id: string;
  /**
   *
   * @type {SceneAnnotationDataAttributes}
   * @memberof SceneAnnotationData
   */
  attributes: SceneAnnotationDataAttributes;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneAnnotationData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneAnnotationDataAttributes
 */
export interface SceneAnnotationDataAttributes {
  /**
   *
   * @type {string}
   * @memberof SceneAnnotationDataAttributes
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof SceneAnnotationDataAttributes
   */
  modifiedAt: string;
  /**
   * The data describing how to render this annotation.
   * @type {SceneAnnotationCalloutDataType | SceneAnnotationCustomDataType}
   * @memberof SceneAnnotationDataAttributes
   */
  data: SceneAnnotationCalloutDataType | SceneAnnotationCustomDataType;
  /**
   *
   * @type {string}
   * @memberof SceneAnnotationDataAttributes
   */
  suppliedId?: string;
}
/**
 *
 * @export
 * @interface SceneAnnotationSet
 */
export interface SceneAnnotationSet {
  /**
   *
   * @type {SceneAnnotationSetData}
   * @memberof SceneAnnotationSet
   */
  data: SceneAnnotationSetData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneAnnotationSet
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneAnnotationSetData
 */
export interface SceneAnnotationSetData {
  /**
   *
   * @type {string}
   * @memberof SceneAnnotationSetData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneAnnotationSetData
   */
  id: string;
  /**
   *
   * @type {SceneAnnotationSetDataAttributes}
   * @memberof SceneAnnotationSetData
   */
  attributes: SceneAnnotationSetDataAttributes;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneAnnotationSetData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneAnnotationSetDataAttributes
 */
export interface SceneAnnotationSetDataAttributes {
  /**
   *
   * @type {string}
   * @memberof SceneAnnotationSetDataAttributes
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof SceneAnnotationSetDataAttributes
   */
  modifiedAt: string;
  /**
   *
   * @type {string}
   * @memberof SceneAnnotationSetDataAttributes
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof SceneAnnotationSetDataAttributes
   */
  suppliedId?: string;
}
/**
 *
 * @export
 * @interface SceneAnnotationSetList
 */
export interface SceneAnnotationSetList {
  /**
   *
   * @type {Array<SceneAnnotationSetData>}
   * @memberof SceneAnnotationSetList
   */
  data: Array<SceneAnnotationSetData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneAnnotationSetList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneData
 */
export interface SceneData {
  /**
   *
   * @type {string}
   * @memberof SceneData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneData
   */
  id: string;
  /**
   *
   * @type {SceneDataAttributes}
   * @memberof SceneData
   */
  attributes: SceneDataAttributes;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneDataAttributes
 */
export interface SceneDataAttributes {
  /**
   *
   * @type {PerspectiveCamera | OrthographicCamera}
   * @memberof SceneDataAttributes
   */
  camera?: PerspectiveCamera | OrthographicCamera;
  /**
   *
   * @type {string}
   * @memberof SceneDataAttributes
   */
  state?: string;
  /**
   *
   * @type {string}
   * @memberof SceneDataAttributes
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof SceneDataAttributes
   */
  suppliedId?: string;
  /**
   *
   * @type {string}
   * @memberof SceneDataAttributes
   */
  name?: string;
  /**
   *
   * @type {boolean}
   * @memberof SceneDataAttributes
   */
  treeEnabled?: boolean;
  /**
   *
   * @type {string}
   * @memberof SceneDataAttributes
   */
  modified?: string;
  /**
   *
   * @type {Orientation}
   * @memberof SceneDataAttributes
   */
  worldOrientation?: Orientation;
  /**
   * The number of scene items in this scene. (This field needs to be explicitly requested)
   * @type {number}
   * @memberof SceneDataAttributes
   */
  sceneItemCount?: number;
  /**
   *
   * @type {string}
   * @memberof SceneDataAttributes
   */
  expiresAt?: string;
  /**
   * User supplied key-value pairs for a scene. You can supply up to 50 entries, with key names limited to 64 characters and values limited to 256 characters.
   * @type {{ [key: string]: string; }}
   * @memberof SceneDataAttributes
   */
  metadata?: { [key: string]: string };
}
/**
 *
 * @export
 * @interface SceneItem
 */
export interface SceneItem {
  /**
   *
   * @type {SceneItemData}
   * @memberof SceneItem
   */
  data: SceneItemData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneItem
   */
  links?: { [key: string]: Link };
}
/**
 * The union of the items of the provided queries
 * @export
 * @interface SceneItemAndExpression
 */
export interface SceneItemAndExpression {
  /**
   * The type of the expression
   * @type {string}
   * @memberof SceneItemAndExpression
   */
  type: SceneItemAndExpressionTypeEnum;
  /**
   *
   * @type {SceneItemQueryOperand | SceneItemAndExpression | SceneItemOrExpression}
   * @memberof SceneItemAndExpression
   */
  left: SceneItemQueryOperand | SceneItemAndExpression | SceneItemOrExpression;
  /**
   *
   * @type {SceneItemQueryOperand | SceneItemAndExpression | SceneItemOrExpression}
   * @memberof SceneItemAndExpression
   */
  right: SceneItemQueryOperand | SceneItemAndExpression | SceneItemOrExpression;
}

export const SceneItemAndExpressionTypeEnum = {
  And: 'and',
} as const;

export type SceneItemAndExpressionTypeEnum =
  (typeof SceneItemAndExpressionTypeEnum)[keyof typeof SceneItemAndExpressionTypeEnum];

/**
 *
 * @export
 * @interface SceneItemData
 */
export interface SceneItemData {
  /**
   *
   * @type {string}
   * @memberof SceneItemData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneItemData
   */
  id: string;
  /**
   *
   * @type {SceneItemDataAttributes}
   * @memberof SceneItemData
   */
  attributes: SceneItemDataAttributes;
  /**
   *
   * @type {SceneItemDataRelationships}
   * @memberof SceneItemData
   */
  relationships: SceneItemDataRelationships;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneItemData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneItemDataAttributes
 */
export interface SceneItemDataAttributes {
  /**
   *
   * @type {BoundingBox}
   * @memberof SceneItemDataAttributes
   */
  boundingBox?: BoundingBox;
  /**
   *
   * @type {string}
   * @memberof SceneItemDataAttributes
   */
  created?: string;
  /**
   *
   * @type {boolean}
   * @memberof SceneItemDataAttributes
   */
  endItem?: boolean;
  /**
   *
   * @type {ColorMaterial}
   * @memberof SceneItemDataAttributes
   */
  materialOverride?: ColorMaterial;
  /**
   * This has been deprecated and replaced by the GET endpoint /property-entries
   * @type {{ [key: string]: MetadataLongType | MetadataFloatType | MetadataDateType | MetadataStringType | MetadataNullType; }}
   * @memberof SceneItemDataAttributes
   * @deprecated
   */
  metadata?: {
    [key: string]:
      | MetadataLongType
      | MetadataFloatType
      | MetadataDateType
      | MetadataStringType
      | MetadataNullType;
  };
  /**
   *
   * @type {string}
   * @memberof SceneItemDataAttributes
   */
  name?: string;
  /**
   *
   * @type {boolean}
   * @memberof SceneItemDataAttributes
   */
  phantom?: boolean;
  /**
   *
   * @type {string}
   * @memberof SceneItemDataAttributes
   */
  suppliedId?: string;
  /**
   *
   * @type {Matrix4}
   * @memberof SceneItemDataAttributes
   */
  transform?: Matrix4;
  /**
   *
   * @type {boolean}
   * @memberof SceneItemDataAttributes
   */
  visible?: boolean;
  /**
   *
   * @type {Matrix4}
   * @memberof SceneItemDataAttributes
   */
  worldTransform?: Matrix4;
}
/**
 *
 * @export
 * @interface SceneItemDataRelationships
 */
export interface SceneItemDataRelationships {
  /**
   *
   * @type {GeometrySetRelationship | PartRevisionRelationship | SceneRelationship | PartRenditionRelationship}
   * @memberof SceneItemDataRelationships
   */
  source?:
    | GeometrySetRelationship
    | PartRevisionRelationship
    | SceneRelationship
    | PartRenditionRelationship;
  /**
   *
   * @type {SceneItemRelationship}
   * @memberof SceneItemDataRelationships
   */
  parent?: SceneItemRelationship;
  /**
   *
   * @type {PartRenditionRelationship}
   * @memberof SceneItemDataRelationships
   */
  partRendition?: PartRenditionRelationship;
}
/**
 *
 * @export
 * @interface SceneItemExpressionOperation
 */
export interface SceneItemExpressionOperation {
  /**
   *
   * @type {SceneItemQueryOperand | SceneItemAndExpression | SceneItemOrExpression}
   * @memberof SceneItemExpressionOperation
   */
  expression:
    | SceneItemQueryOperand
    | SceneItemAndExpression
    | SceneItemOrExpression;
  /**
   * List of changes to perform on `scene-items` matching the query for the operation
   * @type {Array<ChangeVisibilityOp | ChangeMaterialOp | ClearMaterialOp | ChangeTransformOp | ClearTransformOp | SelectOp | DeselectOperation | ClearRenOp | ViewDefaultRenOp | ViewRenByIdOp | ViewRenBySuppliedIdOp | ViewRepByIdOp | ViewRepByPredefinedIdOp | ClearRepOp>}
   * @memberof SceneItemExpressionOperation
   */
  changes: Array<
    | ChangeVisibilityOp
    | ChangeMaterialOp
    | ClearMaterialOp
    | ChangeTransformOp
    | ClearTransformOp
    | SelectOp
    | DeselectOperation
    | ClearRenOp
    | ViewDefaultRenOp
    | ViewRenByIdOp
    | ViewRenBySuppliedIdOp
    | ViewRepByIdOp
    | ViewRepByPredefinedIdOp
    | ClearRepOp
  >;
}
/**
 *
 * @export
 * @interface SceneItemList
 */
export interface SceneItemList {
  /**
   *
   * @type {Array<SceneItemData>}
   * @memberof SceneItemList
   */
  data: Array<SceneItemData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneItemList
   */
  links: { [key: string]: Link };
}
/**
 * The join of the items of the provided queries
 * @export
 * @interface SceneItemOrExpression
 */
export interface SceneItemOrExpression {
  /**
   * The type of the expression
   * @type {string}
   * @memberof SceneItemOrExpression
   */
  type: SceneItemOrExpressionTypeEnum;
  /**
   *
   * @type {SceneItemQueryOperand | SceneItemAndExpression | SceneItemOrExpression}
   * @memberof SceneItemOrExpression
   */
  left: SceneItemQueryOperand | SceneItemAndExpression | SceneItemOrExpression;
  /**
   *
   * @type {SceneItemQueryOperand | SceneItemAndExpression | SceneItemOrExpression}
   * @memberof SceneItemOrExpression
   */
  right: SceneItemQueryOperand | SceneItemAndExpression | SceneItemOrExpression;
}

export const SceneItemOrExpressionTypeEnum = {
  Or: 'or',
} as const;

export type SceneItemOrExpressionTypeEnum =
  (typeof SceneItemOrExpressionTypeEnum)[keyof typeof SceneItemOrExpressionTypeEnum];

/**
 *
 * @export
 * @interface SceneItemOverride
 */
export interface SceneItemOverride {
  /**
   *
   * @type {SceneItemOverrideData}
   * @memberof SceneItemOverride
   */
  data: SceneItemOverrideData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneItemOverride
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneItemOverrideData
 */
export interface SceneItemOverrideData {
  /**
   *
   * @type {string}
   * @memberof SceneItemOverrideData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneItemOverrideData
   */
  id: string;
  /**
   *
   * @type {SceneItemOverrideDataAttributes}
   * @memberof SceneItemOverrideData
   */
  attributes: SceneItemOverrideDataAttributes;
  /**
   *
   * @type {SceneItemOverrideDataRelationships}
   * @memberof SceneItemOverrideData
   */
  relationships: SceneItemOverrideDataRelationships;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneItemOverrideData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneItemOverrideDataAttributes
 */
export interface SceneItemOverrideDataAttributes {
  /**
   *
   * @type {string}
   * @memberof SceneItemOverrideDataAttributes
   */
  created: string;
  /**
   *
   * @type {boolean}
   * @memberof SceneItemOverrideDataAttributes
   */
  visible?: boolean;
  /**
   *
   * @type {Matrix4}
   * @memberof SceneItemOverrideDataAttributes
   */
  transform?: Matrix4;
  /**
   *
   * @type {ColorMaterial}
   * @memberof SceneItemOverrideDataAttributes
   */
  material?: ColorMaterial;
  /**
   *
   * @type {boolean}
   * @memberof SceneItemOverrideDataAttributes
   */
  selected?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SceneItemOverrideDataAttributes
   */
  phantom?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SceneItemOverrideDataAttributes
   */
  endItem?: boolean;
}
/**
 *
 * @export
 * @interface SceneItemOverrideDataRelationships
 */
export interface SceneItemOverrideDataRelationships {
  /**
   *
   * @type {SceneItemRelationship}
   * @memberof SceneItemOverrideDataRelationships
   */
  sceneItem: SceneItemRelationship;
  /**
   *
   * @type {SceneViewRelationship}
   * @memberof SceneItemOverrideDataRelationships
   */
  sceneView: SceneViewRelationship;
}
/**
 *
 * @export
 * @interface SceneItemOverrideList
 */
export interface SceneItemOverrideList {
  /**
   *
   * @type {Array<SceneItemOverrideData>}
   * @memberof SceneItemOverrideList
   */
  data: Array<SceneItemOverrideData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneItemOverrideList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneItemQueryOperand
 */
export interface SceneItemQueryOperand {
  /**
   * The type of the expression denoting it as an operand
   * @type {string}
   * @memberof SceneItemQueryOperand
   */
  type: SceneItemQueryOperandTypeEnum;
  /**
   * Query Operand for searching `scene-items`.
   * @type {QueryBySceneItemId | QueryBySceneItemIds | QueryByRoot | QueryBySceneItemMetadata}
   * @memberof SceneItemQueryOperand
   */
  query:
    | QueryBySceneItemId
    | QueryBySceneItemIds
    | QueryByRoot
    | QueryBySceneItemMetadata;
}

export const SceneItemQueryOperandTypeEnum = {
  QueryOperand: 'query-operand',
} as const;

export type SceneItemQueryOperandTypeEnum =
  (typeof SceneItemQueryOperandTypeEnum)[keyof typeof SceneItemQueryOperandTypeEnum];

/**
 * Relationship to a `scene-item`.
 * @export
 * @interface SceneItemRelationship
 */
export interface SceneItemRelationship {
  /**
   *
   * @type {SceneItemRelationshipData}
   * @memberof SceneItemRelationship
   */
  data: SceneItemRelationshipData;
}
/**
 *
 * @export
 * @interface SceneItemRelationshipData
 */
export interface SceneItemRelationshipData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof SceneItemRelationshipData
   */
  type: SceneItemRelationshipDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneItemRelationshipData
   */
  id: string;
}

export const SceneItemRelationshipDataTypeEnum = {
  SceneItem: 'scene-item',
} as const;

export type SceneItemRelationshipDataTypeEnum =
  (typeof SceneItemRelationshipDataTypeEnum)[keyof typeof SceneItemRelationshipDataTypeEnum];

/**
 *
 * @export
 * @interface SceneList
 */
export interface SceneList {
  /**
   *
   * @type {Array<SceneData>}
   * @memberof SceneList
   */
  data: Array<SceneData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneOperation
 */
export interface SceneOperation {
  /**
   * Query `scene-items`. Use `query-by-collection` to combine multiple queries.
   * @type {QueryById | QueryByCollection | QueryAll | QueryByMetadata}
   * @memberof SceneOperation
   */
  query: QueryById | QueryByCollection | QueryAll | QueryByMetadata;
  /**
   * List of operations to perform on `scene-items` matching the query.
   * @type {Array<ChangeVisibilityOp | ChangeMaterialOp | ClearMaterialOp | ChangeTransformOp | ClearTransformOp | SelectOp | DeselectOperation | ClearRenOp | ViewDefaultRenOp | ViewRenByIdOp | ViewRenBySuppliedIdOp | ViewRepByIdOp | ViewRepByPredefinedIdOp | ClearRepOp>}
   * @memberof SceneOperation
   */
  operations: Array<
    | ChangeVisibilityOp
    | ChangeMaterialOp
    | ClearMaterialOp
    | ChangeTransformOp
    | ClearTransformOp
    | SelectOp
    | DeselectOperation
    | ClearRenOp
    | ViewDefaultRenOp
    | ViewRenByIdOp
    | ViewRenBySuppliedIdOp
    | ViewRepByIdOp
    | ViewRepByPredefinedIdOp
    | ClearRepOp
  >;
}
/**
 * A reference to a scene for a thread.
 * @export
 * @interface SceneReference
 */
export interface SceneReference {
  /**
   *
   * @type {string}
   * @memberof SceneReference
   */
  type: SceneReferenceTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneReference
   */
  sceneId: string;
  /**
   *
   * @type {Vector3}
   * @memberof SceneReference
   */
  position?: Vector3;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneReference
   */
  sceneViewStateId?: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneReference
   */
  sceneItemId?: string;
  /**
   *
   * @type {Array<ThumbnailData>}
   * @memberof SceneReference
   */
  thumbnails: Array<ThumbnailData>;
}

export const SceneReferenceTypeEnum = {
  SceneReference: 'scene-reference',
} as const;

export type SceneReferenceTypeEnum =
  (typeof SceneReferenceTypeEnum)[keyof typeof SceneReferenceTypeEnum];

/**
 * Relationship to a `scene`.
 * @export
 * @interface SceneRelationship
 */
export interface SceneRelationship {
  /**
   *
   * @type {SceneRelationshipData}
   * @memberof SceneRelationship
   */
  data: SceneRelationshipData;
}
/**
 *
 * @export
 * @interface SceneRelationshipData
 */
export interface SceneRelationshipData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof SceneRelationshipData
   */
  type: SceneRelationshipDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneRelationshipData
   */
  id: string;
}

export const SceneRelationshipDataTypeEnum = {
  Scene: 'scene',
} as const;

export type SceneRelationshipDataTypeEnum =
  (typeof SceneRelationshipDataTypeEnum)[keyof typeof SceneRelationshipDataTypeEnum];

/**
 *
 * @export
 * @interface SceneSync
 */
export interface SceneSync {
  /**
   *
   * @type {SceneSyncData}
   * @memberof SceneSync
   */
  data: SceneSyncData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneSync
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneSyncData
 */
export interface SceneSyncData {
  /**
   *
   * @type {string}
   * @memberof SceneSyncData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneSyncData
   */
  id: string;
  /**
   *
   * @type {SceneSyncDataAttributes}
   * @memberof SceneSyncData
   */
  attributes: SceneSyncDataAttributes;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneSyncData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneSyncDataAttributes
 */
export interface SceneSyncDataAttributes {
  /**
   *
   * @type {string}
   * @memberof SceneSyncDataAttributes
   */
  created: string;
  /**
   *
   * @type {string}
   * @memberof SceneSyncDataAttributes
   */
  completedAt: string;
  /**
   *
   * @type {string}
   * @memberof SceneSyncDataAttributes
   */
  status: string;
}
/**
 *
 * @export
 * @interface SceneSyncItemResultData
 */
export interface SceneSyncItemResultData {
  /**
   *
   * @type {string}
   * @memberof SceneSyncItemResultData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneSyncItemResultData
   */
  id: string;
  /**
   *
   * @type {SceneSyncItemResultDataAttributes}
   * @memberof SceneSyncItemResultData
   */
  attributes: SceneSyncItemResultDataAttributes;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneSyncItemResultData
   */
  links?: { [key: string]: Link };
  /**
   *
   * @type {SceneSyncItemResultDataRelationships}
   * @memberof SceneSyncItemResultData
   */
  relationships: SceneSyncItemResultDataRelationships;
}
/**
 *
 * @export
 * @interface SceneSyncItemResultDataAttributes
 */
export interface SceneSyncItemResultDataAttributes {
  /**
   *
   * @type {string}
   * @memberof SceneSyncItemResultDataAttributes
   */
  status: string;
  /**
   *
   * @type {ApiError}
   * @memberof SceneSyncItemResultDataAttributes
   */
  error?: ApiError;
}
/**
 *
 * @export
 * @interface SceneSyncItemResultDataRelationships
 */
export interface SceneSyncItemResultDataRelationships {
  /**
   *
   * @type {SceneRelationship}
   * @memberof SceneSyncItemResultDataRelationships
   */
  scene: SceneRelationship;
  /**
   *
   * @type {SceneItemRelationship}
   * @memberof SceneSyncItemResultDataRelationships
   */
  sceneItem: SceneItemRelationship;
}
/**
 *
 * @export
 * @interface SceneSyncItemResultsList
 */
export interface SceneSyncItemResultsList {
  /**
   *
   * @type {Array<SceneSyncItemResultData>}
   * @memberof SceneSyncItemResultsList
   */
  data: Array<SceneSyncItemResultData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneSyncItemResultsList
   */
  links: { [key: string]: Link };
  /**
   *
   * @type {Array<SceneItemData>}
   * @memberof SceneSyncItemResultsList
   */
  included: Array<SceneItemData>;
}
/**
 *
 * @export
 * @interface SceneView
 */
export interface SceneView {
  /**
   *
   * @type {SceneViewData}
   * @memberof SceneView
   */
  data: SceneViewData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneView
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneViewData
 */
export interface SceneViewData {
  /**
   *
   * @type {string}
   * @memberof SceneViewData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneViewData
   */
  id: string;
  /**
   *
   * @type {SceneViewDataAttributes}
   * @memberof SceneViewData
   */
  attributes: SceneViewDataAttributes;
  /**
   *
   * @type {SceneViewDataRelationships}
   * @memberof SceneViewData
   */
  relationships: SceneViewDataRelationships;
}
/**
 *
 * @export
 * @interface SceneViewDataAttributes
 */
export interface SceneViewDataAttributes {
  /**
   *
   * @type {PerspectiveCamera | OrthographicCamera}
   * @memberof SceneViewDataAttributes
   */
  camera: PerspectiveCamera | OrthographicCamera;
  /**
   *
   * @type {string}
   * @memberof SceneViewDataAttributes
   */
  created: string;
  /**
   *
   * @type {CrossSectioning}
   * @memberof SceneViewDataAttributes
   */
  crossSectioning?: CrossSectioning | null;
  /**
   *
   * @type {Orientation}
   * @memberof SceneViewDataAttributes
   */
  worldOrientation?: Orientation;
  /**
   * Whether to exclude non-visible items in the view
   * @type {boolean}
   * @memberof SceneViewDataAttributes
   */
  excludePrunedItems?: boolean;
}
/**
 *
 * @export
 * @interface SceneViewDataRelationships
 */
export interface SceneViewDataRelationships {
  /**
   *
   * @type {SceneRelationship}
   * @memberof SceneViewDataRelationships
   */
  scene: SceneRelationship;
}
/**
 *
 * @export
 * @interface SceneViewItem
 */
export interface SceneViewItem {
  /**
   *
   * @type {SceneItemData}
   * @memberof SceneViewItem
   */
  data: SceneItemData;
  /**
   *
   * @type {Array<SceneItemOverrideData>}
   * @memberof SceneViewItem
   */
  included?: Array<SceneItemOverrideData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneViewItem
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneViewList
 */
export interface SceneViewList {
  /**
   *
   * @type {Array<SceneViewData>}
   * @memberof SceneViewList
   */
  data: Array<SceneViewData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneViewList
   */
  links: { [key: string]: Link };
}
/**
 * Relationship to a `scene-view`.
 * @export
 * @interface SceneViewRelationship
 */
export interface SceneViewRelationship {
  /**
   *
   * @type {SceneViewRelationshipData}
   * @memberof SceneViewRelationship
   */
  data: SceneViewRelationshipData;
}
/**
 *
 * @export
 * @interface SceneViewRelationshipData
 */
export interface SceneViewRelationshipData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof SceneViewRelationshipData
   */
  type: SceneViewRelationshipDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneViewRelationshipData
   */
  id: string;
}

export const SceneViewRelationshipDataTypeEnum = {
  SceneView: 'scene-view',
} as const;

export type SceneViewRelationshipDataTypeEnum =
  (typeof SceneViewRelationshipDataTypeEnum)[keyof typeof SceneViewRelationshipDataTypeEnum];

/**
 *
 * @export
 * @interface SceneViewState
 */
export interface SceneViewState {
  /**
   *
   * @type {SceneViewStateData}
   * @memberof SceneViewState
   */
  data: SceneViewStateData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneViewState
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneViewStateData
 */
export interface SceneViewStateData {
  /**
   *
   * @type {string}
   * @memberof SceneViewStateData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneViewStateData
   */
  id: string;
  /**
   *
   * @type {SceneViewStateDataAttributes}
   * @memberof SceneViewStateData
   */
  attributes: SceneViewStateDataAttributes;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneViewStateData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneViewStateDataAttributes
 */
export interface SceneViewStateDataAttributes {
  /**
   *
   * @type {PerspectiveCamera | OrthographicCamera}
   * @memberof SceneViewStateDataAttributes
   */
  camera?: PerspectiveCamera | OrthographicCamera;
  /**
   *
   * @type {string}
   * @memberof SceneViewStateDataAttributes
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof SceneViewStateDataAttributes
   */
  name?: string;
  /**
   *
   * @type {Array<ThumbnailData>}
   * @memberof SceneViewStateDataAttributes
   */
  thumbnails?: Array<ThumbnailData>;
  /**
   *
   * @type {FeatureLines}
   * @memberof SceneViewStateDataAttributes
   */
  featureLines?: FeatureLines;
  /**
   *
   * @type {boolean}
   * @memberof SceneViewStateDataAttributes
   */
  noDefaultLights?: boolean;
  /**
   *
   * @type {string}
   * @memberof SceneViewStateDataAttributes
   */
  suppliedId?: string;
}
/**
 *
 * @export
 * @interface SceneViewStateList
 */
export interface SceneViewStateList {
  /**
   *
   * @type {Array<SceneViewStateData>}
   * @memberof SceneViewStateList
   */
  data: Array<SceneViewStateData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneViewStateList
   */
  links: { [key: string]: Link };
}
/**
 * Relationship to a `scene-view-state`.
 * @export
 * @interface SceneViewStateRelationship
 */
export interface SceneViewStateRelationship {
  /**
   *
   * @type {SceneViewStateRelationshipData}
   * @memberof SceneViewStateRelationship
   */
  data: SceneViewStateRelationshipData;
}
/**
 *
 * @export
 * @interface SceneViewStateRelationshipData
 */
export interface SceneViewStateRelationshipData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof SceneViewStateRelationshipData
   */
  type: SceneViewStateRelationshipDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneViewStateRelationshipData
   */
  id: string;
}

export const SceneViewStateRelationshipDataTypeEnum = {
  SceneViewState: 'scene-view-state',
} as const;

export type SceneViewStateRelationshipDataTypeEnum =
  (typeof SceneViewStateRelationshipDataTypeEnum)[keyof typeof SceneViewStateRelationshipDataTypeEnum];

/**
 *
 * @export
 * @interface SearchSession
 */
export interface SearchSession {
  /**
   *
   * @type {SearchSessionData}
   * @memberof SearchSession
   */
  data: SearchSessionData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SearchSession
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SearchSessionData
 */
export interface SearchSessionData {
  /**
   *
   * @type {string}
   * @memberof SearchSessionData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SearchSessionData
   */
  id: string;
  /**
   *
   * @type {SearchSessionDataAttributes}
   * @memberof SearchSessionData
   */
  attributes: SearchSessionDataAttributes;
  /**
   *
   * @type {SceneViewDataRelationships}
   * @memberof SearchSessionData
   */
  relationships?: SceneViewDataRelationships;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SearchSessionData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SearchSessionDataAttributes
 */
export interface SearchSessionDataAttributes {
  /**
   *
   * @type {string}
   * @memberof SearchSessionDataAttributes
   */
  status: string;
}
/**
 *
 * @export
 * @interface SectionPlane
 */
export interface SectionPlane {
  /**
   *
   * @type {Vector3}
   * @memberof SectionPlane
   */
  normal: Vector3;
  /**
   * Distance from the center point to move the plane.
   * @type {number}
   * @memberof SectionPlane
   */
  offset: number;
}
/**
 * Queries a file by its unique ID.
 * @export
 * @interface SelectFileById
 */
export interface SelectFileById {
  /**
   *
   * @type {string}
   * @memberof SelectFileById
   */
  type: SelectFileByIdTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SelectFileById
   */
  id: string;
}

export const SelectFileByIdTypeEnum = {
  FileById: 'file-by-id',
} as const;

export type SelectFileByIdTypeEnum =
  (typeof SelectFileByIdTypeEnum)[keyof typeof SelectFileByIdTypeEnum];

/**
 * Queries a file by its supplied ID.
 * @export
 * @interface SelectFileBySuppliedId
 */
export interface SelectFileBySuppliedId {
  /**
   *
   * @type {string}
   * @memberof SelectFileBySuppliedId
   */
  type: SelectFileBySuppliedIdTypeEnum;
  /**
   *
   * @type {string}
   * @memberof SelectFileBySuppliedId
   */
  id: string;
}

export const SelectFileBySuppliedIdTypeEnum = {
  FileBySuppliedId: 'file-by-supplied-id',
} as const;

export type SelectFileBySuppliedIdTypeEnum =
  (typeof SelectFileBySuppliedIdTypeEnum)[keyof typeof SelectFileBySuppliedIdTypeEnum];

/**
 *
 * @export
 * @interface SelectOp
 */
export interface SelectOp {
  /**
   * Resource object type.
   * @type {string}
   * @memberof SelectOp
   */
  type: SelectOpTypeEnum;
}

export const SelectOpTypeEnum = {
  Select: 'select',
} as const;

export type SelectOpTypeEnum =
  (typeof SelectOpTypeEnum)[keyof typeof SelectOpTypeEnum];

/**
 *
 * @export
 * @interface StreamKey
 */
export interface StreamKey {
  /**
   *
   * @type {StreamKeyData}
   * @memberof StreamKey
   */
  data: StreamKeyData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof StreamKey
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface StreamKeyData
 */
export interface StreamKeyData {
  /**
   *
   * @type {string}
   * @memberof StreamKeyData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof StreamKeyData
   */
  id: string;
  /**
   *
   * @type {StreamKeyDataAttributes}
   * @memberof StreamKeyData
   */
  attributes: StreamKeyDataAttributes;
  /**
   *
   * @type {SceneViewDataRelationships}
   * @memberof StreamKeyData
   */
  relationships: SceneViewDataRelationships;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof StreamKeyData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface StreamKeyDataAttributes
 */
export interface StreamKeyDataAttributes {
  /**
   *
   * @type {string}
   * @memberof StreamKeyDataAttributes
   */
  key?: string;
  /**
   *
   * @type {number}
   * @memberof StreamKeyDataAttributes
   */
  expiry: number;
  /**
   *
   * @type {string}
   * @memberof StreamKeyDataAttributes
   */
  created: string;
  /**
   *
   * @type {boolean}
   * @memberof StreamKeyDataAttributes
   */
  excludePrunedItems?: boolean;
  /**
   *
   * @type {string}
   * @memberof StreamKeyDataAttributes
   */
  sceneViewStateSuppliedId?: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof StreamKeyDataAttributes
   */
  sceneViewStateId?: string;
}
/**
 *
 * @export
 * @interface StreamKeyList
 */
export interface StreamKeyList {
  /**
   *
   * @type {Array<StreamKeyData>}
   * @memberof StreamKeyList
   */
  data: Array<StreamKeyData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof StreamKeyList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface Thread
 */
export interface Thread {
  /**
   *
   * @type {ThreadData}
   * @memberof Thread
   */
  data: ThreadData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof Thread
   */
  links?: { [key: string]: Link };
  /**
   *
   * @type {Array<UserData>}
   * @memberof Thread
   */
  included?: Array<UserData>;
}
/**
 *
 * @export
 * @interface ThreadData
 */
export interface ThreadData {
  /**
   *
   * @type {string}
   * @memberof ThreadData
   */
  type: ThreadDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof ThreadData
   */
  id: string;
  /**
   *
   * @type {ThreadDataAttributes}
   * @memberof ThreadData
   */
  attributes: ThreadDataAttributes;
  /**
   *
   * @type {ThreadDataRelationships}
   * @memberof ThreadData
   */
  relationships: ThreadDataRelationships;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof ThreadData
   */
  links?: { [key: string]: Link };
}

export const ThreadDataTypeEnum = {
  Thread: 'thread',
} as const;

export type ThreadDataTypeEnum =
  (typeof ThreadDataTypeEnum)[keyof typeof ThreadDataTypeEnum];

/**
 *
 * @export
 * @interface ThreadDataAttributes
 */
export interface ThreadDataAttributes {
  /**
   *
   * @type {string}
   * @memberof ThreadDataAttributes
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof ThreadDataAttributes
   */
  modifiedAt: string;
  /**
   *
   * @type {string}
   * @memberof ThreadDataAttributes
   */
  editedAt?: string;
  /**
   *
   * @type {ThreadType}
   * @memberof ThreadDataAttributes
   */
  type: ThreadType;
  /**
   *
   * @type {ThreadStatus}
   * @memberof ThreadDataAttributes
   */
  status: ThreadStatus;
  /**
   *
   * @type {string}
   * @memberof ThreadDataAttributes
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof ThreadDataAttributes
   */
  body?: string;
  /**
   * Indicates whether or not the thread is in a drafted state
   * @type {boolean}
   * @memberof ThreadDataAttributes
   */
  isDrafting: boolean;
  /**
   *
   * @type {number}
   * @memberof ThreadDataAttributes
   */
  replyCount?: number;
  /**
   *
   * @type {SceneReference}
   * @memberof ThreadDataAttributes
   */
  reference?: SceneReference;
}
/**
 *
 * @export
 * @interface ThreadDataRelationships
 */
export interface ThreadDataRelationships {
  /**
   *
   * @type {CollaborationContextRelationship}
   * @memberof ThreadDataRelationships
   */
  collaborationContext: CollaborationContextRelationship;
  /**
   *
   * @type {UserRelationship}
   * @memberof ThreadDataRelationships
   */
  user: UserRelationship;
}
/**
 *
 * @export
 * @interface ThreadList
 */
export interface ThreadList {
  /**
   *
   * @type {Array<ThreadData>}
   * @memberof ThreadList
   */
  data: Array<ThreadData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof ThreadList
   */
  links: { [key: string]: Link };
  /**
   *
   * @type {Array<UserData>}
   * @memberof ThreadList
   */
  included?: Array<UserData>;
}
/**
 *
 * @export
 * @interface ThreadRelationship
 */
export interface ThreadRelationship {
  /**
   *
   * @type {ThreadRelationshipData}
   * @memberof ThreadRelationship
   */
  data: ThreadRelationshipData;
}
/**
 *
 * @export
 * @interface ThreadRelationshipData
 */
export interface ThreadRelationshipData {
  /**
   *
   * @type {string}
   * @memberof ThreadRelationshipData
   */
  type: ThreadRelationshipDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof ThreadRelationshipData
   */
  id: string;
}

export const ThreadRelationshipDataTypeEnum = {
  Thread: 'thread',
} as const;

export type ThreadRelationshipDataTypeEnum =
  (typeof ThreadRelationshipDataTypeEnum)[keyof typeof ThreadRelationshipDataTypeEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const ThreadStatus = {
  Open: 'open',
  Resolved: 'resolved',
} as const;

export type ThreadStatus = (typeof ThreadStatus)[keyof typeof ThreadStatus];

/**
 *
 * @export
 * @enum {string}
 */

export const ThreadType = {
  Comment: 'comment',
  Issue: 'issue',
} as const;

export type ThreadType = (typeof ThreadType)[keyof typeof ThreadType];

/**
 *
 * @export
 * @interface ThumbnailData
 */
export interface ThumbnailData {
  /**
   *
   * @type {string}
   * @memberof ThumbnailData
   */
  uri: string;
  /**
   *
   * @type {number}
   * @memberof ThumbnailData
   */
  height: number;
  /**
   *
   * @type {number}
   * @memberof ThumbnailData
   */
  width: number;
}
/**
 *
 * @export
 * @interface TranslationInspectionJob
 */
export interface TranslationInspectionJob {
  /**
   *
   * @type {TranslationInspectionJobData}
   * @memberof TranslationInspectionJob
   */
  data: TranslationInspectionJobData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof TranslationInspectionJob
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface TranslationInspectionJobData
 */
export interface TranslationInspectionJobData {
  /**
   *
   * @type {string}
   * @memberof TranslationInspectionJobData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof TranslationInspectionJobData
   */
  id: string;
  /**
   *
   * @type {TranslationInspectionJobDataAttributes}
   * @memberof TranslationInspectionJobData
   */
  attributes: TranslationInspectionJobDataAttributes;
}
/**
 *
 * @export
 * @interface TranslationInspectionJobDataAttributes
 */
export interface TranslationInspectionJobDataAttributes {
  /**
   *
   * @type {string}
   * @memberof TranslationInspectionJobDataAttributes
   */
  status: string;
  /**
   *
   * @type {Array<string>}
   * @memberof TranslationInspectionJobDataAttributes
   */
  missing: Array<string>;
}
/**
 *
 * @export
 * @interface UpdateAccountRequest
 */
export interface UpdateAccountRequest {
  /**
   *
   * @type {UpdateAccountRequestData}
   * @memberof UpdateAccountRequest
   */
  data: UpdateAccountRequestData;
}
/**
 *
 * @export
 * @interface UpdateAccountRequestData
 */
export interface UpdateAccountRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdateAccountRequestData
   */
  type: string;
  /**
   *
   * @type {UpdateAccountRequestDataAttributes}
   * @memberof UpdateAccountRequestData
   */
  attributes: UpdateAccountRequestDataAttributes;
}
/**
 *
 * @export
 * @interface UpdateAccountRequestDataAttributes
 */
export interface UpdateAccountRequestDataAttributes {
  /**
   *
   * @type {string}
   * @memberof UpdateAccountRequestDataAttributes
   */
  status?: UpdateAccountRequestDataAttributesStatusEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateAccountRequestDataAttributes
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateAccountRequestDataAttributes
   */
  owner?: string;
}

export const UpdateAccountRequestDataAttributesStatusEnum = {
  Active: 'active',
  Disabled: 'disabled',
} as const;

export type UpdateAccountRequestDataAttributesStatusEnum =
  (typeof UpdateAccountRequestDataAttributesStatusEnum)[keyof typeof UpdateAccountRequestDataAttributesStatusEnum];

/**
 *
 * @export
 * @interface UpdateApplicationRequest
 */
export interface UpdateApplicationRequest {
  /**
   *
   * @type {UpdateApplicationRequestData}
   * @memberof UpdateApplicationRequest
   */
  data: UpdateApplicationRequestData;
}
/**
 *
 * @export
 * @interface UpdateApplicationRequestData
 */
export interface UpdateApplicationRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdateApplicationRequestData
   */
  type: string;
  /**
   *
   * @type {UpdateApplicationRequestDataAttributes}
   * @memberof UpdateApplicationRequestData
   */
  attributes: UpdateApplicationRequestDataAttributes;
}
/**
 *
 * @export
 * @interface UpdateApplicationRequestDataAttributes
 */
export interface UpdateApplicationRequestDataAttributes {
  /**
   *
   * @type {string}
   * @memberof UpdateApplicationRequestDataAttributes
   */
  name?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof UpdateApplicationRequestDataAttributes
   */
  redirect_uris?: Array<string>;
}
/**
 *
 * @export
 * @interface UpdateFileCollectionRequest
 */
export interface UpdateFileCollectionRequest {
  /**
   *
   * @type {UpdateFileCollectionRequestData}
   * @memberof UpdateFileCollectionRequest
   */
  data: UpdateFileCollectionRequestData;
}
/**
 *
 * @export
 * @interface UpdateFileCollectionRequestData
 */
export interface UpdateFileCollectionRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdateFileCollectionRequestData
   */
  type: UpdateFileCollectionRequestDataTypeEnum;
  /**
   *
   * @type {UpdateFileCollectionRequestDataAttributes}
   * @memberof UpdateFileCollectionRequestData
   */
  attributes: UpdateFileCollectionRequestDataAttributes;
}

export const UpdateFileCollectionRequestDataTypeEnum = {
  FileCollection: 'file-collection',
} as const;

export type UpdateFileCollectionRequestDataTypeEnum =
  (typeof UpdateFileCollectionRequestDataTypeEnum)[keyof typeof UpdateFileCollectionRequestDataTypeEnum];

/**
 *
 * @export
 * @interface UpdateFileCollectionRequestDataAttributes
 */
export interface UpdateFileCollectionRequestDataAttributes {
  /**
   * Number of seconds before expiration
   * @type {number}
   * @memberof UpdateFileCollectionRequestDataAttributes
   */
  expiry?: number;
  /**
   * Updates to file collection metadata. Null values delete the associated key/value pair.
   * @type {{ [key: string]: string; }}
   * @memberof UpdateFileCollectionRequestDataAttributes
   */
  metadata?: { [key: string]: string };
}
/**
 *
 * @export
 * @interface UpdateFileRequest
 */
export interface UpdateFileRequest {
  /**
   *
   * @type {UpdateFileRequestData}
   * @memberof UpdateFileRequest
   */
  data: UpdateFileRequestData;
}
/**
 *
 * @export
 * @interface UpdateFileRequestData
 */
export interface UpdateFileRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdateFileRequestData
   */
  type: string;
  /**
   *
   * @type {UpdateFileRequestDataAttributes}
   * @memberof UpdateFileRequestData
   */
  attributes: UpdateFileRequestDataAttributes;
}
/**
 *
 * @export
 * @interface UpdateFileRequestDataAttributes
 */
export interface UpdateFileRequestDataAttributes {
  /**
   * Name of the file you would like to rename
   * @type {string}
   * @memberof UpdateFileRequestDataAttributes
   */
  name?: string;
  /**
   * Number of seconds before the file is deleted.
   * @type {number}
   * @memberof UpdateFileRequestDataAttributes
   */
  expiry?: number | null;
  /**
   * Updates to file metadata. Null values delete the associated key/value pair.
   * @type {{ [key: string]: string; }}
   * @memberof UpdateFileRequestDataAttributes
   */
  metadata?: { [key: string]: string };
}
/**
 * An operation that updates items with the specified revision to the default rendition.
 * @export
 * @interface UpdateItemToDefaultRenditionOperation
 */
export interface UpdateItemToDefaultRenditionOperation {
  /**
   *
   * @type {string}
   * @memberof UpdateItemToDefaultRenditionOperation
   */
  type: UpdateItemToDefaultRenditionOperationTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof UpdateItemToDefaultRenditionOperation
   */
  revisionId: string;
}

export const UpdateItemToDefaultRenditionOperationTypeEnum = {
  UpdateToDefaultRendition: 'update-to-default-rendition',
} as const;

export type UpdateItemToDefaultRenditionOperationTypeEnum =
  (typeof UpdateItemToDefaultRenditionOperationTypeEnum)[keyof typeof UpdateItemToDefaultRenditionOperationTypeEnum];

/**
 *
 * @export
 * @interface UpdatePartRequest
 */
export interface UpdatePartRequest {
  /**
   *
   * @type {UpdatePartRequestData}
   * @memberof UpdatePartRequest
   */
  data: UpdatePartRequestData;
}
/**
 *
 * @export
 * @interface UpdatePartRequestData
 */
export interface UpdatePartRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdatePartRequestData
   */
  type: string;
  /**
   *
   * @type {UpdatePartRequestDataAttributes}
   * @memberof UpdatePartRequestData
   */
  attributes: UpdatePartRequestDataAttributes;
}
/**
 *
 * @export
 * @interface UpdatePartRequestDataAttributes
 */
export interface UpdatePartRequestDataAttributes {
  /**
   * Name to be used for the root part.
   * @type {string}
   * @memberof UpdatePartRequestDataAttributes
   */
  name?: string;
}
/**
 *
 * @export
 * @interface UpdatePartRevisionRequest
 */
export interface UpdatePartRevisionRequest {
  /**
   *
   * @type {UpdatePartRevisionRequestData}
   * @memberof UpdatePartRevisionRequest
   */
  data: UpdatePartRevisionRequestData;
}
/**
 * Modify existing part revisions using this endpoint. When specifying a `relationship`, the generated output from that relationship will be used to replace any relationship that is present on the revision prior to the update. For example, sending a file relationship that has geometry will replace the existing geometry on the revision with the new geometry in the given file.
 * @export
 * @interface UpdatePartRevisionRequestData
 */
export interface UpdatePartRevisionRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdatePartRevisionRequestData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof UpdatePartRevisionRequestData
   */
  id: string;
  /**
   *
   * @type {UpdatePartRevisionRequestDataAttributes}
   * @memberof UpdatePartRevisionRequestData
   */
  attributes: UpdatePartRevisionRequestDataAttributes;
  /**
   *
   * @type {UpdatePartRevisionRequestDataRelationships}
   * @memberof UpdatePartRevisionRequestData
   */
  relationships?: UpdatePartRevisionRequestDataRelationships;
}
/**
 *
 * @export
 * @interface UpdatePartRevisionRequestDataAttributes
 */
export interface UpdatePartRevisionRequestDataAttributes {
  /**
   * Metadata about the `part` and/or `part-revision`. This metadata will take precedence over any metadata that belongs to the part file if `indexMetadata` is specified. This has been deprecated and replaced by the PATCH endpoint /property-entries
   * @type {{ [key: string]: MetadataLongType | MetadataFloatType | MetadataDateType | MetadataStringType | MetadataNullType; }}
   * @memberof UpdatePartRevisionRequestDataAttributes
   * @deprecated
   */
  metadata?: {
    [key: string]:
      | MetadataLongType
      | MetadataFloatType
      | MetadataDateType
      | MetadataStringType
      | MetadataNullType;
  };
  /**
   * Whether or not to index metadata in the part file when sending a file relationship - not used otherwise. To ignore metadata from the part file and add your own, pass `false` for `indexMetadata` and supply custom metadata using the `metadata` field.
   * @type {boolean}
   * @memberof UpdatePartRevisionRequestDataAttributes
   */
  indexMetadata?: boolean;
  /**
   * Name to be used for the root part. This will be used when given a file relationship - not used otherwise.
   * @type {string}
   * @memberof UpdatePartRevisionRequestDataAttributes
   */
  name?: string;
  /**
   * Metadata key used to extract an ID used for correlation. This will be used when given a file relationship - not used otherwise.
   * @type {string}
   * @memberof UpdatePartRevisionRequestDataAttributes
   */
  suppliedIdKey?: string;
  /**
   * Metadata key used to extract an ID used for correlation. This will be used when given a file relationship - not used otherwise.
   * @type {string}
   * @memberof UpdatePartRevisionRequestDataAttributes
   */
  suppliedRevisionIdKey?: string;
  /**
   * Metadata key used to extract an ID used for correlation. This will be used when given a file relationship - not used otherwise.
   * @type {string}
   * @memberof UpdatePartRevisionRequestDataAttributes
   */
  suppliedInstanceIdKey?: string;
}
/**
 *
 * @export
 * @interface UpdatePartRevisionRequestDataRelationships
 */
export interface UpdatePartRevisionRequestDataRelationships {
  /**
   *
   * @type {FileRelationship}
   * @memberof UpdatePartRevisionRequestDataRelationships
   */
  source?: FileRelationship;
  /**
   *
   * @type {PartRenditionRelationship}
   * @memberof UpdatePartRevisionRequestDataRelationships
   */
  defaultPartRendition?: PartRenditionRelationship;
  /**
   *
   * @type {PartRevisionChildren}
   * @memberof UpdatePartRevisionRequestDataRelationships
   */
  children?: PartRevisionChildren;
}
/**
 *
 * @export
 * @interface UpdateReplyRequest
 */
export interface UpdateReplyRequest {
  /**
   *
   * @type {UpdateReplyRequestData}
   * @memberof UpdateReplyRequest
   */
  data: UpdateReplyRequestData;
}
/**
 *
 * @export
 * @interface UpdateReplyRequestData
 */
export interface UpdateReplyRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdateReplyRequestData
   */
  type: string;
  /**
   *
   * @type {UpdateReplyRequestDataAttributes}
   * @memberof UpdateReplyRequestData
   */
  attributes: UpdateReplyRequestDataAttributes;
}
/**
 *
 * @export
 * @interface UpdateReplyRequestDataAttributes
 */
export interface UpdateReplyRequestDataAttributes {
  /**
   *
   * @type {string}
   * @memberof UpdateReplyRequestDataAttributes
   */
  body?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof UpdateReplyRequestDataAttributes
   */
  isDrafting?: boolean;
}
/**
 *
 * @export
 * @interface UpdateSceneAnnotationRequest
 */
export interface UpdateSceneAnnotationRequest {
  /**
   *
   * @type {UpdateSceneAnnotationRequestData}
   * @memberof UpdateSceneAnnotationRequest
   */
  data: UpdateSceneAnnotationRequestData;
}
/**
 *
 * @export
 * @interface UpdateSceneAnnotationRequestData
 */
export interface UpdateSceneAnnotationRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdateSceneAnnotationRequestData
   */
  type: string;
  /**
   *
   * @type {UpdateSceneAnnotationRequestDataAttributes}
   * @memberof UpdateSceneAnnotationRequestData
   */
  attributes: UpdateSceneAnnotationRequestDataAttributes;
}
/**
 *
 * @export
 * @interface UpdateSceneAnnotationRequestDataAttributes
 */
export interface UpdateSceneAnnotationRequestDataAttributes {
  /**
   * The data describing how to render this annotation.
   * @type {SceneAnnotationCalloutDataType | SceneAnnotationCustomDataType}
   * @memberof UpdateSceneAnnotationRequestDataAttributes
   */
  data?: SceneAnnotationCalloutDataType | SceneAnnotationCustomDataType;
  /**
   * A customer provided ID used for correlation.
   * @type {string}
   * @memberof UpdateSceneAnnotationRequestDataAttributes
   */
  suppliedId?: string | null;
}
/**
 *
 * @export
 * @interface UpdateSceneItemOverrideRequest
 */
export interface UpdateSceneItemOverrideRequest {
  /**
   *
   * @type {UpdateSceneItemOverrideRequestData}
   * @memberof UpdateSceneItemOverrideRequest
   */
  data: UpdateSceneItemOverrideRequestData;
}
/**
 *
 * @export
 * @interface UpdateSceneItemOverrideRequestData
 */
export interface UpdateSceneItemOverrideRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdateSceneItemOverrideRequestData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof UpdateSceneItemOverrideRequestData
   */
  id: string;
  /**
   *
   * @type {UpdateSceneItemOverrideRequestDataAttributes}
   * @memberof UpdateSceneItemOverrideRequestData
   */
  attributes: UpdateSceneItemOverrideRequestDataAttributes;
}
/**
 *
 * @export
 * @interface UpdateSceneItemOverrideRequestDataAttributes
 */
export interface UpdateSceneItemOverrideRequestDataAttributes {
  /**
   * Item visibility.
   * @type {boolean}
   * @memberof UpdateSceneItemOverrideRequestDataAttributes
   */
  visible?: boolean | null;
  /**
   *
   * @type {Matrix4Nullable}
   * @memberof UpdateSceneItemOverrideRequestDataAttributes
   */
  transform?: Matrix4Nullable | null;
  /**
   *
   * @type {ColorMaterialNullable}
   * @memberof UpdateSceneItemOverrideRequestDataAttributes
   */
  material?: ColorMaterialNullable | null;
  /**
   *
   * @type {boolean}
   * @memberof UpdateSceneItemOverrideRequestDataAttributes
   */
  selected?: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof UpdateSceneItemOverrideRequestDataAttributes
   */
  phantom?: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof UpdateSceneItemOverrideRequestDataAttributes
   */
  endItem?: boolean | null;
}
/**
 *
 * @export
 * @interface UpdateSceneItemRequest
 */
export interface UpdateSceneItemRequest {
  /**
   *
   * @type {UpdateSceneItemRequestData}
   * @memberof UpdateSceneItemRequest
   */
  data: UpdateSceneItemRequestData;
}
/**
 *
 * @export
 * @interface UpdateSceneItemRequestData
 */
export interface UpdateSceneItemRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdateSceneItemRequestData
   */
  type: string;
  /**
   *
   * @type {UpdateSceneItemRequestDataAttributes}
   * @memberof UpdateSceneItemRequestData
   */
  attributes: UpdateSceneItemRequestDataAttributes;
  /**
   *
   * @type {UpdateSceneItemRequestDataRelationships}
   * @memberof UpdateSceneItemRequestData
   */
  relationships?: UpdateSceneItemRequestDataRelationships;
}
/**
 *
 * @export
 * @interface UpdateSceneItemRequestDataAttributes
 */
export interface UpdateSceneItemRequestDataAttributes {
  /**
   * Item visibility.
   * @type {boolean}
   * @memberof UpdateSceneItemRequestDataAttributes
   */
  visible?: boolean;
  /**
   *
   * @type {MaterialOverride}
   * @memberof UpdateSceneItemRequestDataAttributes
   */
  materialOverride?: MaterialOverride;
  /**
   *
   * @type {Matrix4}
   * @memberof UpdateSceneItemRequestDataAttributes
   */
  transform?: Matrix4;
  /**
   *
   * @type {string}
   * @memberof UpdateSceneItemRequestDataAttributes
   */
  name?: string;
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof UpdateSceneItemRequestDataAttributes
   */
  suppliedId?: string;
  /**
   * Additional metadata for the scene-item. This metadata will take precedence over any metadata that belongs to the part file.
   * @type {{ [key: string]: MetadataLongType | MetadataFloatType | MetadataDateType | MetadataStringType | MetadataNullType; }}
   * @memberof UpdateSceneItemRequestDataAttributes
   */
  metadata?: {
    [key: string]:
      | MetadataLongType
      | MetadataFloatType
      | MetadataDateType
      | MetadataStringType
      | MetadataNullType;
  };
  /**
   * Phantom state of the item.
   * @type {boolean}
   * @memberof UpdateSceneItemRequestDataAttributes
   */
  phantom?: boolean;
  /**
   * Whether this item is an end item.
   * @type {boolean}
   * @memberof UpdateSceneItemRequestDataAttributes
   */
  endItem?: boolean;
}
/**
 *
 * @export
 * @interface UpdateSceneItemRequestDataRelationships
 */
export interface UpdateSceneItemRequestDataRelationships {
  /**
   * Relationship to a `geometry-set` or `part-revision`.
   * @type {GeometrySetRelationship | PartRevisionRelationship | object}
   * @memberof UpdateSceneItemRequestDataRelationships
   */
  source?: GeometrySetRelationship | PartRevisionRelationship | object | null;
}
/**
 *
 * @export
 * @interface UpdateSceneRequest
 */
export interface UpdateSceneRequest {
  /**
   *
   * @type {UpdateSceneRequestData}
   * @memberof UpdateSceneRequest
   */
  data: UpdateSceneRequestData;
}
/**
 *
 * @export
 * @interface UpdateSceneRequestData
 */
export interface UpdateSceneRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdateSceneRequestData
   */
  type: string;
  /**
   *
   * @type {UpdateSceneRequestDataAttributes}
   * @memberof UpdateSceneRequestData
   */
  attributes: UpdateSceneRequestDataAttributes;
}
/**
 *
 * @export
 * @interface UpdateSceneRequestDataAttributes
 */
export interface UpdateSceneRequestDataAttributes {
  /**
   *
   * @type {PerspectiveCamera | OrthographicCamera | CameraFit}
   * @memberof UpdateSceneRequestDataAttributes
   */
  camera?: PerspectiveCamera | OrthographicCamera | CameraFit;
  /**
   * State of the scene.
   * @type {string}
   * @memberof UpdateSceneRequestDataAttributes
   */
  state?: UpdateSceneRequestDataAttributesStateEnum;
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof UpdateSceneRequestDataAttributes
   */
  suppliedId?: string | null;
  /**
   *
   * @type {string}
   * @memberof UpdateSceneRequestDataAttributes
   */
  name?: string;
  /**
   * Whether or not scene trees can be viewed for this scene.
   * @type {boolean}
   * @memberof UpdateSceneRequestDataAttributes
   */
  treeEnabled?: boolean;
  /**
   *
   * @type {Orientation}
   * @memberof UpdateSceneRequestDataAttributes
   */
  worldOrientation?: Orientation;
  /**
   * Number of seconds before expiration
   * @type {number}
   * @memberof UpdateSceneRequestDataAttributes
   */
  expiry?: number;
  /**
   * User supplied key-value pairs for a scene. You can supply up to 50 entries, with key names limited to 64 characters and values limited to 256 characters. A null value will delete the entry in the map, all other key/value pairs provided here will be inserted or updated into the existing scene metadata.
   * @type {{ [key: string]: string; }}
   * @memberof UpdateSceneRequestDataAttributes
   */
  metadata?: { [key: string]: string };
}

export const UpdateSceneRequestDataAttributesStateEnum = {
  Draft: 'draft',
  Commit: 'commit',
} as const;

export type UpdateSceneRequestDataAttributesStateEnum =
  (typeof UpdateSceneRequestDataAttributesStateEnum)[keyof typeof UpdateSceneRequestDataAttributesStateEnum];

/**
 *
 * @export
 * @interface UpdateSceneViewRequest
 */
export interface UpdateSceneViewRequest {
  /**
   *
   * @type {UpdateSceneViewRequestData}
   * @memberof UpdateSceneViewRequest
   */
  data: UpdateSceneViewRequestData;
}
/**
 *
 * @export
 * @interface UpdateSceneViewRequestData
 */
export interface UpdateSceneViewRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdateSceneViewRequestData
   */
  type: string;
  /**
   *
   * @type {UpdateSceneViewRequestDataAttributes}
   * @memberof UpdateSceneViewRequestData
   */
  attributes: UpdateSceneViewRequestDataAttributes;
}
/**
 *
 * @export
 * @interface UpdateSceneViewRequestDataAttributes
 */
export interface UpdateSceneViewRequestDataAttributes {
  /**
   *
   * @type {PerspectiveCamera | OrthographicCamera | CameraFit}
   * @memberof UpdateSceneViewRequestDataAttributes
   */
  camera?: PerspectiveCamera | OrthographicCamera | CameraFit;
  /**
   *
   * @type {CrossSectioning}
   * @memberof UpdateSceneViewRequestDataAttributes
   */
  crossSectioning?: CrossSectioning | null;
  /**
   * Whether or not to turn off default lighting
   * @type {boolean}
   * @memberof UpdateSceneViewRequestDataAttributes
   */
  noDefaultLights?: boolean;
}
/**
 *
 * @export
 * @interface UpdateSceneViewStateRequest
 */
export interface UpdateSceneViewStateRequest {
  /**
   *
   * @type {UpdateSceneViewStateRequestData}
   * @memberof UpdateSceneViewStateRequest
   */
  data: UpdateSceneViewStateRequestData;
}
/**
 *
 * @export
 * @interface UpdateSceneViewStateRequestData
 */
export interface UpdateSceneViewStateRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdateSceneViewStateRequestData
   */
  type: string;
  /**
   *
   * @type {CreateSceneViewStateRequestDataAttributes}
   * @memberof UpdateSceneViewStateRequestData
   */
  attributes: CreateSceneViewStateRequestDataAttributes;
}
/**
 *
 * @export
 * @interface UpdateThreadRequest
 */
export interface UpdateThreadRequest {
  /**
   *
   * @type {UpdateThreadRequestData}
   * @memberof UpdateThreadRequest
   */
  data: UpdateThreadRequestData;
}
/**
 *
 * @export
 * @interface UpdateThreadRequestData
 */
export interface UpdateThreadRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdateThreadRequestData
   */
  type: string;
  /**
   *
   * @type {UpdateThreadRequestDataAttributes}
   * @memberof UpdateThreadRequestData
   */
  attributes: UpdateThreadRequestDataAttributes;
}
/**
 *
 * @export
 * @interface UpdateThreadRequestDataAttributes
 */
export interface UpdateThreadRequestDataAttributes {
  /**
   *
   * @type {ThreadStatus}
   * @memberof UpdateThreadRequestDataAttributes
   */
  status?: ThreadStatus;
  /**
   *
   * @type {string}
   * @memberof UpdateThreadRequestDataAttributes
   */
  title?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof UpdateThreadRequestDataAttributes
   */
  isDrafting?: boolean;
  /**
   *
   * @type {string}
   * @memberof UpdateThreadRequestDataAttributes
   */
  body?: string | null;
}
/**
 *
 * @export
 * @interface UpdateWebhookSubscriptionRequest
 */
export interface UpdateWebhookSubscriptionRequest {
  /**
   *
   * @type {UpdateWebhookSubscriptionRequestData}
   * @memberof UpdateWebhookSubscriptionRequest
   */
  data: UpdateWebhookSubscriptionRequestData;
}
/**
 *
 * @export
 * @interface UpdateWebhookSubscriptionRequestData
 */
export interface UpdateWebhookSubscriptionRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdateWebhookSubscriptionRequestData
   */
  type: string;
  /**
   *
   * @type {UpdateWebhookSubscriptionRequestDataAttributes}
   * @memberof UpdateWebhookSubscriptionRequestData
   */
  attributes: UpdateWebhookSubscriptionRequestDataAttributes;
}
/**
 *
 * @export
 * @interface UpdateWebhookSubscriptionRequestDataAttributes
 */
export interface UpdateWebhookSubscriptionRequestDataAttributes {
  /**
   * Status of subscription.
   * @type {string}
   * @memberof UpdateWebhookSubscriptionRequestDataAttributes
   */
  status?: UpdateWebhookSubscriptionRequestDataAttributesStatusEnum;
  /**
   *
   * @type {Array<string>}
   * @memberof UpdateWebhookSubscriptionRequestDataAttributes
   */
  topics?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof UpdateWebhookSubscriptionRequestDataAttributes
   */
  url?: string;
}

export const UpdateWebhookSubscriptionRequestDataAttributesStatusEnum = {
  Active: 'active',
  Paused: 'paused',
} as const;

export type UpdateWebhookSubscriptionRequestDataAttributesStatusEnum =
  (typeof UpdateWebhookSubscriptionRequestDataAttributesStatusEnum)[keyof typeof UpdateWebhookSubscriptionRequestDataAttributesStatusEnum];

/**
 *
 * @export
 * @interface UpsertPropertyEntriesRequest
 */
export interface UpsertPropertyEntriesRequest {
  /**
   *
   * @type {UpsertPropertyEntriesRequestData}
   * @memberof UpsertPropertyEntriesRequest
   */
  data: UpsertPropertyEntriesRequestData;
}
/**
 *
 * @export
 * @interface UpsertPropertyEntriesRequestData
 */
export interface UpsertPropertyEntriesRequestData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpsertPropertyEntriesRequestData
   */
  type: string;
  /**
   *
   * @type {UpsertPropertyEntriesRequestDataAttributes}
   * @memberof UpsertPropertyEntriesRequestData
   */
  attributes: UpsertPropertyEntriesRequestDataAttributes;
  /**
   *
   * @type {UpsertPropertyEntriesRequestDataRelationships}
   * @memberof UpsertPropertyEntriesRequestData
   */
  relationships: UpsertPropertyEntriesRequestDataRelationships;
}
/**
 *
 * @export
 * @interface UpsertPropertyEntriesRequestDataAttributes
 */
export interface UpsertPropertyEntriesRequestDataAttributes {
  /**
   * Property entries for a provided resource or property set.
   * @type {{ [key: string]: PropertyStringType | PropertyDoubleType | PropertyLongType | PropertyDateType | object; }}
   * @memberof UpsertPropertyEntriesRequestDataAttributes
   */
  entries: {
    [key: string]:
      | PropertyStringType
      | PropertyDoubleType
      | PropertyLongType
      | PropertyDateType
      | object;
  };
}
/**
 *
 * @export
 * @interface UpsertPropertyEntriesRequestDataRelationships
 */
export interface UpsertPropertyEntriesRequestDataRelationships {
  /**
   * Relationship to the property set by `property-set`, `part-revision`, `part-instance` or `scene-item`.
   * @type {PropertySetRelationship | PartRevisionRelationship | SceneItemRelationship | PartInstanceRelationship}
   * @memberof UpsertPropertyEntriesRequestDataRelationships
   */
  propertySet:
    | PropertySetRelationship
    | PartRevisionRelationship
    | SceneItemRelationship
    | PartInstanceRelationship;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {UserData}
   * @memberof User
   */
  data: UserData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof User
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface UserData
 */
export interface UserData {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof UserData
   */
  id: string;
  /**
   *
   * @type {UserDataAttributes}
   * @memberof UserData
   */
  attributes: UserDataAttributes;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof UserData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface UserDataAttributes
 */
export interface UserDataAttributes {
  /**
   *
   * @type {string}
   * @memberof UserDataAttributes
   */
  fullName: string;
  /**
   *
   * @type {string}
   * @memberof UserDataAttributes
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UserDataAttributes
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof UserDataAttributes
   */
  idpId?: string;
}
/**
 *
 * @export
 * @interface UserGroup
 */
export interface UserGroup {
  /**
   *
   * @type {UserGroupData}
   * @memberof UserGroup
   */
  data: UserGroupData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof UserGroup
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface UserGroupData
 */
export interface UserGroupData {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof UserGroupData
   */
  id: string;
  /**
   *
   * @type {UserGroupDataAttributes}
   * @memberof UserGroupData
   */
  attributes: UserGroupDataAttributes;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof UserGroupData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface UserGroupDataAttributes
 */
export interface UserGroupDataAttributes {
  /**
   *
   * @type {string}
   * @memberof UserGroupDataAttributes
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof UserGroupDataAttributes
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof UserGroupDataAttributes
   */
  suppliedId?: string;
}
/**
 *
 * @export
 * @interface UserGroupId
 */
export interface UserGroupId {
  /**
   * Resource object type.
   * @type {string}
   * @memberof UserGroupId
   */
  type: UserGroupIdTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof UserGroupId
   */
  id: string;
}

export const UserGroupIdTypeEnum = {
  UserGroup: 'user-group',
} as const;

export type UserGroupIdTypeEnum =
  (typeof UserGroupIdTypeEnum)[keyof typeof UserGroupIdTypeEnum];

/**
 *
 * @export
 * @interface UserGroupIdsList
 */
export interface UserGroupIdsList {
  /**
   *
   * @type {Array<UserGroupId>}
   * @memberof UserGroupIdsList
   */
  data: Array<UserGroupId>;
}
/**
 *
 * @export
 * @interface UserGroupList
 */
export interface UserGroupList {
  /**
   *
   * @type {Array<UserGroupData>}
   * @memberof UserGroupList
   */
  data: Array<UserGroupData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof UserGroupList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface UserId
 */
export interface UserId {
  /**
   * Resource object type.
   * @type {string}
   * @memberof UserId
   */
  type: UserIdTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof UserId
   */
  id: string;
}

export const UserIdTypeEnum = {
  User: 'user',
} as const;

export type UserIdTypeEnum =
  (typeof UserIdTypeEnum)[keyof typeof UserIdTypeEnum];

/**
 *
 * @export
 * @interface UserIdList
 */
export interface UserIdList {
  /**
   *
   * @type {Array<UserId>}
   * @memberof UserIdList
   */
  data: Array<UserId>;
}
/**
 *
 * @export
 * @interface UserList
 */
export interface UserList {
  /**
   *
   * @type {Array<UserData>}
   * @memberof UserList
   */
  data: Array<UserData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof UserList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface UserRelationship
 */
export interface UserRelationship {
  /**
   *
   * @type {UserRelationshipData}
   * @memberof UserRelationship
   */
  data: UserRelationshipData;
}
/**
 *
 * @export
 * @interface UserRelationshipData
 */
export interface UserRelationshipData {
  /**
   *
   * @type {string}
   * @memberof UserRelationshipData
   */
  type: UserRelationshipDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof UserRelationshipData
   */
  id: string;
}

export const UserRelationshipDataTypeEnum = {
  User: 'user',
} as const;

export type UserRelationshipDataTypeEnum =
  (typeof UserRelationshipDataTypeEnum)[keyof typeof UserRelationshipDataTypeEnum];

/**
 * 3D vector.
 * @export
 * @interface Vector3
 */
export interface Vector3 {
  /**
   * x-axis coordinate.
   * @type {number}
   * @memberof Vector3
   */
  x: number;
  /**
   * y-axis coordinate.
   * @type {number}
   * @memberof Vector3
   */
  y: number;
  /**
   * z-axis coordinate.
   * @type {number}
   * @memberof Vector3
   */
  z: number;
}
/**
 * 4D vector.
 * @export
 * @interface Vector4
 */
export interface Vector4 {
  /**
   * x-axis coordinate.
   * @type {number}
   * @memberof Vector4
   */
  x: number;
  /**
   * y-axis coordinate.
   * @type {number}
   * @memberof Vector4
   */
  y: number;
  /**
   * z-axis coordinate.
   * @type {number}
   * @memberof Vector4
   */
  z: number;
  /**
   * w value.
   * @type {number}
   * @memberof Vector4
   */
  w: number;
}
/**
 *
 * @export
 * @interface ViewDefaultRenOp
 */
export interface ViewDefaultRenOp {
  /**
   * Resource object type.
   * @type {string}
   * @memberof ViewDefaultRenOp
   */
  type: ViewDefaultRenOpTypeEnum;
}

export const ViewDefaultRenOpTypeEnum = {
  ViewDefaultRendition: 'view-default-rendition',
} as const;

export type ViewDefaultRenOpTypeEnum =
  (typeof ViewDefaultRenOpTypeEnum)[keyof typeof ViewDefaultRenOpTypeEnum];

/**
 *
 * @export
 * @interface ViewRenByIdOp
 */
export interface ViewRenByIdOp {
  /**
   * Resource object type.
   * @type {string}
   * @memberof ViewRenByIdOp
   */
  type: ViewRenByIdOpTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof ViewRenByIdOp
   */
  renditionId: string;
}

export const ViewRenByIdOpTypeEnum = {
  ViewRenditionById: 'view-rendition-by-id',
} as const;

export type ViewRenByIdOpTypeEnum =
  (typeof ViewRenByIdOpTypeEnum)[keyof typeof ViewRenByIdOpTypeEnum];

/**
 *
 * @export
 * @interface ViewRenBySuppliedIdOp
 */
export interface ViewRenBySuppliedIdOp {
  /**
   * Resource object type.
   * @type {string}
   * @memberof ViewRenBySuppliedIdOp
   */
  type: ViewRenBySuppliedIdOpTypeEnum;
  /**
   *
   * @type {string}
   * @memberof ViewRenBySuppliedIdOp
   */
  renditionSuppliedId: string;
}

export const ViewRenBySuppliedIdOpTypeEnum = {
  ViewRenditionBySuppliedId: 'view-rendition-by-supplied-id',
} as const;

export type ViewRenBySuppliedIdOpTypeEnum =
  (typeof ViewRenBySuppliedIdOpTypeEnum)[keyof typeof ViewRenBySuppliedIdOpTypeEnum];

/**
 *
 * @export
 * @interface ViewRepByIdOp
 */
export interface ViewRepByIdOp {
  /**
   * Resource object type.
   * @type {string}
   * @memberof ViewRepByIdOp
   */
  type: ViewRepByIdOpTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof ViewRepByIdOp
   */
  id: string;
}

export const ViewRepByIdOpTypeEnum = {
  ViewRepresentationById: 'view-representation-by-id',
} as const;

export type ViewRepByIdOpTypeEnum =
  (typeof ViewRepByIdOpTypeEnum)[keyof typeof ViewRepByIdOpTypeEnum];

/**
 *
 * @export
 * @interface ViewRepByPredefinedIdOp
 */
export interface ViewRepByPredefinedIdOp {
  /**
   * Resource object type.
   * @type {string}
   * @memberof ViewRepByPredefinedIdOp
   */
  type: ViewRepByPredefinedIdOpTypeEnum;
  /**
   * A predefined representation identifier, such as `entire-part`.
   * @type {string}
   * @memberof ViewRepByPredefinedIdOp
   */
  id: ViewRepByPredefinedIdOpIdEnum;
}

export const ViewRepByPredefinedIdOpTypeEnum = {
  ViewRepresentationByPredefinedId: 'view-representation-by-predefined-id',
} as const;

export type ViewRepByPredefinedIdOpTypeEnum =
  (typeof ViewRepByPredefinedIdOpTypeEnum)[keyof typeof ViewRepByPredefinedIdOpTypeEnum];
export const ViewRepByPredefinedIdOpIdEnum = {
  Empty: 'empty',
  EntirePart: 'entire-part',
} as const;

export type ViewRepByPredefinedIdOpIdEnum =
  (typeof ViewRepByPredefinedIdOpIdEnum)[keyof typeof ViewRepByPredefinedIdOpIdEnum];

/**
 *
 * @export
 * @interface WebhookEvent
 */
export interface WebhookEvent {
  /**
   *
   * @type {WebhookEventData}
   * @memberof WebhookEvent
   */
  data: WebhookEventData;
  /**
   *
   * @type {Array<WebhookEventSceneIncludedData | WebhookEventPartRevisionIncludedData>}
   * @memberof WebhookEvent
   */
  included: Array<
    WebhookEventSceneIncludedData | WebhookEventPartRevisionIncludedData
  >;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof WebhookEvent
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface WebhookEventData
 */
export interface WebhookEventData {
  /**
   *
   * @type {string}
   * @memberof WebhookEventData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof WebhookEventData
   */
  id: string;
  /**
   *
   * @type {WebhookEventDataAttributes}
   * @memberof WebhookEventData
   */
  attributes: WebhookEventDataAttributes;
  /**
   *
   * @type {WebhookEventDataRelationships}
   * @memberof WebhookEventData
   */
  relationships?: WebhookEventDataRelationships;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof WebhookEventData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface WebhookEventDataAttributes
 */
export interface WebhookEventDataAttributes {
  /**
   *
   * @type {string}
   * @memberof WebhookEventDataAttributes
   */
  created: string;
  /**
   *
   * @type {string}
   * @memberof WebhookEventDataAttributes
   */
  topic: string;
  /**
   *
   * @type {Array<string>}
   * @memberof WebhookEventDataAttributes
   */
  changed?: Array<string>;
}
/**
 *
 * @export
 * @interface WebhookEventDataRelationships
 */
export interface WebhookEventDataRelationships {
  /**
   *
   * @type {WebhookEventDataRelationshipsOwner}
   * @memberof WebhookEventDataRelationships
   */
  owner: WebhookEventDataRelationshipsOwner;
  /**
   *
   * @type {WebhookEventDataRelationshipsResource}
   * @memberof WebhookEventDataRelationships
   */
  resource: WebhookEventDataRelationshipsResource;
}
/**
 * Relationship to an `owner`.
 * @export
 * @interface WebhookEventDataRelationshipsOwner
 */
export interface WebhookEventDataRelationshipsOwner {
  /**
   *
   * @type {WebhookEventDataRelationshipsOwnerData}
   * @memberof WebhookEventDataRelationshipsOwner
   */
  data: WebhookEventDataRelationshipsOwnerData;
  /**
   *
   * @type {RelationshipLinks}
   * @memberof WebhookEventDataRelationshipsOwner
   */
  links?: RelationshipLinks;
}
/**
 *
 * @export
 * @interface WebhookEventDataRelationshipsOwnerData
 */
export interface WebhookEventDataRelationshipsOwnerData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof WebhookEventDataRelationshipsOwnerData
   */
  type: WebhookEventDataRelationshipsOwnerDataTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof WebhookEventDataRelationshipsOwnerData
   */
  id: string;
}

export const WebhookEventDataRelationshipsOwnerDataTypeEnum = {
  Account: 'account',
} as const;

export type WebhookEventDataRelationshipsOwnerDataTypeEnum =
  (typeof WebhookEventDataRelationshipsOwnerDataTypeEnum)[keyof typeof WebhookEventDataRelationshipsOwnerDataTypeEnum];

/**
 * Relationship to a `resource`.
 * @export
 * @interface WebhookEventDataRelationshipsResource
 */
export interface WebhookEventDataRelationshipsResource {
  /**
   *
   * @type {WebhookEventDataRelationshipsResourceData}
   * @memberof WebhookEventDataRelationshipsResource
   */
  data: WebhookEventDataRelationshipsResourceData;
  /**
   *
   * @type {RelationshipLinks}
   * @memberof WebhookEventDataRelationshipsResource
   */
  links?: RelationshipLinks;
}
/**
 *
 * @export
 * @interface WebhookEventDataRelationshipsResourceData
 */
export interface WebhookEventDataRelationshipsResourceData {
  /**
   * Resource object type.
   * @type {string}
   * @memberof WebhookEventDataRelationshipsResourceData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof WebhookEventDataRelationshipsResourceData
   */
  id: string;
}
/**
 *
 * @export
 * @interface WebhookEventPartRevisionIncludedAttributes
 */
export interface WebhookEventPartRevisionIncludedAttributes {
  /**
   *
   * @type {string}
   * @memberof WebhookEventPartRevisionIncludedAttributes
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof WebhookEventPartRevisionIncludedAttributes
   */
  suppliedId?: string;
  /**
   *
   * @type {string}
   * @memberof WebhookEventPartRevisionIncludedAttributes
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof WebhookEventPartRevisionIncludedAttributes
   */
  partName?: string;
}
/**
 *
 * @export
 * @interface WebhookEventPartRevisionIncludedData
 */
export interface WebhookEventPartRevisionIncludedData {
  /**
   *
   * @type {string}
   * @memberof WebhookEventPartRevisionIncludedData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof WebhookEventPartRevisionIncludedData
   */
  id: string;
  /**
   *
   * @type {WebhookEventPartRevisionIncludedAttributes}
   * @memberof WebhookEventPartRevisionIncludedData
   */
  attributes: WebhookEventPartRevisionIncludedAttributes;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof WebhookEventPartRevisionIncludedData
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface WebhookEventSceneIncludedAttributes
 */
export interface WebhookEventSceneIncludedAttributes {
  /**
   * User supplied key-value pairs for a scene. You can supply up to 50 entries, with key names limited to 64 characters and values limited to 256 characters.
   * @type {{ [key: string]: string; }}
   * @memberof WebhookEventSceneIncludedAttributes
   */
  metadata?: { [key: string]: string };
}
/**
 *
 * @export
 * @interface WebhookEventSceneIncludedData
 */
export interface WebhookEventSceneIncludedData {
  /**
   *
   * @type {string}
   * @memberof WebhookEventSceneIncludedData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof WebhookEventSceneIncludedData
   */
  id: string;
  /**
   *
   * @type {WebhookEventSceneIncludedAttributes}
   * @memberof WebhookEventSceneIncludedData
   */
  attributes: WebhookEventSceneIncludedAttributes;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof WebhookEventSceneIncludedData
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface WebhookSubscription
 */
export interface WebhookSubscription {
  /**
   *
   * @type {WebhookSubscriptionData}
   * @memberof WebhookSubscription
   */
  data: WebhookSubscriptionData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof WebhookSubscription
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface WebhookSubscriptionData
 */
export interface WebhookSubscriptionData {
  /**
   *
   * @type {string}
   * @memberof WebhookSubscriptionData
   */
  type: string;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof WebhookSubscriptionData
   */
  id: string;
  /**
   *
   * @type {WebhookSubscriptionDataAttributes}
   * @memberof WebhookSubscriptionData
   */
  attributes: WebhookSubscriptionDataAttributes;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof WebhookSubscriptionData
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface WebhookSubscriptionDataAttributes
 */
export interface WebhookSubscriptionDataAttributes {
  /**
   *
   * @type {string}
   * @memberof WebhookSubscriptionDataAttributes
   */
  url: string;
  /**
   *
   * @type {string}
   * @memberof WebhookSubscriptionDataAttributes
   */
  secret?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof WebhookSubscriptionDataAttributes
   */
  topics: Array<string>;
  /**
   *
   * @type {string}
   * @memberof WebhookSubscriptionDataAttributes
   */
  status: WebhookSubscriptionDataAttributesStatusEnum;
  /**
   *
   * @type {string}
   * @memberof WebhookSubscriptionDataAttributes
   */
  created: string;
}

export const WebhookSubscriptionDataAttributesStatusEnum = {
  Active: 'active',
  Paused: 'paused',
} as const;

export type WebhookSubscriptionDataAttributesStatusEnum =
  (typeof WebhookSubscriptionDataAttributesStatusEnum)[keyof typeof WebhookSubscriptionDataAttributesStatusEnum];

/**
 *
 * @export
 * @interface WebhookSubscriptionList
 */
export interface WebhookSubscriptionList {
  /**
   *
   * @type {Array<WebhookSubscriptionData>}
   * @memberof WebhookSubscriptionList
   */
  data: Array<WebhookSubscriptionData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof WebhookSubscriptionList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface WithFileContent
 */
export interface WithFileContent {
  /**
   *
   * @type {string}
   * @memberof WithFileContent
   */
  type: WithFileContentTypeEnum;
  /**
   * The name of the file to create
   * @type {string}
   * @memberof WithFileContent
   */
  name: string;
}

export const WithFileContentTypeEnum = {
  FileContent: 'file-content',
} as const;

export type WithFileContentTypeEnum =
  (typeof WithFileContentTypeEnum)[keyof typeof WithFileContentTypeEnum];

/**
 *
 * @export
 * @interface WithReply
 */
export interface WithReply {
  /**
   *
   * @type {string}
   * @memberof WithReply
   */
  type: WithReplyTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof WithReply
   */
  id: string;
}

export const WithReplyTypeEnum = {
  Reply: 'reply',
} as const;

export type WithReplyTypeEnum =
  (typeof WithReplyTypeEnum)[keyof typeof WithReplyTypeEnum];

/**
 * A sceneViewId to be associated as a reference.
 * @export
 * @interface WithSceneViewId
 */
export interface WithSceneViewId {
  /**
   *
   * @type {string}
   * @memberof WithSceneViewId
   */
  type: WithSceneViewIdTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof WithSceneViewId
   */
  sceneViewId: string;
}

export const WithSceneViewIdTypeEnum = {
  SceneViewId: 'scene-view-id',
} as const;

export type WithSceneViewIdTypeEnum =
  (typeof WithSceneViewIdTypeEnum)[keyof typeof WithSceneViewIdTypeEnum];

/**
 * A sceneViewStateId to be associated as a reference.
 * @export
 * @interface WithSceneViewStateId
 */
export interface WithSceneViewStateId {
  /**
   *
   * @type {string}
   * @memberof WithSceneViewStateId
   */
  type: WithSceneViewStateIdTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof WithSceneViewStateId
   */
  sceneViewStateId: string;
}

export const WithSceneViewStateIdTypeEnum = {
  SceneViewStateId: 'scene-view-state-id',
} as const;

export type WithSceneViewStateIdTypeEnum =
  (typeof WithSceneViewStateIdTypeEnum)[keyof typeof WithSceneViewStateIdTypeEnum];

/**
 *
 * @export
 * @interface WithThread
 */
export interface WithThread {
  /**
   *
   * @type {string}
   * @memberof WithThread
   */
  type: WithThreadTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof WithThread
   */
  id: string;
}

export const WithThreadTypeEnum = {
  Thread: 'thread',
} as const;

export type WithThreadTypeEnum =
  (typeof WithThreadTypeEnum)[keyof typeof WithThreadTypeEnum];

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create an `account`.
     * @param {CreateAccountRequest} createAccountRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccount: async (
      createAccountRequest: CreateAccountRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createAccountRequest' is not null or undefined
      assertParamExists(
        'createAccount',
        'createAccountRequest',
        createAccountRequest
      );
      const localVarPath = `/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2Internal required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2Internal',
        ['accounts.*', 'accounts.write'],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createAccountRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create an `application` for an `account`.
     * @param {string} id The &#x60;account&#x60; ID.
     * @param {AdminCreateApplicationRequest} adminCreateApplicationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApplicationForAccount: async (
      id: string,
      adminCreateApplicationRequest: AdminCreateApplicationRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createApplicationForAccount', 'id', id);
      // verify required parameter 'adminCreateApplicationRequest' is not null or undefined
      assertParamExists(
        'createApplicationForAccount',
        'adminCreateApplicationRequest',
        adminCreateApplicationRequest
      );
      const localVarPath = `/accounts/{id}/applications`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2Internal required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2Internal',
        ['accounts.*', 'accounts.write'],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        adminCreateApplicationRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete an `account`.
     * @param {string} id The &#x60;account&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccount: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteAccount', 'id', id);
      const localVarPath = `/accounts/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2Internal required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2Internal',
        ['accounts.*', 'accounts.write'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get an `account`.
     * @param {string} id The &#x60;account&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getAccount', 'id', id);
      const localVarPath = `/accounts/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2Internal required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2Internal',
        ['accounts.*', 'accounts.read'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update an `account`.
     * @param {string} id The &#x60;account&#x60; ID.
     * @param {UpdateAccountRequest} updateAccountRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAccount: async (
      id: string,
      updateAccountRequest: UpdateAccountRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateAccount', 'id', id);
      // verify required parameter 'updateAccountRequest' is not null or undefined
      assertParamExists(
        'updateAccount',
        'updateAccountRequest',
        updateAccountRequest
      );
      const localVarPath = `/accounts/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2Internal required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2Internal',
        ['accounts.*', 'accounts.write'],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateAccountRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create an `account`.
     * @param {CreateAccountRequest} createAccountRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAccount(
      createAccountRequest: CreateAccountRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(
        createAccountRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Create an `application` for an `account`.
     * @param {string} id The &#x60;account&#x60; ID.
     * @param {AdminCreateApplicationRequest} adminCreateApplicationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createApplicationForAccount(
      id: string,
      adminCreateApplicationRequest: AdminCreateApplicationRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CreatedApplication>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createApplicationForAccount(
          id,
          adminCreateApplicationRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete an `account`.
     * @param {string} id The &#x60;account&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAccount(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get an `account`.
     * @param {string} id The &#x60;account&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccount(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update an `account`.
     * @param {string} id The &#x60;account&#x60; ID.
     * @param {UpdateAccountRequest} updateAccountRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateAccount(
      id: string,
      updateAccountRequest: UpdateAccountRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(
        id,
        updateAccountRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AccountsApiFp(configuration);
  return {
    /**
     * Create an `account`.
     * @param {CreateAccountRequest} createAccountRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccount(
      createAccountRequest: CreateAccountRequest,
      options?: any
    ): AxiosPromise<Account> {
      return localVarFp
        .createAccount(createAccountRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create an `application` for an `account`.
     * @param {string} id The &#x60;account&#x60; ID.
     * @param {AdminCreateApplicationRequest} adminCreateApplicationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApplicationForAccount(
      id: string,
      adminCreateApplicationRequest: AdminCreateApplicationRequest,
      options?: any
    ): AxiosPromise<CreatedApplication> {
      return localVarFp
        .createApplicationForAccount(id, adminCreateApplicationRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete an `account`.
     * @param {string} id The &#x60;account&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccount(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteAccount(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get an `account`.
     * @param {string} id The &#x60;account&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(id: string, options?: any): AxiosPromise<Account> {
      return localVarFp
        .getAccount(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update an `account`.
     * @param {string} id The &#x60;account&#x60; ID.
     * @param {UpdateAccountRequest} updateAccountRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAccount(
      id: string,
      updateAccountRequest: UpdateAccountRequest,
      options?: any
    ): AxiosPromise<Account> {
      return localVarFp
        .updateAccount(id, updateAccountRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiCreateAccountRequest
 */
export interface AccountsApiCreateAccountRequest {
  /**
   *
   * @type {CreateAccountRequest}
   * @memberof AccountsApiCreateAccount
   */
  readonly createAccountRequest: CreateAccountRequest;
}

/**
 * Request parameters for createApplicationForAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiCreateApplicationForAccountRequest
 */
export interface AccountsApiCreateApplicationForAccountRequest {
  /**
   * The &#x60;account&#x60; ID.
   * @type {string}
   * @memberof AccountsApiCreateApplicationForAccount
   */
  readonly id: string;

  /**
   *
   * @type {AdminCreateApplicationRequest}
   * @memberof AccountsApiCreateApplicationForAccount
   */
  readonly adminCreateApplicationRequest: AdminCreateApplicationRequest;
}

/**
 * Request parameters for deleteAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiDeleteAccountRequest
 */
export interface AccountsApiDeleteAccountRequest {
  /**
   * The &#x60;account&#x60; ID.
   * @type {string}
   * @memberof AccountsApiDeleteAccount
   */
  readonly id: string;
}

/**
 * Request parameters for getAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountRequest
 */
export interface AccountsApiGetAccountRequest {
  /**
   * The &#x60;account&#x60; ID.
   * @type {string}
   * @memberof AccountsApiGetAccount
   */
  readonly id: string;
}

/**
 * Request parameters for updateAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiUpdateAccountRequest
 */
export interface AccountsApiUpdateAccountRequest {
  /**
   * The &#x60;account&#x60; ID.
   * @type {string}
   * @memberof AccountsApiUpdateAccount
   */
  readonly id: string;

  /**
   *
   * @type {UpdateAccountRequest}
   * @memberof AccountsApiUpdateAccount
   */
  readonly updateAccountRequest: UpdateAccountRequest;
}

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
  /**
   * Create an `account`.
   * @param {AccountsApiCreateAccountRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public createAccount(
    requestParameters: AccountsApiCreateAccountRequest,
    options?: AxiosRequestConfig
  ) {
    return AccountsApiFp(this.configuration)
      .createAccount(requestParameters.createAccountRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create an `application` for an `account`.
   * @param {AccountsApiCreateApplicationForAccountRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public createApplicationForAccount(
    requestParameters: AccountsApiCreateApplicationForAccountRequest,
    options?: AxiosRequestConfig
  ) {
    return AccountsApiFp(this.configuration)
      .createApplicationForAccount(
        requestParameters.id,
        requestParameters.adminCreateApplicationRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete an `account`.
   * @param {AccountsApiDeleteAccountRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public deleteAccount(
    requestParameters: AccountsApiDeleteAccountRequest,
    options?: AxiosRequestConfig
  ) {
    return AccountsApiFp(this.configuration)
      .deleteAccount(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get an `account`.
   * @param {AccountsApiGetAccountRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getAccount(
    requestParameters: AccountsApiGetAccountRequest,
    options?: AxiosRequestConfig
  ) {
    return AccountsApiFp(this.configuration)
      .getAccount(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update an `account`.
   * @param {AccountsApiUpdateAccountRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public updateAccount(
    requestParameters: AccountsApiUpdateAccountRequest,
    options?: AxiosRequestConfig
  ) {
    return AccountsApiFp(this.configuration)
      .updateAccount(
        requestParameters.id,
        requestParameters.updateAccountRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
export const ApplicationsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create an OAuth2 `application`.
     * @param {CreateApplicationRequest} createApplicationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApplication: async (
      createApplicationRequest: CreateApplicationRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createApplicationRequest' is not null or undefined
      assertParamExists(
        'createApplication',
        'createApplicationRequest',
        createApplicationRequest
      );
      const localVarPath = `/applications`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createApplicationRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete an `application`.
     * @param {string} id The &#x60;application&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApplication: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteApplication', 'id', id);
      const localVarPath = `/applications/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get an `application`.
     * @param {string} id The &#x60;application&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplication: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getApplication', 'id', id);
      const localVarPath = `/applications/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get `applications`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterClientId] Comma-separated list of client IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplications: async (
      pageCursor?: string,
      pageSize?: number,
      filterClientId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/applications`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (filterClientId !== undefined) {
        localVarQueryParameter['filter[clientId]'] = filterClientId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update an `application`.
     * @param {string} id The &#x60;application&#x60; ID.
     * @param {UpdateApplicationRequest} updateApplicationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApplication: async (
      id: string,
      updateApplicationRequest: UpdateApplicationRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateApplication', 'id', id);
      // verify required parameter 'updateApplicationRequest' is not null or undefined
      assertParamExists(
        'updateApplication',
        'updateApplicationRequest',
        updateApplicationRequest
      );
      const localVarPath = `/applications/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateApplicationRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ApplicationsApi - functional programming interface
 * @export
 */
export const ApplicationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ApplicationsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create an OAuth2 `application`.
     * @param {CreateApplicationRequest} createApplicationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createApplication(
      createApplicationRequest: CreateApplicationRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CreatedApplication>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createApplication(
          createApplicationRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete an `application`.
     * @param {string} id The &#x60;application&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteApplication(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteApplication(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get an `application`.
     * @param {string} id The &#x60;application&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApplication(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get `applications`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterClientId] Comma-separated list of client IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApplications(
      pageCursor?: string,
      pageSize?: number,
      filterClientId?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ApplicationList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApplications(
        pageCursor,
        pageSize,
        filterClientId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update an `application`.
     * @param {string} id The &#x60;application&#x60; ID.
     * @param {UpdateApplicationRequest} updateApplicationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateApplication(
      id: string,
      updateApplicationRequest: UpdateApplicationRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateApplication(
          id,
          updateApplicationRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ApplicationsApi - factory interface
 * @export
 */
export const ApplicationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ApplicationsApiFp(configuration);
  return {
    /**
     * Create an OAuth2 `application`.
     * @param {CreateApplicationRequest} createApplicationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApplication(
      createApplicationRequest: CreateApplicationRequest,
      options?: any
    ): AxiosPromise<CreatedApplication> {
      return localVarFp
        .createApplication(createApplicationRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete an `application`.
     * @param {string} id The &#x60;application&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApplication(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteApplication(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get an `application`.
     * @param {string} id The &#x60;application&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplication(id: string, options?: any): AxiosPromise<Application> {
      return localVarFp
        .getApplication(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get `applications`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterClientId] Comma-separated list of client IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplications(
      pageCursor?: string,
      pageSize?: number,
      filterClientId?: string,
      options?: any
    ): AxiosPromise<ApplicationList> {
      return localVarFp
        .getApplications(pageCursor, pageSize, filterClientId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update an `application`.
     * @param {string} id The &#x60;application&#x60; ID.
     * @param {UpdateApplicationRequest} updateApplicationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApplication(
      id: string,
      updateApplicationRequest: UpdateApplicationRequest,
      options?: any
    ): AxiosPromise<Application> {
      return localVarFp
        .updateApplication(id, updateApplicationRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiCreateApplicationRequest
 */
export interface ApplicationsApiCreateApplicationRequest {
  /**
   *
   * @type {CreateApplicationRequest}
   * @memberof ApplicationsApiCreateApplication
   */
  readonly createApplicationRequest: CreateApplicationRequest;
}

/**
 * Request parameters for deleteApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiDeleteApplicationRequest
 */
export interface ApplicationsApiDeleteApplicationRequest {
  /**
   * The &#x60;application&#x60; ID.
   * @type {string}
   * @memberof ApplicationsApiDeleteApplication
   */
  readonly id: string;
}

/**
 * Request parameters for getApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiGetApplicationRequest
 */
export interface ApplicationsApiGetApplicationRequest {
  /**
   * The &#x60;application&#x60; ID.
   * @type {string}
   * @memberof ApplicationsApiGetApplication
   */
  readonly id: string;
}

/**
 * Request parameters for getApplications operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiGetApplicationsRequest
 */
export interface ApplicationsApiGetApplicationsRequest {
  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof ApplicationsApiGetApplications
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof ApplicationsApiGetApplications
   */
  readonly pageSize?: number;

  /**
   * Comma-separated list of client IDs to filter on.
   * @type {string}
   * @memberof ApplicationsApiGetApplications
   */
  readonly filterClientId?: string;
}

/**
 * Request parameters for updateApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiUpdateApplicationRequest
 */
export interface ApplicationsApiUpdateApplicationRequest {
  /**
   * The &#x60;application&#x60; ID.
   * @type {string}
   * @memberof ApplicationsApiUpdateApplication
   */
  readonly id: string;

  /**
   *
   * @type {UpdateApplicationRequest}
   * @memberof ApplicationsApiUpdateApplication
   */
  readonly updateApplicationRequest: UpdateApplicationRequest;
}

/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
export class ApplicationsApi extends BaseAPI {
  /**
   * Create an OAuth2 `application`.
   * @param {ApplicationsApiCreateApplicationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public createApplication(
    requestParameters: ApplicationsApiCreateApplicationRequest,
    options?: AxiosRequestConfig
  ) {
    return ApplicationsApiFp(this.configuration)
      .createApplication(requestParameters.createApplicationRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete an `application`.
   * @param {ApplicationsApiDeleteApplicationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public deleteApplication(
    requestParameters: ApplicationsApiDeleteApplicationRequest,
    options?: AxiosRequestConfig
  ) {
    return ApplicationsApiFp(this.configuration)
      .deleteApplication(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get an `application`.
   * @param {ApplicationsApiGetApplicationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public getApplication(
    requestParameters: ApplicationsApiGetApplicationRequest,
    options?: AxiosRequestConfig
  ) {
    return ApplicationsApiFp(this.configuration)
      .getApplication(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get `applications`.
   * @param {ApplicationsApiGetApplicationsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public getApplications(
    requestParameters: ApplicationsApiGetApplicationsRequest = {},
    options?: AxiosRequestConfig
  ) {
    return ApplicationsApiFp(this.configuration)
      .getApplications(
        requestParameters.pageCursor,
        requestParameters.pageSize,
        requestParameters.filterClientId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update an `application`.
   * @param {ApplicationsApiUpdateApplicationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public updateApplication(
    requestParameters: ApplicationsApiUpdateApplicationRequest,
    options?: AxiosRequestConfig
  ) {
    return ApplicationsApiFp(this.configuration)
      .updateApplication(
        requestParameters.id,
        requestParameters.updateApplicationRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AttachmentsApi - axios parameter creator
 * @export
 */
export const AttachmentsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create an `attachment` for a thread or a reply relationship. The content of the attachment can be a scene-view-state (created or provided), or a file. A file attachment requires the caller to upload the file after the attachment creation using a provided upload url. **Preview:** This is a preview API and is subject to change.
     * @param {CreateAttachmentRequest} createAttachmentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAttachment: async (
      createAttachmentRequest: CreateAttachmentRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createAttachmentRequest' is not null or undefined
      assertParamExists(
        'createAttachment',
        'createAttachmentRequest',
        createAttachmentRequest
      );
      const localVarPath = `/attachments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createAttachmentRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a download url for a file `attachment` by ID.
     * @param {string} id The &#x60;attachment&#x60; ID.
     * @param {CreateDownloadRequest} createDownloadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAttachmentDownloadUrl: async (
      id: string,
      createDownloadRequest: CreateDownloadRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createAttachmentDownloadUrl', 'id', id);
      // verify required parameter 'createDownloadRequest' is not null or undefined
      assertParamExists(
        'createAttachmentDownloadUrl',
        'createDownloadRequest',
        createDownloadRequest
      );
      const localVarPath = `/attachments/{id}/download-url`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createDownloadRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create an upload url for a file `attachment` by ID.
     * @param {string} id The &#x60;attachment&#x60; ID.
     * @param {CreateUploadRequest} createUploadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAttachmentUploadUrl: async (
      id: string,
      createUploadRequest: CreateUploadRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createAttachmentUploadUrl', 'id', id);
      // verify required parameter 'createUploadRequest' is not null or undefined
      assertParamExists(
        'createAttachmentUploadUrl',
        'createUploadRequest',
        createUploadRequest
      );
      const localVarPath = `/attachments/{id}/upload-url`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createUploadRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List attachments **Preview:** This is a preview API and is subject to change.
     * @param {string} filterRelationshipId A relationship id to filter attachments for
     * @param {'thread' | 'reply'} filterRelationshipType The type of relationship (reply or thread)
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAttachments: async (
      filterRelationshipId: string,
      filterRelationshipType: 'thread' | 'reply',
      pageCursor?: string,
      pageSize?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'filterRelationshipId' is not null or undefined
      assertParamExists(
        'listAttachments',
        'filterRelationshipId',
        filterRelationshipId
      );
      // verify required parameter 'filterRelationshipType' is not null or undefined
      assertParamExists(
        'listAttachments',
        'filterRelationshipType',
        filterRelationshipType
      );
      const localVarPath = `/attachments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (filterRelationshipId !== undefined) {
        localVarQueryParameter['filter[relationshipId]'] = filterRelationshipId;
      }

      if (filterRelationshipType !== undefined) {
        localVarQueryParameter['filter[relationshipType]'] =
          filterRelationshipType;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AttachmentsApi - functional programming interface
 * @export
 */
export const AttachmentsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    AttachmentsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create an `attachment` for a thread or a reply relationship. The content of the attachment can be a scene-view-state (created or provided), or a file. A file attachment requires the caller to upload the file after the attachment creation using a provided upload url. **Preview:** This is a preview API and is subject to change.
     * @param {CreateAttachmentRequest} createAttachmentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAttachment(
      createAttachmentRequest: CreateAttachmentRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createAttachment(
          createAttachmentRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Create a download url for a file `attachment` by ID.
     * @param {string} id The &#x60;attachment&#x60; ID.
     * @param {CreateDownloadRequest} createDownloadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAttachmentDownloadUrl(
      id: string,
      createDownloadRequest: CreateDownloadRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PresignedUrl>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createAttachmentDownloadUrl(
          id,
          createDownloadRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Create an upload url for a file `attachment` by ID.
     * @param {string} id The &#x60;attachment&#x60; ID.
     * @param {CreateUploadRequest} createUploadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAttachmentUploadUrl(
      id: string,
      createUploadRequest: CreateUploadRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PresignedUrl>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createAttachmentUploadUrl(
          id,
          createUploadRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * List attachments **Preview:** This is a preview API and is subject to change.
     * @param {string} filterRelationshipId A relationship id to filter attachments for
     * @param {'thread' | 'reply'} filterRelationshipType The type of relationship (reply or thread)
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAttachments(
      filterRelationshipId: string,
      filterRelationshipType: 'thread' | 'reply',
      pageCursor?: string,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAttachments(
        filterRelationshipId,
        filterRelationshipType,
        pageCursor,
        pageSize,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * AttachmentsApi - factory interface
 * @export
 */
export const AttachmentsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AttachmentsApiFp(configuration);
  return {
    /**
     * Create an `attachment` for a thread or a reply relationship. The content of the attachment can be a scene-view-state (created or provided), or a file. A file attachment requires the caller to upload the file after the attachment creation using a provided upload url. **Preview:** This is a preview API and is subject to change.
     * @param {CreateAttachmentRequest} createAttachmentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAttachment(
      createAttachmentRequest: CreateAttachmentRequest,
      options?: any
    ): AxiosPromise<Attachment> {
      return localVarFp
        .createAttachment(createAttachmentRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a download url for a file `attachment` by ID.
     * @param {string} id The &#x60;attachment&#x60; ID.
     * @param {CreateDownloadRequest} createDownloadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAttachmentDownloadUrl(
      id: string,
      createDownloadRequest: CreateDownloadRequest,
      options?: any
    ): AxiosPromise<PresignedUrl> {
      return localVarFp
        .createAttachmentDownloadUrl(id, createDownloadRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create an upload url for a file `attachment` by ID.
     * @param {string} id The &#x60;attachment&#x60; ID.
     * @param {CreateUploadRequest} createUploadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAttachmentUploadUrl(
      id: string,
      createUploadRequest: CreateUploadRequest,
      options?: any
    ): AxiosPromise<PresignedUrl> {
      return localVarFp
        .createAttachmentUploadUrl(id, createUploadRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List attachments **Preview:** This is a preview API and is subject to change.
     * @param {string} filterRelationshipId A relationship id to filter attachments for
     * @param {'thread' | 'reply'} filterRelationshipType The type of relationship (reply or thread)
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAttachments(
      filterRelationshipId: string,
      filterRelationshipType: 'thread' | 'reply',
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<AttachmentList> {
      return localVarFp
        .listAttachments(
          filterRelationshipId,
          filterRelationshipType,
          pageCursor,
          pageSize,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createAttachment operation in AttachmentsApi.
 * @export
 * @interface AttachmentsApiCreateAttachmentRequest
 */
export interface AttachmentsApiCreateAttachmentRequest {
  /**
   *
   * @type {CreateAttachmentRequest}
   * @memberof AttachmentsApiCreateAttachment
   */
  readonly createAttachmentRequest: CreateAttachmentRequest;
}

/**
 * Request parameters for createAttachmentDownloadUrl operation in AttachmentsApi.
 * @export
 * @interface AttachmentsApiCreateAttachmentDownloadUrlRequest
 */
export interface AttachmentsApiCreateAttachmentDownloadUrlRequest {
  /**
   * The &#x60;attachment&#x60; ID.
   * @type {string}
   * @memberof AttachmentsApiCreateAttachmentDownloadUrl
   */
  readonly id: string;

  /**
   *
   * @type {CreateDownloadRequest}
   * @memberof AttachmentsApiCreateAttachmentDownloadUrl
   */
  readonly createDownloadRequest: CreateDownloadRequest;
}

/**
 * Request parameters for createAttachmentUploadUrl operation in AttachmentsApi.
 * @export
 * @interface AttachmentsApiCreateAttachmentUploadUrlRequest
 */
export interface AttachmentsApiCreateAttachmentUploadUrlRequest {
  /**
   * The &#x60;attachment&#x60; ID.
   * @type {string}
   * @memberof AttachmentsApiCreateAttachmentUploadUrl
   */
  readonly id: string;

  /**
   *
   * @type {CreateUploadRequest}
   * @memberof AttachmentsApiCreateAttachmentUploadUrl
   */
  readonly createUploadRequest: CreateUploadRequest;
}

/**
 * Request parameters for listAttachments operation in AttachmentsApi.
 * @export
 * @interface AttachmentsApiListAttachmentsRequest
 */
export interface AttachmentsApiListAttachmentsRequest {
  /**
   * A relationship id to filter attachments for
   * @type {string}
   * @memberof AttachmentsApiListAttachments
   */
  readonly filterRelationshipId: string;

  /**
   * The type of relationship (reply or thread)
   * @type {'thread' | 'reply'}
   * @memberof AttachmentsApiListAttachments
   */
  readonly filterRelationshipType: 'thread' | 'reply';

  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof AttachmentsApiListAttachments
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof AttachmentsApiListAttachments
   */
  readonly pageSize?: number;
}

/**
 * AttachmentsApi - object-oriented interface
 * @export
 * @class AttachmentsApi
 * @extends {BaseAPI}
 */
export class AttachmentsApi extends BaseAPI {
  /**
   * Create an `attachment` for a thread or a reply relationship. The content of the attachment can be a scene-view-state (created or provided), or a file. A file attachment requires the caller to upload the file after the attachment creation using a provided upload url. **Preview:** This is a preview API and is subject to change.
   * @param {AttachmentsApiCreateAttachmentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AttachmentsApi
   */
  public createAttachment(
    requestParameters: AttachmentsApiCreateAttachmentRequest,
    options?: AxiosRequestConfig
  ) {
    return AttachmentsApiFp(this.configuration)
      .createAttachment(requestParameters.createAttachmentRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a download url for a file `attachment` by ID.
   * @param {AttachmentsApiCreateAttachmentDownloadUrlRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AttachmentsApi
   */
  public createAttachmentDownloadUrl(
    requestParameters: AttachmentsApiCreateAttachmentDownloadUrlRequest,
    options?: AxiosRequestConfig
  ) {
    return AttachmentsApiFp(this.configuration)
      .createAttachmentDownloadUrl(
        requestParameters.id,
        requestParameters.createDownloadRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create an upload url for a file `attachment` by ID.
   * @param {AttachmentsApiCreateAttachmentUploadUrlRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AttachmentsApi
   */
  public createAttachmentUploadUrl(
    requestParameters: AttachmentsApiCreateAttachmentUploadUrlRequest,
    options?: AxiosRequestConfig
  ) {
    return AttachmentsApiFp(this.configuration)
      .createAttachmentUploadUrl(
        requestParameters.id,
        requestParameters.createUploadRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List attachments **Preview:** This is a preview API and is subject to change.
   * @param {AttachmentsApiListAttachmentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AttachmentsApi
   */
  public listAttachments(
    requestParameters: AttachmentsApiListAttachmentsRequest,
    options?: AxiosRequestConfig
  ) {
    return AttachmentsApiFp(this.configuration)
      .listAttachments(
        requestParameters.filterRelationshipId,
        requestParameters.filterRelationshipType,
        requestParameters.pageCursor,
        requestParameters.pageSize,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * BatchesApi - axios parameter creator
 * @export
 */
export const BatchesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a `batch`. This API is asynchronous, returning the location of a `queued-batch`. Check the status via the getQueuedBatch API.
     * @param {CreateBatchRequest} createBatchRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBatch: async (
      createBatchRequest: CreateBatchRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createBatchRequest' is not null or undefined
      assertParamExists(
        'createBatch',
        'createBatchRequest',
        createBatchRequest
      );
      const localVarPath = `/batches`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createBatchRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `batch` by ID.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBatch: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getBatch', 'id', id);
      const localVarPath = `/batches/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `queued-batch`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `batch`.
     * @param {string} id The &#x60;queued-batch&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedBatch: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getQueuedBatch', 'id', id);
      const localVarPath = `/queued-batches/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BatchesApi - functional programming interface
 * @export
 */
export const BatchesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BatchesApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a `batch`. This API is asynchronous, returning the location of a `queued-batch`. Check the status via the getQueuedBatch API.
     * @param {CreateBatchRequest} createBatchRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createBatch(
      createBatchRequest: CreateBatchRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createBatch(
        createBatchRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `batch` by ID.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBatch(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Batch>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBatch(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `queued-batch`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `batch`.
     * @param {string} id The &#x60;queued-batch&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedBatch(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getQueuedBatch(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * BatchesApi - factory interface
 * @export
 */
export const BatchesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = BatchesApiFp(configuration);
  return {
    /**
     * Create a `batch`. This API is asynchronous, returning the location of a `queued-batch`. Check the status via the getQueuedBatch API.
     * @param {CreateBatchRequest} createBatchRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBatch(
      createBatchRequest: CreateBatchRequest,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return localVarFp
        .createBatch(createBatchRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `batch` by ID.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBatch(id: string, options?: any): AxiosPromise<Batch> {
      return localVarFp
        .getBatch(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `queued-batch`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `batch`.
     * @param {string} id The &#x60;queued-batch&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedBatch(id: string, options?: any): AxiosPromise<QueuedJob> {
      return localVarFp
        .getQueuedBatch(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createBatch operation in BatchesApi.
 * @export
 * @interface BatchesApiCreateBatchRequest
 */
export interface BatchesApiCreateBatchRequest {
  /**
   *
   * @type {CreateBatchRequest}
   * @memberof BatchesApiCreateBatch
   */
  readonly createBatchRequest: CreateBatchRequest;
}

/**
 * Request parameters for getBatch operation in BatchesApi.
 * @export
 * @interface BatchesApiGetBatchRequest
 */
export interface BatchesApiGetBatchRequest {
  /**
   * The &#x60;file&#x60; ID.
   * @type {string}
   * @memberof BatchesApiGetBatch
   */
  readonly id: string;
}

/**
 * Request parameters for getQueuedBatch operation in BatchesApi.
 * @export
 * @interface BatchesApiGetQueuedBatchRequest
 */
export interface BatchesApiGetQueuedBatchRequest {
  /**
   * The &#x60;queued-batch&#x60; ID.
   * @type {string}
   * @memberof BatchesApiGetQueuedBatch
   */
  readonly id: string;
}

/**
 * BatchesApi - object-oriented interface
 * @export
 * @class BatchesApi
 * @extends {BaseAPI}
 */
export class BatchesApi extends BaseAPI {
  /**
   * Create a `batch`. This API is asynchronous, returning the location of a `queued-batch`. Check the status via the getQueuedBatch API.
   * @param {BatchesApiCreateBatchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public createBatch(
    requestParameters: BatchesApiCreateBatchRequest,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .createBatch(requestParameters.createBatchRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `batch` by ID.
   * @param {BatchesApiGetBatchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public getBatch(
    requestParameters: BatchesApiGetBatchRequest,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .getBatch(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `queued-batch`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `batch`.
   * @param {BatchesApiGetQueuedBatchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BatchesApi
   */
  public getQueuedBatch(
    requestParameters: BatchesApiGetQueuedBatchRequest,
    options?: AxiosRequestConfig
  ) {
    return BatchesApiFp(this.configuration)
      .getQueuedBatch(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CollaborationContextsApi - axios parameter creator
 * @export
 */
export const CollaborationContextsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a `collaboration-context`.
     * @param {string} id The &#x60;collaboration-context&#x60; ID.
     * @param {UserGroupIdsList} userGroupIdsList
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCollaborationContextUserGroups: async (
      id: string,
      userGroupIdsList: UserGroupIdsList,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('addCollaborationContextUserGroups', 'id', id);
      // verify required parameter 'userGroupIdsList' is not null or undefined
      assertParamExists(
        'addCollaborationContextUserGroups',
        'userGroupIdsList',
        userGroupIdsList
      );
      const localVarPath = `/collaboration-contexts/{id}/user-groups`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userGroupIdsList,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a `collaboration-context`.
     * @param {CreateCollaborationContextRequest} createCollaborationContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollaborationContext: async (
      createCollaborationContextRequest: CreateCollaborationContextRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createCollaborationContextRequest' is not null or undefined
      assertParamExists(
        'createCollaborationContext',
        'createCollaborationContextRequest',
        createCollaborationContextRequest
      );
      const localVarPath = `/collaboration-contexts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createCollaborationContextRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Remove a collaboration context along with all of its data
     * @param {string} id The &#x60;collaboration-context&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCollaborationContext: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteCollaborationContext', 'id', id);
      const localVarPath = `/collaboration-contexts/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `collaboration-context` by ID.
     * @param {string} id The &#x60;collaboration-context&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollaborationContext: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getCollaborationContext', 'id', id);
      const localVarPath = `/collaboration-contexts/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List `collaboration-context`s
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollaborationContexts: async (
      pageCursor?: string,
      pageSize?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/collaboration-contexts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CollaborationContextsApi - functional programming interface
 * @export
 */
export const CollaborationContextsApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    CollaborationContextsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a `collaboration-context`.
     * @param {string} id The &#x60;collaboration-context&#x60; ID.
     * @param {UserGroupIdsList} userGroupIdsList
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addCollaborationContextUserGroups(
      id: string,
      userGroupIdsList: UserGroupIdsList,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addCollaborationContextUserGroups(
          id,
          userGroupIdsList,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Create a `collaboration-context`.
     * @param {CreateCollaborationContextRequest} createCollaborationContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createCollaborationContext(
      createCollaborationContextRequest: CreateCollaborationContextRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CollaborationContext>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createCollaborationContext(
          createCollaborationContextRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Remove a collaboration context along with all of its data
     * @param {string} id The &#x60;collaboration-context&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCollaborationContext(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteCollaborationContext(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `collaboration-context` by ID.
     * @param {string} id The &#x60;collaboration-context&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCollaborationContext(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CollaborationContext>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCollaborationContext(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * List `collaboration-context`s
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listCollaborationContexts(
      pageCursor?: string,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CollaborationContextList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listCollaborationContexts(
          pageCursor,
          pageSize,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * CollaborationContextsApi - factory interface
 * @export
 */
export const CollaborationContextsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CollaborationContextsApiFp(configuration);
  return {
    /**
     * Create a `collaboration-context`.
     * @param {string} id The &#x60;collaboration-context&#x60; ID.
     * @param {UserGroupIdsList} userGroupIdsList
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCollaborationContextUserGroups(
      id: string,
      userGroupIdsList: UserGroupIdsList,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .addCollaborationContextUserGroups(id, userGroupIdsList, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a `collaboration-context`.
     * @param {CreateCollaborationContextRequest} createCollaborationContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollaborationContext(
      createCollaborationContextRequest: CreateCollaborationContextRequest,
      options?: any
    ): AxiosPromise<CollaborationContext> {
      return localVarFp
        .createCollaborationContext(createCollaborationContextRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Remove a collaboration context along with all of its data
     * @param {string} id The &#x60;collaboration-context&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCollaborationContext(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteCollaborationContext(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `collaboration-context` by ID.
     * @param {string} id The &#x60;collaboration-context&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollaborationContext(
      id: string,
      options?: any
    ): AxiosPromise<CollaborationContext> {
      return localVarFp
        .getCollaborationContext(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List `collaboration-context`s
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollaborationContexts(
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<CollaborationContextList> {
      return localVarFp
        .listCollaborationContexts(pageCursor, pageSize, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for addCollaborationContextUserGroups operation in CollaborationContextsApi.
 * @export
 * @interface CollaborationContextsApiAddCollaborationContextUserGroupsRequest
 */
export interface CollaborationContextsApiAddCollaborationContextUserGroupsRequest {
  /**
   * The &#x60;collaboration-context&#x60; ID.
   * @type {string}
   * @memberof CollaborationContextsApiAddCollaborationContextUserGroups
   */
  readonly id: string;

  /**
   *
   * @type {UserGroupIdsList}
   * @memberof CollaborationContextsApiAddCollaborationContextUserGroups
   */
  readonly userGroupIdsList: UserGroupIdsList;
}

/**
 * Request parameters for createCollaborationContext operation in CollaborationContextsApi.
 * @export
 * @interface CollaborationContextsApiCreateCollaborationContextRequest
 */
export interface CollaborationContextsApiCreateCollaborationContextRequest {
  /**
   *
   * @type {CreateCollaborationContextRequest}
   * @memberof CollaborationContextsApiCreateCollaborationContext
   */
  readonly createCollaborationContextRequest: CreateCollaborationContextRequest;
}

/**
 * Request parameters for deleteCollaborationContext operation in CollaborationContextsApi.
 * @export
 * @interface CollaborationContextsApiDeleteCollaborationContextRequest
 */
export interface CollaborationContextsApiDeleteCollaborationContextRequest {
  /**
   * The &#x60;collaboration-context&#x60; ID.
   * @type {string}
   * @memberof CollaborationContextsApiDeleteCollaborationContext
   */
  readonly id: string;
}

/**
 * Request parameters for getCollaborationContext operation in CollaborationContextsApi.
 * @export
 * @interface CollaborationContextsApiGetCollaborationContextRequest
 */
export interface CollaborationContextsApiGetCollaborationContextRequest {
  /**
   * The &#x60;collaboration-context&#x60; ID.
   * @type {string}
   * @memberof CollaborationContextsApiGetCollaborationContext
   */
  readonly id: string;
}

/**
 * Request parameters for listCollaborationContexts operation in CollaborationContextsApi.
 * @export
 * @interface CollaborationContextsApiListCollaborationContextsRequest
 */
export interface CollaborationContextsApiListCollaborationContextsRequest {
  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof CollaborationContextsApiListCollaborationContexts
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof CollaborationContextsApiListCollaborationContexts
   */
  readonly pageSize?: number;
}

/**
 * CollaborationContextsApi - object-oriented interface
 * @export
 * @class CollaborationContextsApi
 * @extends {BaseAPI}
 */
export class CollaborationContextsApi extends BaseAPI {
  /**
   * Create a `collaboration-context`.
   * @param {CollaborationContextsApiAddCollaborationContextUserGroupsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollaborationContextsApi
   */
  public addCollaborationContextUserGroups(
    requestParameters: CollaborationContextsApiAddCollaborationContextUserGroupsRequest,
    options?: AxiosRequestConfig
  ) {
    return CollaborationContextsApiFp(this.configuration)
      .addCollaborationContextUserGroups(
        requestParameters.id,
        requestParameters.userGroupIdsList,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a `collaboration-context`.
   * @param {CollaborationContextsApiCreateCollaborationContextRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollaborationContextsApi
   */
  public createCollaborationContext(
    requestParameters: CollaborationContextsApiCreateCollaborationContextRequest,
    options?: AxiosRequestConfig
  ) {
    return CollaborationContextsApiFp(this.configuration)
      .createCollaborationContext(
        requestParameters.createCollaborationContextRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Remove a collaboration context along with all of its data
   * @param {CollaborationContextsApiDeleteCollaborationContextRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollaborationContextsApi
   */
  public deleteCollaborationContext(
    requestParameters: CollaborationContextsApiDeleteCollaborationContextRequest,
    options?: AxiosRequestConfig
  ) {
    return CollaborationContextsApiFp(this.configuration)
      .deleteCollaborationContext(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `collaboration-context` by ID.
   * @param {CollaborationContextsApiGetCollaborationContextRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollaborationContextsApi
   */
  public getCollaborationContext(
    requestParameters: CollaborationContextsApiGetCollaborationContextRequest,
    options?: AxiosRequestConfig
  ) {
    return CollaborationContextsApiFp(this.configuration)
      .getCollaborationContext(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List `collaboration-context`s
   * @param {CollaborationContextsApiListCollaborationContextsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollaborationContextsApi
   */
  public listCollaborationContexts(
    requestParameters: CollaborationContextsApiListCollaborationContextsRequest = {},
    options?: AxiosRequestConfig
  ) {
    return CollaborationContextsApiFp(this.configuration)
      .listCollaborationContexts(
        requestParameters.pageCursor,
        requestParameters.pageSize,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ExportsApi - axios parameter creator
 * @export
 */
export const ExportsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create an `export`. This API is asynchronous, returning the location of a `queued-export`. Check the status via the getQueuedExport API.
     * @param {CreateExportRequest} createExportRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createExport: async (
      createExportRequest: CreateExportRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createExportRequest' is not null or undefined
      assertParamExists(
        'createExport',
        'createExportRequest',
        createExportRequest
      );
      const localVarPath = `/exports`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createExportRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get an `export` by ID.
     * @param {string} id The &#x60;export&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExport: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getExport', 'id', id);
      const localVarPath = `/exports/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `queued-export`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `export`.
     * @param {string} id The &#x60;queued-export&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedExport: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getQueuedExport', 'id', id);
      const localVarPath = `/queued-exports/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ExportsApi - functional programming interface
 * @export
 */
export const ExportsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ExportsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create an `export`. This API is asynchronous, returning the location of a `queued-export`. Check the status via the getQueuedExport API.
     * @param {CreateExportRequest} createExportRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createExport(
      createExportRequest: CreateExportRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createExport(
        createExportRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get an `export` by ID.
     * @param {string} id The &#x60;export&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getExport(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Export>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getExport(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `queued-export`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `export`.
     * @param {string} id The &#x60;queued-export&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedExport(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getQueuedExport(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ExportsApi - factory interface
 * @export
 */
export const ExportsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ExportsApiFp(configuration);
  return {
    /**
     * Create an `export`. This API is asynchronous, returning the location of a `queued-export`. Check the status via the getQueuedExport API.
     * @param {CreateExportRequest} createExportRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createExport(
      createExportRequest: CreateExportRequest,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return localVarFp
        .createExport(createExportRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get an `export` by ID.
     * @param {string} id The &#x60;export&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExport(id: string, options?: any): AxiosPromise<Export> {
      return localVarFp
        .getExport(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `queued-export`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `export`.
     * @param {string} id The &#x60;queued-export&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedExport(id: string, options?: any): AxiosPromise<QueuedJob> {
      return localVarFp
        .getQueuedExport(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createExport operation in ExportsApi.
 * @export
 * @interface ExportsApiCreateExportRequest
 */
export interface ExportsApiCreateExportRequest {
  /**
   *
   * @type {CreateExportRequest}
   * @memberof ExportsApiCreateExport
   */
  readonly createExportRequest: CreateExportRequest;
}

/**
 * Request parameters for getExport operation in ExportsApi.
 * @export
 * @interface ExportsApiGetExportRequest
 */
export interface ExportsApiGetExportRequest {
  /**
   * The &#x60;export&#x60; ID.
   * @type {string}
   * @memberof ExportsApiGetExport
   */
  readonly id: string;
}

/**
 * Request parameters for getQueuedExport operation in ExportsApi.
 * @export
 * @interface ExportsApiGetQueuedExportRequest
 */
export interface ExportsApiGetQueuedExportRequest {
  /**
   * The &#x60;queued-export&#x60; ID.
   * @type {string}
   * @memberof ExportsApiGetQueuedExport
   */
  readonly id: string;
}

/**
 * ExportsApi - object-oriented interface
 * @export
 * @class ExportsApi
 * @extends {BaseAPI}
 */
export class ExportsApi extends BaseAPI {
  /**
   * Create an `export`. This API is asynchronous, returning the location of a `queued-export`. Check the status via the getQueuedExport API.
   * @param {ExportsApiCreateExportRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExportsApi
   */
  public createExport(
    requestParameters: ExportsApiCreateExportRequest,
    options?: AxiosRequestConfig
  ) {
    return ExportsApiFp(this.configuration)
      .createExport(requestParameters.createExportRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get an `export` by ID.
   * @param {ExportsApiGetExportRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExportsApi
   */
  public getExport(
    requestParameters: ExportsApiGetExportRequest,
    options?: AxiosRequestConfig
  ) {
    return ExportsApiFp(this.configuration)
      .getExport(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `queued-export`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `export`.
   * @param {ExportsApiGetQueuedExportRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExportsApi
   */
  public getQueuedExport(
    requestParameters: ExportsApiGetQueuedExportRequest,
    options?: AxiosRequestConfig
  ) {
    return ExportsApiFp(this.configuration)
      .getQueuedExport(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FileCollectionsApi - axios parameter creator
 * @export
 */
export const FileCollectionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Add files to a `file-collection`.
     * @param {string} id The &#x60;file-collection&#x60; ID.
     * @param {FileIdList} fileIdList
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFileCollectionFiles: async (
      id: string,
      fileIdList: FileIdList,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('addFileCollectionFiles', 'id', id);
      // verify required parameter 'fileIdList' is not null or undefined
      assertParamExists('addFileCollectionFiles', 'fileIdList', fileIdList);
      const localVarPath = `/file-collections/{id}/files`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        fileIdList,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a `file-collection`.
     * @param {CreateFileCollectionRequest} createFileCollectionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFileCollection: async (
      createFileCollectionRequest: CreateFileCollectionRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createFileCollectionRequest' is not null or undefined
      assertParamExists(
        'createFileCollection',
        'createFileCollectionRequest',
        createFileCollectionRequest
      );
      const localVarPath = `/file-collections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createFileCollectionRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a `file-collection`.
     * @param {string} id The &#x60;file-collection&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFileCollection: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteFileCollection', 'id', id);
      const localVarPath = `/file-collections/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `file-collection` by ID.
     * @param {string} id The &#x60;file-collection&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileCollection: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getFileCollection', 'id', id);
      const localVarPath = `/file-collections/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List the files in a `file-collection`.
     * @param {string} id The &#x60;file-collection&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFileCollectionFiles: async (
      id: string,
      pageCursor?: string,
      pageSize?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('listFileCollectionFiles', 'id', id);
      const localVarPath = `/file-collections/{id}/files`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List `file-collection`s by supplied ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFileCollections: async (
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/file-collections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (filterSuppliedId !== undefined) {
        localVarQueryParameter['filter[suppliedId]'] = filterSuppliedId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Remove a file from a `file-collection`.
     * @param {string} id The &#x60;file-collection&#x60; ID.
     * @param {string} [filterFileId] Comma-separated list of file-ids to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFileCollectionFiles: async (
      id: string,
      filterFileId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('removeFileCollectionFiles', 'id', id);
      const localVarPath = `/file-collections/{id}/files`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (filterFileId !== undefined) {
        localVarQueryParameter['filter[fileId]'] = filterFileId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a `file-collection`.
     * @param {string} id The &#x60;file-collection&#x60; ID.
     * @param {UpdateFileCollectionRequest} updateFileCollectionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFileCollection: async (
      id: string,
      updateFileCollectionRequest: UpdateFileCollectionRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateFileCollection', 'id', id);
      // verify required parameter 'updateFileCollectionRequest' is not null or undefined
      assertParamExists(
        'updateFileCollection',
        'updateFileCollectionRequest',
        updateFileCollectionRequest
      );
      const localVarPath = `/file-collections/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateFileCollectionRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FileCollectionsApi - functional programming interface
 * @export
 */
export const FileCollectionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    FileCollectionsApiAxiosParamCreator(configuration);
  return {
    /**
     * Add files to a `file-collection`.
     * @param {string} id The &#x60;file-collection&#x60; ID.
     * @param {FileIdList} fileIdList
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addFileCollectionFiles(
      id: string,
      fileIdList: FileIdList,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<FileCollectionMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addFileCollectionFiles(
          id,
          fileIdList,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Create a `file-collection`.
     * @param {CreateFileCollectionRequest} createFileCollectionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFileCollection(
      createFileCollectionRequest: CreateFileCollectionRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<FileCollectionMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createFileCollection(
          createFileCollectionRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete a `file-collection`.
     * @param {string} id The &#x60;file-collection&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFileCollection(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteFileCollection(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `file-collection` by ID.
     * @param {string} id The &#x60;file-collection&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFileCollection(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<FileCollectionMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFileCollection(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * List the files in a `file-collection`.
     * @param {string} id The &#x60;file-collection&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listFileCollectionFiles(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listFileCollectionFiles(
          id,
          pageCursor,
          pageSize,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * List `file-collection`s by supplied ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listFileCollections(
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<FileCollectionList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listFileCollections(
          pageCursor,
          pageSize,
          filterSuppliedId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Remove a file from a `file-collection`.
     * @param {string} id The &#x60;file-collection&#x60; ID.
     * @param {string} [filterFileId] Comma-separated list of file-ids to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeFileCollectionFiles(
      id: string,
      filterFileId?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.removeFileCollectionFiles(
          id,
          filterFileId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update a `file-collection`.
     * @param {string} id The &#x60;file-collection&#x60; ID.
     * @param {UpdateFileCollectionRequest} updateFileCollectionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFileCollection(
      id: string,
      updateFileCollectionRequest: UpdateFileCollectionRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateFileCollection(
          id,
          updateFileCollectionRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * FileCollectionsApi - factory interface
 * @export
 */
export const FileCollectionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = FileCollectionsApiFp(configuration);
  return {
    /**
     * Add files to a `file-collection`.
     * @param {string} id The &#x60;file-collection&#x60; ID.
     * @param {FileIdList} fileIdList
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFileCollectionFiles(
      id: string,
      fileIdList: FileIdList,
      options?: any
    ): AxiosPromise<FileCollectionMetadata> {
      return localVarFp
        .addFileCollectionFiles(id, fileIdList, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a `file-collection`.
     * @param {CreateFileCollectionRequest} createFileCollectionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFileCollection(
      createFileCollectionRequest: CreateFileCollectionRequest,
      options?: any
    ): AxiosPromise<FileCollectionMetadata> {
      return localVarFp
        .createFileCollection(createFileCollectionRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a `file-collection`.
     * @param {string} id The &#x60;file-collection&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFileCollection(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteFileCollection(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `file-collection` by ID.
     * @param {string} id The &#x60;file-collection&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileCollection(
      id: string,
      options?: any
    ): AxiosPromise<FileCollectionMetadata> {
      return localVarFp
        .getFileCollection(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List the files in a `file-collection`.
     * @param {string} id The &#x60;file-collection&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFileCollectionFiles(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<FileList> {
      return localVarFp
        .listFileCollectionFiles(id, pageCursor, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List `file-collection`s by supplied ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFileCollections(
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      options?: any
    ): AxiosPromise<FileCollectionList> {
      return localVarFp
        .listFileCollections(pageCursor, pageSize, filterSuppliedId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Remove a file from a `file-collection`.
     * @param {string} id The &#x60;file-collection&#x60; ID.
     * @param {string} [filterFileId] Comma-separated list of file-ids to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFileCollectionFiles(
      id: string,
      filterFileId?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .removeFileCollectionFiles(id, filterFileId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update a `file-collection`.
     * @param {string} id The &#x60;file-collection&#x60; ID.
     * @param {UpdateFileCollectionRequest} updateFileCollectionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFileCollection(
      id: string,
      updateFileCollectionRequest: UpdateFileCollectionRequest,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .updateFileCollection(id, updateFileCollectionRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for addFileCollectionFiles operation in FileCollectionsApi.
 * @export
 * @interface FileCollectionsApiAddFileCollectionFilesRequest
 */
export interface FileCollectionsApiAddFileCollectionFilesRequest {
  /**
   * The &#x60;file-collection&#x60; ID.
   * @type {string}
   * @memberof FileCollectionsApiAddFileCollectionFiles
   */
  readonly id: string;

  /**
   *
   * @type {FileIdList}
   * @memberof FileCollectionsApiAddFileCollectionFiles
   */
  readonly fileIdList: FileIdList;
}

/**
 * Request parameters for createFileCollection operation in FileCollectionsApi.
 * @export
 * @interface FileCollectionsApiCreateFileCollectionRequest
 */
export interface FileCollectionsApiCreateFileCollectionRequest {
  /**
   *
   * @type {CreateFileCollectionRequest}
   * @memberof FileCollectionsApiCreateFileCollection
   */
  readonly createFileCollectionRequest: CreateFileCollectionRequest;
}

/**
 * Request parameters for deleteFileCollection operation in FileCollectionsApi.
 * @export
 * @interface FileCollectionsApiDeleteFileCollectionRequest
 */
export interface FileCollectionsApiDeleteFileCollectionRequest {
  /**
   * The &#x60;file-collection&#x60; ID.
   * @type {string}
   * @memberof FileCollectionsApiDeleteFileCollection
   */
  readonly id: string;
}

/**
 * Request parameters for getFileCollection operation in FileCollectionsApi.
 * @export
 * @interface FileCollectionsApiGetFileCollectionRequest
 */
export interface FileCollectionsApiGetFileCollectionRequest {
  /**
   * The &#x60;file-collection&#x60; ID.
   * @type {string}
   * @memberof FileCollectionsApiGetFileCollection
   */
  readonly id: string;
}

/**
 * Request parameters for listFileCollectionFiles operation in FileCollectionsApi.
 * @export
 * @interface FileCollectionsApiListFileCollectionFilesRequest
 */
export interface FileCollectionsApiListFileCollectionFilesRequest {
  /**
   * The &#x60;file-collection&#x60; ID.
   * @type {string}
   * @memberof FileCollectionsApiListFileCollectionFiles
   */
  readonly id: string;

  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof FileCollectionsApiListFileCollectionFiles
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof FileCollectionsApiListFileCollectionFiles
   */
  readonly pageSize?: number;
}

/**
 * Request parameters for listFileCollections operation in FileCollectionsApi.
 * @export
 * @interface FileCollectionsApiListFileCollectionsRequest
 */
export interface FileCollectionsApiListFileCollectionsRequest {
  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof FileCollectionsApiListFileCollections
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof FileCollectionsApiListFileCollections
   */
  readonly pageSize?: number;

  /**
   * Comma-separated list of supplied IDs to filter on.
   * @type {string}
   * @memberof FileCollectionsApiListFileCollections
   */
  readonly filterSuppliedId?: string;
}

/**
 * Request parameters for removeFileCollectionFiles operation in FileCollectionsApi.
 * @export
 * @interface FileCollectionsApiRemoveFileCollectionFilesRequest
 */
export interface FileCollectionsApiRemoveFileCollectionFilesRequest {
  /**
   * The &#x60;file-collection&#x60; ID.
   * @type {string}
   * @memberof FileCollectionsApiRemoveFileCollectionFiles
   */
  readonly id: string;

  /**
   * Comma-separated list of file-ids to filter on.
   * @type {string}
   * @memberof FileCollectionsApiRemoveFileCollectionFiles
   */
  readonly filterFileId?: string;
}

/**
 * Request parameters for updateFileCollection operation in FileCollectionsApi.
 * @export
 * @interface FileCollectionsApiUpdateFileCollectionRequest
 */
export interface FileCollectionsApiUpdateFileCollectionRequest {
  /**
   * The &#x60;file-collection&#x60; ID.
   * @type {string}
   * @memberof FileCollectionsApiUpdateFileCollection
   */
  readonly id: string;

  /**
   *
   * @type {UpdateFileCollectionRequest}
   * @memberof FileCollectionsApiUpdateFileCollection
   */
  readonly updateFileCollectionRequest: UpdateFileCollectionRequest;
}

/**
 * FileCollectionsApi - object-oriented interface
 * @export
 * @class FileCollectionsApi
 * @extends {BaseAPI}
 */
export class FileCollectionsApi extends BaseAPI {
  /**
   * Add files to a `file-collection`.
   * @param {FileCollectionsApiAddFileCollectionFilesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileCollectionsApi
   */
  public addFileCollectionFiles(
    requestParameters: FileCollectionsApiAddFileCollectionFilesRequest,
    options?: AxiosRequestConfig
  ) {
    return FileCollectionsApiFp(this.configuration)
      .addFileCollectionFiles(
        requestParameters.id,
        requestParameters.fileIdList,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a `file-collection`.
   * @param {FileCollectionsApiCreateFileCollectionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileCollectionsApi
   */
  public createFileCollection(
    requestParameters: FileCollectionsApiCreateFileCollectionRequest,
    options?: AxiosRequestConfig
  ) {
    return FileCollectionsApiFp(this.configuration)
      .createFileCollection(
        requestParameters.createFileCollectionRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a `file-collection`.
   * @param {FileCollectionsApiDeleteFileCollectionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileCollectionsApi
   */
  public deleteFileCollection(
    requestParameters: FileCollectionsApiDeleteFileCollectionRequest,
    options?: AxiosRequestConfig
  ) {
    return FileCollectionsApiFp(this.configuration)
      .deleteFileCollection(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `file-collection` by ID.
   * @param {FileCollectionsApiGetFileCollectionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileCollectionsApi
   */
  public getFileCollection(
    requestParameters: FileCollectionsApiGetFileCollectionRequest,
    options?: AxiosRequestConfig
  ) {
    return FileCollectionsApiFp(this.configuration)
      .getFileCollection(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List the files in a `file-collection`.
   * @param {FileCollectionsApiListFileCollectionFilesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileCollectionsApi
   */
  public listFileCollectionFiles(
    requestParameters: FileCollectionsApiListFileCollectionFilesRequest,
    options?: AxiosRequestConfig
  ) {
    return FileCollectionsApiFp(this.configuration)
      .listFileCollectionFiles(
        requestParameters.id,
        requestParameters.pageCursor,
        requestParameters.pageSize,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List `file-collection`s by supplied ID.
   * @param {FileCollectionsApiListFileCollectionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileCollectionsApi
   */
  public listFileCollections(
    requestParameters: FileCollectionsApiListFileCollectionsRequest = {},
    options?: AxiosRequestConfig
  ) {
    return FileCollectionsApiFp(this.configuration)
      .listFileCollections(
        requestParameters.pageCursor,
        requestParameters.pageSize,
        requestParameters.filterSuppliedId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Remove a file from a `file-collection`.
   * @param {FileCollectionsApiRemoveFileCollectionFilesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileCollectionsApi
   */
  public removeFileCollectionFiles(
    requestParameters: FileCollectionsApiRemoveFileCollectionFilesRequest,
    options?: AxiosRequestConfig
  ) {
    return FileCollectionsApiFp(this.configuration)
      .removeFileCollectionFiles(
        requestParameters.id,
        requestParameters.filterFileId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update a `file-collection`.
   * @param {FileCollectionsApiUpdateFileCollectionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileCollectionsApi
   */
  public updateFileCollection(
    requestParameters: FileCollectionsApiUpdateFileCollectionRequest,
    options?: AxiosRequestConfig
  ) {
    return FileCollectionsApiFp(this.configuration)
      .updateFileCollection(
        requestParameters.id,
        requestParameters.updateFileCollectionRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FileJobsApi - axios parameter creator
 * @export
 */
export const FileJobsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a `file-job`.
     * @param {CreateFileJobRequest} createFileJobRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFileJob: async (
      createFileJobRequest: CreateFileJobRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createFileJobRequest' is not null or undefined
      assertParamExists(
        'createFileJob',
        'createFileJobRequest',
        createFileJobRequest
      );
      const localVarPath = `/file-jobs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createFileJobRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the status and result of a `file-job`.
     * @param {string} id The ID of a file job.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileJob: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getFileJob', 'id', id);
      const localVarPath = `/file-jobs/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FileJobsApi - functional programming interface
 * @export
 */
export const FileJobsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FileJobsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a `file-job`.
     * @param {CreateFileJobRequest} createFileJobRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFileJob(
      createFileJobRequest: CreateFileJobRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createFileJob(
        createFileJobRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get the status and result of a `file-job`.
     * @param {string} id The ID of a file job.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFileJob(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFileJob(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * FileJobsApi - factory interface
 * @export
 */
export const FileJobsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = FileJobsApiFp(configuration);
  return {
    /**
     * Create a `file-job`.
     * @param {CreateFileJobRequest} createFileJobRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFileJob(
      createFileJobRequest: CreateFileJobRequest,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return localVarFp
        .createFileJob(createFileJobRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the status and result of a `file-job`.
     * @param {string} id The ID of a file job.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileJob(id: string, options?: any): AxiosPromise<QueuedJob> {
      return localVarFp
        .getFileJob(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createFileJob operation in FileJobsApi.
 * @export
 * @interface FileJobsApiCreateFileJobRequest
 */
export interface FileJobsApiCreateFileJobRequest {
  /**
   *
   * @type {CreateFileJobRequest}
   * @memberof FileJobsApiCreateFileJob
   */
  readonly createFileJobRequest: CreateFileJobRequest;
}

/**
 * Request parameters for getFileJob operation in FileJobsApi.
 * @export
 * @interface FileJobsApiGetFileJobRequest
 */
export interface FileJobsApiGetFileJobRequest {
  /**
   * The ID of a file job.
   * @type {string}
   * @memberof FileJobsApiGetFileJob
   */
  readonly id: string;
}

/**
 * FileJobsApi - object-oriented interface
 * @export
 * @class FileJobsApi
 * @extends {BaseAPI}
 */
export class FileJobsApi extends BaseAPI {
  /**
   * Create a `file-job`.
   * @param {FileJobsApiCreateFileJobRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileJobsApi
   */
  public createFileJob(
    requestParameters: FileJobsApiCreateFileJobRequest,
    options?: AxiosRequestConfig
  ) {
    return FileJobsApiFp(this.configuration)
      .createFileJob(requestParameters.createFileJobRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the status and result of a `file-job`.
   * @param {FileJobsApiGetFileJobRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileJobsApi
   */
  public getFileJob(
    requestParameters: FileJobsApiGetFileJobRequest,
    options?: AxiosRequestConfig
  ) {
    return FileJobsApiFp(this.configuration)
      .getFileJob(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a download uri for a `file` by ID.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {CreateDownloadRequest} createDownloadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDownloadUrl: async (
      id: string,
      createDownloadRequest: CreateDownloadRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createDownloadUrl', 'id', id);
      // verify required parameter 'createDownloadRequest' is not null or undefined
      assertParamExists(
        'createDownloadUrl',
        'createDownloadRequest',
        createDownloadRequest
      );
      const localVarPath = `/files/{id}/download-url`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createDownloadRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a `file`. Once created, upload file content via the uploadFile API. For details including supported file formats, see our [Import data](https://developer.vertexvis.com/docs/guides/import-data-with-api) guide.
     * @param {CreateFileRequest} createFileRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFile: async (
      createFileRequest: CreateFileRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createFileRequest' is not null or undefined
      assertParamExists('createFile', 'createFileRequest', createFileRequest);
      const localVarPath = `/files`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createFileRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create an upload uri for a `file` by ID.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {CreateUploadRequest} createUploadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUploadUrl: async (
      id: string,
      createUploadRequest: CreateUploadRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createUploadUrl', 'id', id);
      // verify required parameter 'createUploadRequest' is not null or undefined
      assertParamExists(
        'createUploadUrl',
        'createUploadRequest',
        createUploadRequest
      );
      const localVarPath = `/files/{id}/upload-url`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createUploadRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a `file`.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteFile', 'id', id);
      const localVarPath = `/files/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `file` by ID.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getFile', 'id', id);
      const localVarPath = `/files/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get `files`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFiles: async (
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/files`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (filterSuppliedId !== undefined) {
        localVarQueryParameter['filter[suppliedId]'] = filterSuppliedId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a `file`.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {UpdateFileRequest} updateFileRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFile: async (
      id: string,
      updateFileRequest: UpdateFileRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateFile', 'id', id);
      // verify required parameter 'updateFileRequest' is not null or undefined
      assertParamExists('updateFile', 'updateFileRequest', updateFileRequest);
      const localVarPath = `/files/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateFileRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Upload a `file`. Once uploaded, create either parts or geometry sets via the createPart or createGeometrySet APIs.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile: async (
      id: string,
      body: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('uploadFile', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('uploadFile', 'body', body);
      const localVarPath = `/files/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a download uri for a `file` by ID.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {CreateDownloadRequest} createDownloadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDownloadUrl(
      id: string,
      createDownloadRequest: CreateDownloadRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DownloadUrl>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createDownloadUrl(
          id,
          createDownloadRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Create a `file`. Once created, upload file content via the uploadFile API. For details including supported file formats, see our [Import data](https://developer.vertexvis.com/docs/guides/import-data-with-api) guide.
     * @param {CreateFileRequest} createFileRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFile(
      createFileRequest: CreateFileRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createFile(
        createFileRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Create an upload uri for a `file` by ID.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {CreateUploadRequest} createUploadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUploadUrl(
      id: string,
      createUploadRequest: CreateUploadRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PresignedUrl>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUploadUrl(
        id,
        createUploadRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete a `file`.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFile(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `file` by ID.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFile(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get `files`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFiles(
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFiles(
        pageCursor,
        pageSize,
        filterSuppliedId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update a `file`.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {UpdateFileRequest} updateFileRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFile(
      id: string,
      updateFileRequest: UpdateFileRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateFile(
        id,
        updateFileRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Upload a `file`. Once uploaded, create either parts or geometry sets via the createPart or createGeometrySet APIs.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadFile(
      id: string,
      body: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(
        id,
        body,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = FilesApiFp(configuration);
  return {
    /**
     * Create a download uri for a `file` by ID.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {CreateDownloadRequest} createDownloadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDownloadUrl(
      id: string,
      createDownloadRequest: CreateDownloadRequest,
      options?: any
    ): AxiosPromise<DownloadUrl> {
      return localVarFp
        .createDownloadUrl(id, createDownloadRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a `file`. Once created, upload file content via the uploadFile API. For details including supported file formats, see our [Import data](https://developer.vertexvis.com/docs/guides/import-data-with-api) guide.
     * @param {CreateFileRequest} createFileRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFile(
      createFileRequest: CreateFileRequest,
      options?: any
    ): AxiosPromise<FileMetadata> {
      return localVarFp
        .createFile(createFileRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create an upload uri for a `file` by ID.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {CreateUploadRequest} createUploadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUploadUrl(
      id: string,
      createUploadRequest: CreateUploadRequest,
      options?: any
    ): AxiosPromise<PresignedUrl> {
      return localVarFp
        .createUploadUrl(id, createUploadRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a `file`.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(id: string, options?: any): AxiosPromise<FileMetadata> {
      return localVarFp
        .deleteFile(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `file` by ID.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile(id: string, options?: any): AxiosPromise<FileMetadata> {
      return localVarFp
        .getFile(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get `files`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFiles(
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      options?: any
    ): AxiosPromise<FileList> {
      return localVarFp
        .getFiles(pageCursor, pageSize, filterSuppliedId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update a `file`.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {UpdateFileRequest} updateFileRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFile(
      id: string,
      updateFileRequest: UpdateFileRequest,
      options?: any
    ): AxiosPromise<FileMetadata> {
      return localVarFp
        .updateFile(id, updateFileRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Upload a `file`. Once uploaded, create either parts or geometry sets via the createPart or createGeometrySet APIs.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile(id: string, body: any, options?: any): AxiosPromise<void> {
      return localVarFp
        .uploadFile(id, body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createDownloadUrl operation in FilesApi.
 * @export
 * @interface FilesApiCreateDownloadUrlRequest
 */
export interface FilesApiCreateDownloadUrlRequest {
  /**
   * The &#x60;file&#x60; ID.
   * @type {string}
   * @memberof FilesApiCreateDownloadUrl
   */
  readonly id: string;

  /**
   *
   * @type {CreateDownloadRequest}
   * @memberof FilesApiCreateDownloadUrl
   */
  readonly createDownloadRequest: CreateDownloadRequest;
}

/**
 * Request parameters for createFile operation in FilesApi.
 * @export
 * @interface FilesApiCreateFileRequest
 */
export interface FilesApiCreateFileRequest {
  /**
   *
   * @type {CreateFileRequest}
   * @memberof FilesApiCreateFile
   */
  readonly createFileRequest: CreateFileRequest;
}

/**
 * Request parameters for createUploadUrl operation in FilesApi.
 * @export
 * @interface FilesApiCreateUploadUrlRequest
 */
export interface FilesApiCreateUploadUrlRequest {
  /**
   * The &#x60;file&#x60; ID.
   * @type {string}
   * @memberof FilesApiCreateUploadUrl
   */
  readonly id: string;

  /**
   *
   * @type {CreateUploadRequest}
   * @memberof FilesApiCreateUploadUrl
   */
  readonly createUploadRequest: CreateUploadRequest;
}

/**
 * Request parameters for deleteFile operation in FilesApi.
 * @export
 * @interface FilesApiDeleteFileRequest
 */
export interface FilesApiDeleteFileRequest {
  /**
   * The &#x60;file&#x60; ID.
   * @type {string}
   * @memberof FilesApiDeleteFile
   */
  readonly id: string;
}

/**
 * Request parameters for getFile operation in FilesApi.
 * @export
 * @interface FilesApiGetFileRequest
 */
export interface FilesApiGetFileRequest {
  /**
   * The &#x60;file&#x60; ID.
   * @type {string}
   * @memberof FilesApiGetFile
   */
  readonly id: string;
}

/**
 * Request parameters for getFiles operation in FilesApi.
 * @export
 * @interface FilesApiGetFilesRequest
 */
export interface FilesApiGetFilesRequest {
  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof FilesApiGetFiles
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof FilesApiGetFiles
   */
  readonly pageSize?: number;

  /**
   * Comma-separated list of supplied IDs to filter on.
   * @type {string}
   * @memberof FilesApiGetFiles
   */
  readonly filterSuppliedId?: string;
}

/**
 * Request parameters for updateFile operation in FilesApi.
 * @export
 * @interface FilesApiUpdateFileRequest
 */
export interface FilesApiUpdateFileRequest {
  /**
   * The &#x60;file&#x60; ID.
   * @type {string}
   * @memberof FilesApiUpdateFile
   */
  readonly id: string;

  /**
   *
   * @type {UpdateFileRequest}
   * @memberof FilesApiUpdateFile
   */
  readonly updateFileRequest: UpdateFileRequest;
}

/**
 * Request parameters for uploadFile operation in FilesApi.
 * @export
 * @interface FilesApiUploadFileRequest
 */
export interface FilesApiUploadFileRequest {
  /**
   * The &#x60;file&#x60; ID.
   * @type {string}
   * @memberof FilesApiUploadFile
   */
  readonly id: string;

  /**
   *
   * @type {any}
   * @memberof FilesApiUploadFile
   */
  readonly body: any;
}

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
  /**
   * Create a download uri for a `file` by ID.
   * @param {FilesApiCreateDownloadUrlRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public createDownloadUrl(
    requestParameters: FilesApiCreateDownloadUrlRequest,
    options?: AxiosRequestConfig
  ) {
    return FilesApiFp(this.configuration)
      .createDownloadUrl(
        requestParameters.id,
        requestParameters.createDownloadRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a `file`. Once created, upload file content via the uploadFile API. For details including supported file formats, see our [Import data](https://developer.vertexvis.com/docs/guides/import-data-with-api) guide.
   * @param {FilesApiCreateFileRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public createFile(
    requestParameters: FilesApiCreateFileRequest,
    options?: AxiosRequestConfig
  ) {
    return FilesApiFp(this.configuration)
      .createFile(requestParameters.createFileRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create an upload uri for a `file` by ID.
   * @param {FilesApiCreateUploadUrlRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public createUploadUrl(
    requestParameters: FilesApiCreateUploadUrlRequest,
    options?: AxiosRequestConfig
  ) {
    return FilesApiFp(this.configuration)
      .createUploadUrl(
        requestParameters.id,
        requestParameters.createUploadRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a `file`.
   * @param {FilesApiDeleteFileRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public deleteFile(
    requestParameters: FilesApiDeleteFileRequest,
    options?: AxiosRequestConfig
  ) {
    return FilesApiFp(this.configuration)
      .deleteFile(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `file` by ID.
   * @param {FilesApiGetFileRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public getFile(
    requestParameters: FilesApiGetFileRequest,
    options?: AxiosRequestConfig
  ) {
    return FilesApiFp(this.configuration)
      .getFile(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get `files`.
   * @param {FilesApiGetFilesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public getFiles(
    requestParameters: FilesApiGetFilesRequest = {},
    options?: AxiosRequestConfig
  ) {
    return FilesApiFp(this.configuration)
      .getFiles(
        requestParameters.pageCursor,
        requestParameters.pageSize,
        requestParameters.filterSuppliedId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update a `file`.
   * @param {FilesApiUpdateFileRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public updateFile(
    requestParameters: FilesApiUpdateFileRequest,
    options?: AxiosRequestConfig
  ) {
    return FilesApiFp(this.configuration)
      .updateFile(
        requestParameters.id,
        requestParameters.updateFileRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Upload a `file`. Once uploaded, create either parts or geometry sets via the createPart or createGeometrySet APIs.
   * @param {FilesApiUploadFileRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public uploadFile(
    requestParameters: FilesApiUploadFileRequest,
    options?: AxiosRequestConfig
  ) {
    return FilesApiFp(this.configuration)
      .uploadFile(requestParameters.id, requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * GeometrySetsApi - axios parameter creator
 * @export
 */
export const GeometrySetsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a `geometry-set`. Once created, create scenes via the createScene API. For details, see our [Import data](https://developer.vertexvis.com/docs/guides/import-data-with-api) guide.
     * @param {CreateGeometrySetRequest} createGeometrySetRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGeometrySet: async (
      createGeometrySetRequest: CreateGeometrySetRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createGeometrySetRequest' is not null or undefined
      assertParamExists(
        'createGeometrySet',
        'createGeometrySetRequest',
        createGeometrySetRequest
      );
      const localVarPath = `/geometry-sets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createGeometrySetRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `geometry-set` by ID.
     * @param {string} id The &#x60;geometry-set&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGeometrySet: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getGeometrySet', 'id', id);
      const localVarPath = `/geometry-sets/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get `geometry-sets`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGeometrySets: async (
      pageCursor?: string,
      pageSize?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/geometry-sets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GeometrySetsApi - functional programming interface
 * @export
 */
export const GeometrySetsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    GeometrySetsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a `geometry-set`. Once created, create scenes via the createScene API. For details, see our [Import data](https://developer.vertexvis.com/docs/guides/import-data-with-api) guide.
     * @param {CreateGeometrySetRequest} createGeometrySetRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createGeometrySet(
      createGeometrySetRequest: CreateGeometrySetRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createGeometrySet(
          createGeometrySetRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `geometry-set` by ID.
     * @param {string} id The &#x60;geometry-set&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGeometrySet(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeometrySet>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGeometrySet(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get `geometry-sets`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGeometrySets(
      pageCursor?: string,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GeometrySetList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGeometrySets(
        pageCursor,
        pageSize,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * GeometrySetsApi - factory interface
 * @export
 */
export const GeometrySetsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = GeometrySetsApiFp(configuration);
  return {
    /**
     * Create a `geometry-set`. Once created, create scenes via the createScene API. For details, see our [Import data](https://developer.vertexvis.com/docs/guides/import-data-with-api) guide.
     * @param {CreateGeometrySetRequest} createGeometrySetRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGeometrySet(
      createGeometrySetRequest: CreateGeometrySetRequest,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return localVarFp
        .createGeometrySet(createGeometrySetRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `geometry-set` by ID.
     * @param {string} id The &#x60;geometry-set&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGeometrySet(id: string, options?: any): AxiosPromise<GeometrySet> {
      return localVarFp
        .getGeometrySet(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get `geometry-sets`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGeometrySets(
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<GeometrySetList> {
      return localVarFp
        .getGeometrySets(pageCursor, pageSize, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createGeometrySet operation in GeometrySetsApi.
 * @export
 * @interface GeometrySetsApiCreateGeometrySetRequest
 */
export interface GeometrySetsApiCreateGeometrySetRequest {
  /**
   *
   * @type {CreateGeometrySetRequest}
   * @memberof GeometrySetsApiCreateGeometrySet
   */
  readonly createGeometrySetRequest: CreateGeometrySetRequest;
}

/**
 * Request parameters for getGeometrySet operation in GeometrySetsApi.
 * @export
 * @interface GeometrySetsApiGetGeometrySetRequest
 */
export interface GeometrySetsApiGetGeometrySetRequest {
  /**
   * The &#x60;geometry-set&#x60; ID.
   * @type {string}
   * @memberof GeometrySetsApiGetGeometrySet
   */
  readonly id: string;
}

/**
 * Request parameters for getGeometrySets operation in GeometrySetsApi.
 * @export
 * @interface GeometrySetsApiGetGeometrySetsRequest
 */
export interface GeometrySetsApiGetGeometrySetsRequest {
  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof GeometrySetsApiGetGeometrySets
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof GeometrySetsApiGetGeometrySets
   */
  readonly pageSize?: number;
}

/**
 * GeometrySetsApi - object-oriented interface
 * @export
 * @class GeometrySetsApi
 * @extends {BaseAPI}
 */
export class GeometrySetsApi extends BaseAPI {
  /**
   * Create a `geometry-set`. Once created, create scenes via the createScene API. For details, see our [Import data](https://developer.vertexvis.com/docs/guides/import-data-with-api) guide.
   * @param {GeometrySetsApiCreateGeometrySetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeometrySetsApi
   */
  public createGeometrySet(
    requestParameters: GeometrySetsApiCreateGeometrySetRequest,
    options?: AxiosRequestConfig
  ) {
    return GeometrySetsApiFp(this.configuration)
      .createGeometrySet(requestParameters.createGeometrySetRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `geometry-set` by ID.
   * @param {GeometrySetsApiGetGeometrySetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeometrySetsApi
   */
  public getGeometrySet(
    requestParameters: GeometrySetsApiGetGeometrySetRequest,
    options?: AxiosRequestConfig
  ) {
    return GeometrySetsApiFp(this.configuration)
      .getGeometrySet(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get `geometry-sets`.
   * @param {GeometrySetsApiGetGeometrySetsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeometrySetsApi
   */
  public getGeometrySets(
    requestParameters: GeometrySetsApiGetGeometrySetsRequest = {},
    options?: AxiosRequestConfig
  ) {
    return GeometrySetsApiFp(this.configuration)
      .getGeometrySets(
        requestParameters.pageCursor,
        requestParameters.pageSize,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HitsApi - axios parameter creator
 * @export
 */
export const HitsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a `hit` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateHitRequest} createHitRequest
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {string} [fieldsPartRevision] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneHit: async (
      id: string,
      createHitRequest: CreateHitRequest,
      include?: string,
      fieldsPartRevision?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createSceneHit', 'id', id);
      // verify required parameter 'createHitRequest' is not null or undefined
      assertParamExists('createSceneHit', 'createHitRequest', createHitRequest);
      const localVarPath = `/scenes/{id}/hits`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (include !== undefined) {
        localVarQueryParameter['include'] = include;
      }

      if (fieldsPartRevision !== undefined) {
        localVarQueryParameter['fields[part-revision]'] = fieldsPartRevision;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createHitRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a `hit` for a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateHitRequest} createHitRequest
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {string} [fieldsPartRevision] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneViewHit: async (
      id: string,
      createHitRequest: CreateHitRequest,
      include?: string,
      fieldsPartRevision?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createSceneViewHit', 'id', id);
      // verify required parameter 'createHitRequest' is not null or undefined
      assertParamExists(
        'createSceneViewHit',
        'createHitRequest',
        createHitRequest
      );
      const localVarPath = `/scene-views/{id}/hits`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (include !== undefined) {
        localVarQueryParameter['include'] = include;
      }

      if (fieldsPartRevision !== undefined) {
        localVarQueryParameter['fields[part-revision]'] = fieldsPartRevision;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createHitRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HitsApi - functional programming interface
 * @export
 */
export const HitsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HitsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a `hit` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateHitRequest} createHitRequest
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {string} [fieldsPartRevision] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneHit(
      id: string,
      createHitRequest: CreateHitRequest,
      include?: string,
      fieldsPartRevision?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hit>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createSceneHit(
        id,
        createHitRequest,
        include,
        fieldsPartRevision,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Create a `hit` for a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateHitRequest} createHitRequest
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {string} [fieldsPartRevision] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneViewHit(
      id: string,
      createHitRequest: CreateHitRequest,
      include?: string,
      fieldsPartRevision?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hit>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createSceneViewHit(
          id,
          createHitRequest,
          include,
          fieldsPartRevision,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * HitsApi - factory interface
 * @export
 */
export const HitsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = HitsApiFp(configuration);
  return {
    /**
     * Create a `hit` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateHitRequest} createHitRequest
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {string} [fieldsPartRevision] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneHit(
      id: string,
      createHitRequest: CreateHitRequest,
      include?: string,
      fieldsPartRevision?: string,
      options?: any
    ): AxiosPromise<Hit> {
      return localVarFp
        .createSceneHit(
          id,
          createHitRequest,
          include,
          fieldsPartRevision,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a `hit` for a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateHitRequest} createHitRequest
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {string} [fieldsPartRevision] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneViewHit(
      id: string,
      createHitRequest: CreateHitRequest,
      include?: string,
      fieldsPartRevision?: string,
      options?: any
    ): AxiosPromise<Hit> {
      return localVarFp
        .createSceneViewHit(
          id,
          createHitRequest,
          include,
          fieldsPartRevision,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createSceneHit operation in HitsApi.
 * @export
 * @interface HitsApiCreateSceneHitRequest
 */
export interface HitsApiCreateSceneHitRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof HitsApiCreateSceneHit
   */
  readonly id: string;

  /**
   *
   * @type {CreateHitRequest}
   * @memberof HitsApiCreateSceneHit
   */
  readonly createHitRequest: CreateHitRequest;

  /**
   * Comma-separated list of relationships to include in response.
   * @type {string}
   * @memberof HitsApiCreateSceneHit
   */
  readonly include?: string;

  /**
   * Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
   * @type {string}
   * @memberof HitsApiCreateSceneHit
   */
  readonly fieldsPartRevision?: string;
}

/**
 * Request parameters for createSceneViewHit operation in HitsApi.
 * @export
 * @interface HitsApiCreateSceneViewHitRequest
 */
export interface HitsApiCreateSceneViewHitRequest {
  /**
   * The &#x60;scene-view&#x60; ID.
   * @type {string}
   * @memberof HitsApiCreateSceneViewHit
   */
  readonly id: string;

  /**
   *
   * @type {CreateHitRequest}
   * @memberof HitsApiCreateSceneViewHit
   */
  readonly createHitRequest: CreateHitRequest;

  /**
   * Comma-separated list of relationships to include in response.
   * @type {string}
   * @memberof HitsApiCreateSceneViewHit
   */
  readonly include?: string;

  /**
   * Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
   * @type {string}
   * @memberof HitsApiCreateSceneViewHit
   */
  readonly fieldsPartRevision?: string;
}

/**
 * HitsApi - object-oriented interface
 * @export
 * @class HitsApi
 * @extends {BaseAPI}
 */
export class HitsApi extends BaseAPI {
  /**
   * Create a `hit` for a `scene`.
   * @param {HitsApiCreateSceneHitRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HitsApi
   */
  public createSceneHit(
    requestParameters: HitsApiCreateSceneHitRequest,
    options?: AxiosRequestConfig
  ) {
    return HitsApiFp(this.configuration)
      .createSceneHit(
        requestParameters.id,
        requestParameters.createHitRequest,
        requestParameters.include,
        requestParameters.fieldsPartRevision,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a `hit` for a `scene-view`.
   * @param {HitsApiCreateSceneViewHitRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HitsApi
   */
  public createSceneViewHit(
    requestParameters: HitsApiCreateSceneViewHitRequest,
    options?: AxiosRequestConfig
  ) {
    return HitsApiFp(this.configuration)
      .createSceneViewHit(
        requestParameters.id,
        requestParameters.createHitRequest,
        requestParameters.include,
        requestParameters.fieldsPartRevision,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ModelViewsApi - axios parameter creator
 * @export
 */
export const ModelViewsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Get the details of a `model-view`.
     * @param {string} id The &#x60;model-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getModelView: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getModelView', 'id', id);
      const localVarPath = `/model-views/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a paged list of `model-views` for a part revision.
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {boolean} [filterHasAnnotations] Filter model views that contain or do not contain annotations.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartRevisionModelViews: async (
      id: string,
      filterHasAnnotations?: boolean,
      pageCursor?: string,
      pageSize?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPartRevisionModelViews', 'id', id);
      const localVarPath = `/part-revisions/{id}/model-views`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (filterHasAnnotations !== undefined) {
        localVarQueryParameter['filter[hasAnnotations]'] = filterHasAnnotations;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a paged list of `model-views` for a scene item.
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {boolean} [filterHasAnnotations] Filter model views that contain or do not contain annotations.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneItemModelViews: async (
      id: string,
      filterHasAnnotations?: boolean,
      pageCursor?: string,
      pageSize?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getSceneItemModelViews', 'id', id);
      const localVarPath = `/scene-items/{id}/model-views`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (filterHasAnnotations !== undefined) {
        localVarQueryParameter['filter[hasAnnotations]'] = filterHasAnnotations;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ModelViewsApi - functional programming interface
 * @export
 */
export const ModelViewsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ModelViewsApiAxiosParamCreator(configuration);
  return {
    /**
     * Get the details of a `model-view`.
     * @param {string} id The &#x60;model-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getModelView(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelView>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getModelView(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a paged list of `model-views` for a part revision.
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {boolean} [filterHasAnnotations] Filter model views that contain or do not contain annotations.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPartRevisionModelViews(
      id: string,
      filterHasAnnotations?: boolean,
      pageCursor?: string,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelViewList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPartRevisionModelViews(
          id,
          filterHasAnnotations,
          pageCursor,
          pageSize,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a paged list of `model-views` for a scene item.
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {boolean} [filterHasAnnotations] Filter model views that contain or do not contain annotations.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneItemModelViews(
      id: string,
      filterHasAnnotations?: boolean,
      pageCursor?: string,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelViewList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSceneItemModelViews(
          id,
          filterHasAnnotations,
          pageCursor,
          pageSize,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ModelViewsApi - factory interface
 * @export
 */
export const ModelViewsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ModelViewsApiFp(configuration);
  return {
    /**
     * Get the details of a `model-view`.
     * @param {string} id The &#x60;model-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getModelView(id: string, options?: any): AxiosPromise<ModelView> {
      return localVarFp
        .getModelView(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a paged list of `model-views` for a part revision.
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {boolean} [filterHasAnnotations] Filter model views that contain or do not contain annotations.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartRevisionModelViews(
      id: string,
      filterHasAnnotations?: boolean,
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<ModelViewList> {
      return localVarFp
        .getPartRevisionModelViews(
          id,
          filterHasAnnotations,
          pageCursor,
          pageSize,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a paged list of `model-views` for a scene item.
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {boolean} [filterHasAnnotations] Filter model views that contain or do not contain annotations.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneItemModelViews(
      id: string,
      filterHasAnnotations?: boolean,
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<ModelViewList> {
      return localVarFp
        .getSceneItemModelViews(
          id,
          filterHasAnnotations,
          pageCursor,
          pageSize,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for getModelView operation in ModelViewsApi.
 * @export
 * @interface ModelViewsApiGetModelViewRequest
 */
export interface ModelViewsApiGetModelViewRequest {
  /**
   * The &#x60;model-view&#x60; ID.
   * @type {string}
   * @memberof ModelViewsApiGetModelView
   */
  readonly id: string;
}

/**
 * Request parameters for getPartRevisionModelViews operation in ModelViewsApi.
 * @export
 * @interface ModelViewsApiGetPartRevisionModelViewsRequest
 */
export interface ModelViewsApiGetPartRevisionModelViewsRequest {
  /**
   * The &#x60;part-revision&#x60; ID.
   * @type {string}
   * @memberof ModelViewsApiGetPartRevisionModelViews
   */
  readonly id: string;

  /**
   * Filter model views that contain or do not contain annotations.
   * @type {boolean}
   * @memberof ModelViewsApiGetPartRevisionModelViews
   */
  readonly filterHasAnnotations?: boolean;

  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof ModelViewsApiGetPartRevisionModelViews
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof ModelViewsApiGetPartRevisionModelViews
   */
  readonly pageSize?: number;
}

/**
 * Request parameters for getSceneItemModelViews operation in ModelViewsApi.
 * @export
 * @interface ModelViewsApiGetSceneItemModelViewsRequest
 */
export interface ModelViewsApiGetSceneItemModelViewsRequest {
  /**
   * The &#x60;scene-item&#x60; ID.
   * @type {string}
   * @memberof ModelViewsApiGetSceneItemModelViews
   */
  readonly id: string;

  /**
   * Filter model views that contain or do not contain annotations.
   * @type {boolean}
   * @memberof ModelViewsApiGetSceneItemModelViews
   */
  readonly filterHasAnnotations?: boolean;

  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof ModelViewsApiGetSceneItemModelViews
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof ModelViewsApiGetSceneItemModelViews
   */
  readonly pageSize?: number;
}

/**
 * ModelViewsApi - object-oriented interface
 * @export
 * @class ModelViewsApi
 * @extends {BaseAPI}
 */
export class ModelViewsApi extends BaseAPI {
  /**
   * Get the details of a `model-view`.
   * @param {ModelViewsApiGetModelViewRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModelViewsApi
   */
  public getModelView(
    requestParameters: ModelViewsApiGetModelViewRequest,
    options?: AxiosRequestConfig
  ) {
    return ModelViewsApiFp(this.configuration)
      .getModelView(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a paged list of `model-views` for a part revision.
   * @param {ModelViewsApiGetPartRevisionModelViewsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModelViewsApi
   */
  public getPartRevisionModelViews(
    requestParameters: ModelViewsApiGetPartRevisionModelViewsRequest,
    options?: AxiosRequestConfig
  ) {
    return ModelViewsApiFp(this.configuration)
      .getPartRevisionModelViews(
        requestParameters.id,
        requestParameters.filterHasAnnotations,
        requestParameters.pageCursor,
        requestParameters.pageSize,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a paged list of `model-views` for a scene item.
   * @param {ModelViewsApiGetSceneItemModelViewsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModelViewsApi
   */
  public getSceneItemModelViews(
    requestParameters: ModelViewsApiGetSceneItemModelViewsRequest,
    options?: AxiosRequestConfig
  ) {
    return ModelViewsApiFp(this.configuration)
      .getSceneItemModelViews(
        requestParameters.id,
        requestParameters.filterHasAnnotations,
        requestParameters.pageCursor,
        requestParameters.pageSize,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * Oauth2Api - axios parameter creator
 * @export
 */
export const Oauth2ApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Accept Consent Challenge to login.
     * @param {string} challenge Challenge ID from oauth2 flow
     * @param {AdminConsentAcceptRequest} [adminConsentAcceptRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminAcceptConsent: async (
      challenge: string,
      adminConsentAcceptRequest?: AdminConsentAcceptRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'challenge' is not null or undefined
      assertParamExists('adminAcceptConsent', 'challenge', challenge);
      const localVarPath = `/oauth2/auth/requests/consent/accept`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2Internal required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2Internal',
        [],
        configuration
      );

      if (challenge !== undefined) {
        localVarQueryParameter['challenge'] = challenge;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        adminConsentAcceptRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Accept Login Challenge with subject & login challenge
     * @param {string} loginChallenge Login Challenge ID from oauth2 flow
     * @param {AdminLoginAcceptRequest} adminLoginAcceptRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminAcceptLogin: async (
      loginChallenge: string,
      adminLoginAcceptRequest: AdminLoginAcceptRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginChallenge' is not null or undefined
      assertParamExists('adminAcceptLogin', 'loginChallenge', loginChallenge);
      // verify required parameter 'adminLoginAcceptRequest' is not null or undefined
      assertParamExists(
        'adminAcceptLogin',
        'adminLoginAcceptRequest',
        adminLoginAcceptRequest
      );
      const localVarPath = `/oauth2/auth/requests/login/accept`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2Internal required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2Internal',
        [],
        configuration
      );

      if (loginChallenge !== undefined) {
        localVarQueryParameter['login_challenge'] = loginChallenge;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        adminLoginAcceptRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create an OAuth2 access token. For details, see our [Authentication](https://developer.vertexvis.com/docs/guides/authentication) guide.
     * @param {string} grantType
     * @param {string} [scope]
     * @param {string} [code]
     * @param {string} [redirectUri]
     * @param {string} [subjectTokenType]
     * @param {string} [refreshToken]
     * @param {string} [subjectToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken: async (
      grantType: string,
      scope?: string,
      code?: string,
      redirectUri?: string,
      subjectTokenType?: string,
      refreshToken?: string,
      subjectToken?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'grantType' is not null or undefined
      assertParamExists('createToken', 'grantType', grantType);
      const localVarPath = `/oauth2/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (scope !== undefined) {
        localVarFormParams.set('scope', scope as any);
      }

      if (code !== undefined) {
        localVarFormParams.set('code', code as any);
      }

      if (redirectUri !== undefined) {
        localVarFormParams.set('redirect_uri', redirectUri as any);
      }

      if (grantType !== undefined) {
        localVarFormParams.set('grant_type', grantType as any);
      }

      if (subjectTokenType !== undefined) {
        localVarFormParams.set('subject_token_type', subjectTokenType as any);
      }

      if (refreshToken !== undefined) {
        localVarFormParams.set('refresh_token', refreshToken as any);
      }

      if (subjectToken !== undefined) {
        localVarFormParams.set('subject_token', subjectToken as any);
      }

      localVarHeaderParameter['Content-Type'] =
        'application/x-www-form-urlencoded';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Revoke an OAuth2 access token.
     * @param {RevokeOAuth2TokenRequest} revokeOAuth2TokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeToken: async (
      revokeOAuth2TokenRequest: RevokeOAuth2TokenRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'revokeOAuth2TokenRequest' is not null or undefined
      assertParamExists(
        'revokeToken',
        'revokeOAuth2TokenRequest',
        revokeOAuth2TokenRequest
      );
      const localVarPath = `/oauth2/revoke`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        revokeOAuth2TokenRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * Oauth2Api - functional programming interface
 * @export
 */
export const Oauth2ApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = Oauth2ApiAxiosParamCreator(configuration);
  return {
    /**
     * Accept Consent Challenge to login.
     * @param {string} challenge Challenge ID from oauth2 flow
     * @param {AdminConsentAcceptRequest} [adminConsentAcceptRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminAcceptConsent(
      challenge: string,
      adminConsentAcceptRequest?: AdminConsentAcceptRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AdminRedirectTo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminAcceptConsent(
          challenge,
          adminConsentAcceptRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Accept Login Challenge with subject & login challenge
     * @param {string} loginChallenge Login Challenge ID from oauth2 flow
     * @param {AdminLoginAcceptRequest} adminLoginAcceptRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminAcceptLogin(
      loginChallenge: string,
      adminLoginAcceptRequest: AdminLoginAcceptRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AdminRedirectTo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminAcceptLogin(
          loginChallenge,
          adminLoginAcceptRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Create an OAuth2 access token. For details, see our [Authentication](https://developer.vertexvis.com/docs/guides/authentication) guide.
     * @param {string} grantType
     * @param {string} [scope]
     * @param {string} [code]
     * @param {string} [redirectUri]
     * @param {string} [subjectTokenType]
     * @param {string} [refreshToken]
     * @param {string} [subjectToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createToken(
      grantType: string,
      scope?: string,
      code?: string,
      redirectUri?: string,
      subjectTokenType?: string,
      refreshToken?: string,
      subjectToken?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2Token>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createToken(
        grantType,
        scope,
        code,
        redirectUri,
        subjectTokenType,
        refreshToken,
        subjectToken,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Revoke an OAuth2 access token.
     * @param {RevokeOAuth2TokenRequest} revokeOAuth2TokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async revokeToken(
      revokeOAuth2TokenRequest: RevokeOAuth2TokenRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.revokeToken(
        revokeOAuth2TokenRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * Oauth2Api - factory interface
 * @export
 */
export const Oauth2ApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = Oauth2ApiFp(configuration);
  return {
    /**
     * Accept Consent Challenge to login.
     * @param {string} challenge Challenge ID from oauth2 flow
     * @param {AdminConsentAcceptRequest} [adminConsentAcceptRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminAcceptConsent(
      challenge: string,
      adminConsentAcceptRequest?: AdminConsentAcceptRequest,
      options?: any
    ): AxiosPromise<AdminRedirectTo> {
      return localVarFp
        .adminAcceptConsent(challenge, adminConsentAcceptRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Accept Login Challenge with subject & login challenge
     * @param {string} loginChallenge Login Challenge ID from oauth2 flow
     * @param {AdminLoginAcceptRequest} adminLoginAcceptRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminAcceptLogin(
      loginChallenge: string,
      adminLoginAcceptRequest: AdminLoginAcceptRequest,
      options?: any
    ): AxiosPromise<AdminRedirectTo> {
      return localVarFp
        .adminAcceptLogin(loginChallenge, adminLoginAcceptRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create an OAuth2 access token. For details, see our [Authentication](https://developer.vertexvis.com/docs/guides/authentication) guide.
     * @param {string} grantType
     * @param {string} [scope]
     * @param {string} [code]
     * @param {string} [redirectUri]
     * @param {string} [subjectTokenType]
     * @param {string} [refreshToken]
     * @param {string} [subjectToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken(
      grantType: string,
      scope?: string,
      code?: string,
      redirectUri?: string,
      subjectTokenType?: string,
      refreshToken?: string,
      subjectToken?: string,
      options?: any
    ): AxiosPromise<OAuth2Token> {
      return localVarFp
        .createToken(
          grantType,
          scope,
          code,
          redirectUri,
          subjectTokenType,
          refreshToken,
          subjectToken,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Revoke an OAuth2 access token.
     * @param {RevokeOAuth2TokenRequest} revokeOAuth2TokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeToken(
      revokeOAuth2TokenRequest: RevokeOAuth2TokenRequest,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .revokeToken(revokeOAuth2TokenRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for adminAcceptConsent operation in Oauth2Api.
 * @export
 * @interface Oauth2ApiAdminAcceptConsentRequest
 */
export interface Oauth2ApiAdminAcceptConsentRequest {
  /**
   * Challenge ID from oauth2 flow
   * @type {string}
   * @memberof Oauth2ApiAdminAcceptConsent
   */
  readonly challenge: string;

  /**
   *
   * @type {AdminConsentAcceptRequest}
   * @memberof Oauth2ApiAdminAcceptConsent
   */
  readonly adminConsentAcceptRequest?: AdminConsentAcceptRequest;
}

/**
 * Request parameters for adminAcceptLogin operation in Oauth2Api.
 * @export
 * @interface Oauth2ApiAdminAcceptLoginRequest
 */
export interface Oauth2ApiAdminAcceptLoginRequest {
  /**
   * Login Challenge ID from oauth2 flow
   * @type {string}
   * @memberof Oauth2ApiAdminAcceptLogin
   */
  readonly loginChallenge: string;

  /**
   *
   * @type {AdminLoginAcceptRequest}
   * @memberof Oauth2ApiAdminAcceptLogin
   */
  readonly adminLoginAcceptRequest: AdminLoginAcceptRequest;
}

/**
 * Request parameters for createToken operation in Oauth2Api.
 * @export
 * @interface Oauth2ApiCreateTokenRequest
 */
export interface Oauth2ApiCreateTokenRequest {
  /**
   *
   * @type {string}
   * @memberof Oauth2ApiCreateToken
   */
  readonly grantType: string;

  /**
   *
   * @type {string}
   * @memberof Oauth2ApiCreateToken
   */
  readonly scope?: string;

  /**
   *
   * @type {string}
   * @memberof Oauth2ApiCreateToken
   */
  readonly code?: string;

  /**
   *
   * @type {string}
   * @memberof Oauth2ApiCreateToken
   */
  readonly redirectUri?: string;

  /**
   *
   * @type {string}
   * @memberof Oauth2ApiCreateToken
   */
  readonly subjectTokenType?: string;

  /**
   *
   * @type {string}
   * @memberof Oauth2ApiCreateToken
   */
  readonly refreshToken?: string;

  /**
   *
   * @type {string}
   * @memberof Oauth2ApiCreateToken
   */
  readonly subjectToken?: string;
}

/**
 * Request parameters for revokeToken operation in Oauth2Api.
 * @export
 * @interface Oauth2ApiRevokeTokenRequest
 */
export interface Oauth2ApiRevokeTokenRequest {
  /**
   *
   * @type {RevokeOAuth2TokenRequest}
   * @memberof Oauth2ApiRevokeToken
   */
  readonly revokeOAuth2TokenRequest: RevokeOAuth2TokenRequest;
}

/**
 * Oauth2Api - object-oriented interface
 * @export
 * @class Oauth2Api
 * @extends {BaseAPI}
 */
export class Oauth2Api extends BaseAPI {
  /**
   * Accept Consent Challenge to login.
   * @param {Oauth2ApiAdminAcceptConsentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Oauth2Api
   */
  public adminAcceptConsent(
    requestParameters: Oauth2ApiAdminAcceptConsentRequest,
    options?: AxiosRequestConfig
  ) {
    return Oauth2ApiFp(this.configuration)
      .adminAcceptConsent(
        requestParameters.challenge,
        requestParameters.adminConsentAcceptRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Accept Login Challenge with subject & login challenge
   * @param {Oauth2ApiAdminAcceptLoginRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Oauth2Api
   */
  public adminAcceptLogin(
    requestParameters: Oauth2ApiAdminAcceptLoginRequest,
    options?: AxiosRequestConfig
  ) {
    return Oauth2ApiFp(this.configuration)
      .adminAcceptLogin(
        requestParameters.loginChallenge,
        requestParameters.adminLoginAcceptRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create an OAuth2 access token. For details, see our [Authentication](https://developer.vertexvis.com/docs/guides/authentication) guide.
   * @param {Oauth2ApiCreateTokenRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Oauth2Api
   */
  public createToken(
    requestParameters: Oauth2ApiCreateTokenRequest,
    options?: AxiosRequestConfig
  ) {
    return Oauth2ApiFp(this.configuration)
      .createToken(
        requestParameters.grantType,
        requestParameters.scope,
        requestParameters.code,
        requestParameters.redirectUri,
        requestParameters.subjectTokenType,
        requestParameters.refreshToken,
        requestParameters.subjectToken,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Revoke an OAuth2 access token.
   * @param {Oauth2ApiRevokeTokenRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Oauth2Api
   */
  public revokeToken(
    requestParameters: Oauth2ApiRevokeTokenRequest,
    options?: AxiosRequestConfig
  ) {
    return Oauth2ApiFp(this.configuration)
      .revokeToken(requestParameters.revokeOAuth2TokenRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PartRenditionsApi - axios parameter creator
 * @export
 */
export const PartRenditionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Creates a part-rendition associated with a part-revision
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {CreatePartRenditionRequest} createPartRenditionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPartRendition: async (
      id: string,
      createPartRenditionRequest: CreatePartRenditionRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createPartRendition', 'id', id);
      // verify required parameter 'createPartRenditionRequest' is not null or undefined
      assertParamExists(
        'createPartRendition',
        'createPartRenditionRequest',
        createPartRenditionRequest
      );
      const localVarPath = `/part-revisions/{id}/part-renditions`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPartRenditionRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `part-rendition` by ID.
     * @param {string} id The &#x60;part-rendition&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartRendition: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPartRendition', 'id', id);
      const localVarPath = `/part-renditions/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get `part-renditions` with an optional filter.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {string} [filterRevisionId] A revision ID to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartRenditions: async (
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      filterRevisionId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/part-renditions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (filterSuppliedId !== undefined) {
        localVarQueryParameter['filter[suppliedId]'] = filterSuppliedId;
      }

      if (filterRevisionId !== undefined) {
        localVarQueryParameter['filter[revisionId]'] = filterRevisionId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PartRenditionsApi - functional programming interface
 * @export
 */
export const PartRenditionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PartRenditionsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a part-rendition associated with a part-revision
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {CreatePartRenditionRequest} createPartRenditionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPartRendition(
      id: string,
      createPartRenditionRequest: CreatePartRenditionRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartRendition>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createPartRendition(
          id,
          createPartRenditionRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `part-rendition` by ID.
     * @param {string} id The &#x60;part-rendition&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPartRendition(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartRendition>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPartRendition(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get `part-renditions` with an optional filter.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {string} [filterRevisionId] A revision ID to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPartRenditions(
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      filterRevisionId?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PartRenditionList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPartRenditions(
          pageCursor,
          pageSize,
          filterSuppliedId,
          filterRevisionId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PartRenditionsApi - factory interface
 * @export
 */
export const PartRenditionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PartRenditionsApiFp(configuration);
  return {
    /**
     * Creates a part-rendition associated with a part-revision
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {CreatePartRenditionRequest} createPartRenditionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPartRendition(
      id: string,
      createPartRenditionRequest: CreatePartRenditionRequest,
      options?: any
    ): AxiosPromise<PartRendition> {
      return localVarFp
        .createPartRendition(id, createPartRenditionRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `part-rendition` by ID.
     * @param {string} id The &#x60;part-rendition&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartRendition(id: string, options?: any): AxiosPromise<PartRendition> {
      return localVarFp
        .getPartRendition(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get `part-renditions` with an optional filter.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {string} [filterRevisionId] A revision ID to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartRenditions(
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      filterRevisionId?: string,
      options?: any
    ): AxiosPromise<PartRenditionList> {
      return localVarFp
        .getPartRenditions(
          pageCursor,
          pageSize,
          filterSuppliedId,
          filterRevisionId,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createPartRendition operation in PartRenditionsApi.
 * @export
 * @interface PartRenditionsApiCreatePartRenditionRequest
 */
export interface PartRenditionsApiCreatePartRenditionRequest {
  /**
   * The &#x60;part-revision&#x60; ID.
   * @type {string}
   * @memberof PartRenditionsApiCreatePartRendition
   */
  readonly id: string;

  /**
   *
   * @type {CreatePartRenditionRequest}
   * @memberof PartRenditionsApiCreatePartRendition
   */
  readonly createPartRenditionRequest: CreatePartRenditionRequest;
}

/**
 * Request parameters for getPartRendition operation in PartRenditionsApi.
 * @export
 * @interface PartRenditionsApiGetPartRenditionRequest
 */
export interface PartRenditionsApiGetPartRenditionRequest {
  /**
   * The &#x60;part-rendition&#x60; ID.
   * @type {string}
   * @memberof PartRenditionsApiGetPartRendition
   */
  readonly id: string;
}

/**
 * Request parameters for getPartRenditions operation in PartRenditionsApi.
 * @export
 * @interface PartRenditionsApiGetPartRenditionsRequest
 */
export interface PartRenditionsApiGetPartRenditionsRequest {
  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof PartRenditionsApiGetPartRenditions
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof PartRenditionsApiGetPartRenditions
   */
  readonly pageSize?: number;

  /**
   * Comma-separated list of supplied IDs to filter on.
   * @type {string}
   * @memberof PartRenditionsApiGetPartRenditions
   */
  readonly filterSuppliedId?: string;

  /**
   * A revision ID to filter on.
   * @type {string}
   * @memberof PartRenditionsApiGetPartRenditions
   */
  readonly filterRevisionId?: string;
}

/**
 * PartRenditionsApi - object-oriented interface
 * @export
 * @class PartRenditionsApi
 * @extends {BaseAPI}
 */
export class PartRenditionsApi extends BaseAPI {
  /**
   * Creates a part-rendition associated with a part-revision
   * @param {PartRenditionsApiCreatePartRenditionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartRenditionsApi
   */
  public createPartRendition(
    requestParameters: PartRenditionsApiCreatePartRenditionRequest,
    options?: AxiosRequestConfig
  ) {
    return PartRenditionsApiFp(this.configuration)
      .createPartRendition(
        requestParameters.id,
        requestParameters.createPartRenditionRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `part-rendition` by ID.
   * @param {PartRenditionsApiGetPartRenditionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartRenditionsApi
   */
  public getPartRendition(
    requestParameters: PartRenditionsApiGetPartRenditionRequest,
    options?: AxiosRequestConfig
  ) {
    return PartRenditionsApiFp(this.configuration)
      .getPartRendition(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get `part-renditions` with an optional filter.
   * @param {PartRenditionsApiGetPartRenditionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartRenditionsApi
   */
  public getPartRenditions(
    requestParameters: PartRenditionsApiGetPartRenditionsRequest = {},
    options?: AxiosRequestConfig
  ) {
    return PartRenditionsApiFp(this.configuration)
      .getPartRenditions(
        requestParameters.pageCursor,
        requestParameters.pageSize,
        requestParameters.filterSuppliedId,
        requestParameters.filterRevisionId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PartRevisionInstancesApi - axios parameter creator
 * @export
 */
export const PartRevisionInstancesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Gets a page of \'part-revision\' instances. An instance is an occurrence of a revision that is a child of a parent revision. The returned data will have the ordinal used for ordering and the transform matrix for each occurrence.
     * @param {string} [filterParent] Parent ID to filter on. Sending null will return items without a parent.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartRevisionInstanceList: async (
      filterParent?: string,
      pageCursor?: string,
      pageSize?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/part-revision-instances`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (filterParent !== undefined) {
        localVarQueryParameter['filter[parent]'] = filterParent;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PartRevisionInstancesApi - functional programming interface
 * @export
 */
export const PartRevisionInstancesApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    PartRevisionInstancesApiAxiosParamCreator(configuration);
  return {
    /**
     * Gets a page of \'part-revision\' instances. An instance is an occurrence of a revision that is a child of a parent revision. The returned data will have the ordinal used for ordering and the transform matrix for each occurrence.
     * @param {string} [filterParent] Parent ID to filter on. Sending null will return items without a parent.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPartRevisionInstanceList(
      filterParent?: string,
      pageCursor?: string,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PartRevisionInstanceList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPartRevisionInstanceList(
          filterParent,
          pageCursor,
          pageSize,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PartRevisionInstancesApi - factory interface
 * @export
 */
export const PartRevisionInstancesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PartRevisionInstancesApiFp(configuration);
  return {
    /**
     * Gets a page of \'part-revision\' instances. An instance is an occurrence of a revision that is a child of a parent revision. The returned data will have the ordinal used for ordering and the transform matrix for each occurrence.
     * @param {string} [filterParent] Parent ID to filter on. Sending null will return items without a parent.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartRevisionInstanceList(
      filterParent?: string,
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<PartRevisionInstanceList> {
      return localVarFp
        .getPartRevisionInstanceList(
          filterParent,
          pageCursor,
          pageSize,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for getPartRevisionInstanceList operation in PartRevisionInstancesApi.
 * @export
 * @interface PartRevisionInstancesApiGetPartRevisionInstanceListRequest
 */
export interface PartRevisionInstancesApiGetPartRevisionInstanceListRequest {
  /**
   * Parent ID to filter on. Sending null will return items without a parent.
   * @type {string}
   * @memberof PartRevisionInstancesApiGetPartRevisionInstanceList
   */
  readonly filterParent?: string;

  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof PartRevisionInstancesApiGetPartRevisionInstanceList
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof PartRevisionInstancesApiGetPartRevisionInstanceList
   */
  readonly pageSize?: number;
}

/**
 * PartRevisionInstancesApi - object-oriented interface
 * @export
 * @class PartRevisionInstancesApi
 * @extends {BaseAPI}
 */
export class PartRevisionInstancesApi extends BaseAPI {
  /**
   * Gets a page of \'part-revision\' instances. An instance is an occurrence of a revision that is a child of a parent revision. The returned data will have the ordinal used for ordering and the transform matrix for each occurrence.
   * @param {PartRevisionInstancesApiGetPartRevisionInstanceListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartRevisionInstancesApi
   */
  public getPartRevisionInstanceList(
    requestParameters: PartRevisionInstancesApiGetPartRevisionInstanceListRequest = {},
    options?: AxiosRequestConfig
  ) {
    return PartRevisionInstancesApiFp(this.configuration)
      .getPartRevisionInstanceList(
        requestParameters.filterParent,
        requestParameters.pageCursor,
        requestParameters.pageSize,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PartRevisionsApi - axios parameter creator
 * @export
 */
export const PartRevisionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Delete a `part-revision`.
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePartRevision: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deletePartRevision', 'id', id);
      const localVarPath = `/part-revisions/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `part-revision` by ID.
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {string} [fieldsPartRevision] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartRevision: async (
      id: string,
      fieldsPartRevision?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPartRevision', 'id', id);
      const localVarPath = `/part-revisions/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (fieldsPartRevision !== undefined) {
        localVarQueryParameter['fields[part-revision]'] = fieldsPartRevision;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get `part-revisions` for a `part`.
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartRevisions: async (
      id: string,
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPartRevisions', 'id', id);
      const localVarPath = `/parts/{id}/part-revisions`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (filterSuppliedId !== undefined) {
        localVarQueryParameter['filter[suppliedId]'] = filterSuppliedId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `queued-part-revision-deletion` by ID.
     * @param {string} id The &#x60;queued-part-revision-deletion&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedPartRevisionDeletion: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getQueuedPartRevisionDeletion', 'id', id);
      const localVarPath = `/queued-part-revision-deletions/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a rendered image of a `part-revision`.
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {number} [height] The height of the image to render.
     * @param {number} [width] The width of the image to render.
     * @param {Vector3} [cameraPosition] The &#x60;camera&#x60; position vector.
     * @param {Vector3} [cameraUp] The &#x60;camera&#x60; up vector.
     * @param {Vector3} [cameraLookAt] The &#x60;camera&#x60; lookAt vector.
     * @param {Vector3} [cameraPerspectivePosition] The perspective camera position.
     * @param {Vector3} [cameraPerspectiveLookAt] The perspective camera look at position.
     * @param {Vector3} [cameraPerspectiveUp] The perspective camera up vector.
     * @param {Vector3} [cameraOrthographicViewVector] The orthographic camera view vector.
     * @param {Vector3} [cameraOrthographicLookAt] The orthographic camera look at position.
     * @param {Vector3} [cameraOrthographicUp] The orthographic camera up vector.
     * @param {number} [cameraOrthographicFovHeight] The orthographic field-of-view height.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    renderPartRevision: async (
      id: string,
      height?: number,
      width?: number,
      cameraPosition?: Vector3,
      cameraUp?: Vector3,
      cameraLookAt?: Vector3,
      cameraPerspectivePosition?: Vector3,
      cameraPerspectiveLookAt?: Vector3,
      cameraPerspectiveUp?: Vector3,
      cameraOrthographicViewVector?: Vector3,
      cameraOrthographicLookAt?: Vector3,
      cameraOrthographicUp?: Vector3,
      cameraOrthographicFovHeight?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('renderPartRevision', 'id', id);
      const localVarPath = `/part-revisions/{id}/image`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (height !== undefined) {
        localVarQueryParameter['height'] = height;
      }

      if (width !== undefined) {
        localVarQueryParameter['width'] = width;
      }

      if (cameraPosition !== undefined) {
        localVarQueryParameter['camera[position]'] = cameraPosition;
      }

      if (cameraUp !== undefined) {
        localVarQueryParameter['camera[up]'] = cameraUp;
      }

      if (cameraLookAt !== undefined) {
        localVarQueryParameter['camera[lookAt]'] = cameraLookAt;
      }

      if (cameraPerspectivePosition !== undefined) {
        localVarQueryParameter['camera[perspective][position]'] =
          cameraPerspectivePosition;
      }

      if (cameraPerspectiveLookAt !== undefined) {
        localVarQueryParameter['camera[perspective][lookAt]'] =
          cameraPerspectiveLookAt;
      }

      if (cameraPerspectiveUp !== undefined) {
        localVarQueryParameter['camera[perspective][up]'] = cameraPerspectiveUp;
      }

      if (cameraOrthographicViewVector !== undefined) {
        localVarQueryParameter['camera[orthographic][viewVector]'] =
          cameraOrthographicViewVector;
      }

      if (cameraOrthographicLookAt !== undefined) {
        localVarQueryParameter['camera[orthographic][lookAt]'] =
          cameraOrthographicLookAt;
      }

      if (cameraOrthographicUp !== undefined) {
        localVarQueryParameter['camera[orthographic][up]'] =
          cameraOrthographicUp;
      }

      if (cameraOrthographicFovHeight !== undefined) {
        localVarQueryParameter['camera[orthographic][fovHeight]'] =
          cameraOrthographicFovHeight;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a `part-revision`. When given a `file` relationship as a payload, this will invoke a translation job, similar to the POST /parts endpoint. The response code will be a 202 and will respond with an async workflow, and return an Accepted[QueuedJob]. The geometry of the part and all of its children will be replaced with the geometry specified within the translated file given from this relationship. Some of the properties given here are only used for the translation of the file. Namely, `indexMetadata`, `name`, `suppliedIdKey`, `suppliedRevisionIdKey`, and `suppliedInstanceIdKey`. Note that geometry updates are eventually consistent and will not update existing scenes. For updates to the revision when the file relationship is not present will respond with a standard 200 ok code when successful. Note that metadata updates are eventually consistent and will not update existing scenes. To view updated metadata within a scene, a new scene must be created or the updated part-revision must be removed and re-added to an existing scene.
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {UpdatePartRevisionRequest} updatePartRevisionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePartRevision: async (
      id: string,
      updatePartRevisionRequest: UpdatePartRevisionRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updatePartRevision', 'id', id);
      // verify required parameter 'updatePartRevisionRequest' is not null or undefined
      assertParamExists(
        'updatePartRevision',
        'updatePartRevisionRequest',
        updatePartRevisionRequest
      );
      const localVarPath = `/part-revisions/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePartRevisionRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PartRevisionsApi - functional programming interface
 * @export
 */
export const PartRevisionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PartRevisionsApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete a `part-revision`.
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePartRevision(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deletePartRevision(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `part-revision` by ID.
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {string} [fieldsPartRevision] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPartRevision(
      id: string,
      fieldsPartRevision?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartRevision>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPartRevision(
        id,
        fieldsPartRevision,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get `part-revisions` for a `part`.
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPartRevisions(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PartRevisionList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPartRevisions(
          id,
          pageCursor,
          pageSize,
          filterSuppliedId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `queued-part-revision-deletion` by ID.
     * @param {string} id The &#x60;queued-part-revision-deletion&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedPartRevisionDeletion(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getQueuedPartRevisionDeletion(
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a rendered image of a `part-revision`.
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {number} [height] The height of the image to render.
     * @param {number} [width] The width of the image to render.
     * @param {Vector3} [cameraPosition] The &#x60;camera&#x60; position vector.
     * @param {Vector3} [cameraUp] The &#x60;camera&#x60; up vector.
     * @param {Vector3} [cameraLookAt] The &#x60;camera&#x60; lookAt vector.
     * @param {Vector3} [cameraPerspectivePosition] The perspective camera position.
     * @param {Vector3} [cameraPerspectiveLookAt] The perspective camera look at position.
     * @param {Vector3} [cameraPerspectiveUp] The perspective camera up vector.
     * @param {Vector3} [cameraOrthographicViewVector] The orthographic camera view vector.
     * @param {Vector3} [cameraOrthographicLookAt] The orthographic camera look at position.
     * @param {Vector3} [cameraOrthographicUp] The orthographic camera up vector.
     * @param {number} [cameraOrthographicFovHeight] The orthographic field-of-view height.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async renderPartRevision(
      id: string,
      height?: number,
      width?: number,
      cameraPosition?: Vector3,
      cameraUp?: Vector3,
      cameraLookAt?: Vector3,
      cameraPerspectivePosition?: Vector3,
      cameraPerspectiveLookAt?: Vector3,
      cameraPerspectiveUp?: Vector3,
      cameraOrthographicViewVector?: Vector3,
      cameraOrthographicLookAt?: Vector3,
      cameraOrthographicUp?: Vector3,
      cameraOrthographicFovHeight?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.renderPartRevision(
          id,
          height,
          width,
          cameraPosition,
          cameraUp,
          cameraLookAt,
          cameraPerspectivePosition,
          cameraPerspectiveLookAt,
          cameraPerspectiveUp,
          cameraOrthographicViewVector,
          cameraOrthographicLookAt,
          cameraOrthographicUp,
          cameraOrthographicFovHeight,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update a `part-revision`. When given a `file` relationship as a payload, this will invoke a translation job, similar to the POST /parts endpoint. The response code will be a 202 and will respond with an async workflow, and return an Accepted[QueuedJob]. The geometry of the part and all of its children will be replaced with the geometry specified within the translated file given from this relationship. Some of the properties given here are only used for the translation of the file. Namely, `indexMetadata`, `name`, `suppliedIdKey`, `suppliedRevisionIdKey`, and `suppliedInstanceIdKey`. Note that geometry updates are eventually consistent and will not update existing scenes. For updates to the revision when the file relationship is not present will respond with a standard 200 ok code when successful. Note that metadata updates are eventually consistent and will not update existing scenes. To view updated metadata within a scene, a new scene must be created or the updated part-revision must be removed and re-added to an existing scene.
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {UpdatePartRevisionRequest} updatePartRevisionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePartRevision(
      id: string,
      updatePartRevisionRequest: UpdatePartRevisionRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartRevision>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updatePartRevision(
          id,
          updatePartRevisionRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PartRevisionsApi - factory interface
 * @export
 */
export const PartRevisionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PartRevisionsApiFp(configuration);
  return {
    /**
     * Delete a `part-revision`.
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePartRevision(id: string, options?: any): AxiosPromise<QueuedJob> {
      return localVarFp
        .deletePartRevision(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `part-revision` by ID.
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {string} [fieldsPartRevision] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartRevision(
      id: string,
      fieldsPartRevision?: string,
      options?: any
    ): AxiosPromise<PartRevision> {
      return localVarFp
        .getPartRevision(id, fieldsPartRevision, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get `part-revisions` for a `part`.
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartRevisions(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      options?: any
    ): AxiosPromise<PartRevisionList> {
      return localVarFp
        .getPartRevisions(id, pageCursor, pageSize, filterSuppliedId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `queued-part-revision-deletion` by ID.
     * @param {string} id The &#x60;queued-part-revision-deletion&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedPartRevisionDeletion(
      id: string,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return localVarFp
        .getQueuedPartRevisionDeletion(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a rendered image of a `part-revision`.
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {number} [height] The height of the image to render.
     * @param {number} [width] The width of the image to render.
     * @param {Vector3} [cameraPosition] The &#x60;camera&#x60; position vector.
     * @param {Vector3} [cameraUp] The &#x60;camera&#x60; up vector.
     * @param {Vector3} [cameraLookAt] The &#x60;camera&#x60; lookAt vector.
     * @param {Vector3} [cameraPerspectivePosition] The perspective camera position.
     * @param {Vector3} [cameraPerspectiveLookAt] The perspective camera look at position.
     * @param {Vector3} [cameraPerspectiveUp] The perspective camera up vector.
     * @param {Vector3} [cameraOrthographicViewVector] The orthographic camera view vector.
     * @param {Vector3} [cameraOrthographicLookAt] The orthographic camera look at position.
     * @param {Vector3} [cameraOrthographicUp] The orthographic camera up vector.
     * @param {number} [cameraOrthographicFovHeight] The orthographic field-of-view height.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    renderPartRevision(
      id: string,
      height?: number,
      width?: number,
      cameraPosition?: Vector3,
      cameraUp?: Vector3,
      cameraLookAt?: Vector3,
      cameraPerspectivePosition?: Vector3,
      cameraPerspectiveLookAt?: Vector3,
      cameraPerspectiveUp?: Vector3,
      cameraOrthographicViewVector?: Vector3,
      cameraOrthographicLookAt?: Vector3,
      cameraOrthographicUp?: Vector3,
      cameraOrthographicFovHeight?: number,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .renderPartRevision(
          id,
          height,
          width,
          cameraPosition,
          cameraUp,
          cameraLookAt,
          cameraPerspectivePosition,
          cameraPerspectiveLookAt,
          cameraPerspectiveUp,
          cameraOrthographicViewVector,
          cameraOrthographicLookAt,
          cameraOrthographicUp,
          cameraOrthographicFovHeight,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Update a `part-revision`. When given a `file` relationship as a payload, this will invoke a translation job, similar to the POST /parts endpoint. The response code will be a 202 and will respond with an async workflow, and return an Accepted[QueuedJob]. The geometry of the part and all of its children will be replaced with the geometry specified within the translated file given from this relationship. Some of the properties given here are only used for the translation of the file. Namely, `indexMetadata`, `name`, `suppliedIdKey`, `suppliedRevisionIdKey`, and `suppliedInstanceIdKey`. Note that geometry updates are eventually consistent and will not update existing scenes. For updates to the revision when the file relationship is not present will respond with a standard 200 ok code when successful. Note that metadata updates are eventually consistent and will not update existing scenes. To view updated metadata within a scene, a new scene must be created or the updated part-revision must be removed and re-added to an existing scene.
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {UpdatePartRevisionRequest} updatePartRevisionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePartRevision(
      id: string,
      updatePartRevisionRequest: UpdatePartRevisionRequest,
      options?: any
    ): AxiosPromise<PartRevision> {
      return localVarFp
        .updatePartRevision(id, updatePartRevisionRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for deletePartRevision operation in PartRevisionsApi.
 * @export
 * @interface PartRevisionsApiDeletePartRevisionRequest
 */
export interface PartRevisionsApiDeletePartRevisionRequest {
  /**
   * The &#x60;part-revision&#x60; ID.
   * @type {string}
   * @memberof PartRevisionsApiDeletePartRevision
   */
  readonly id: string;
}

/**
 * Request parameters for getPartRevision operation in PartRevisionsApi.
 * @export
 * @interface PartRevisionsApiGetPartRevisionRequest
 */
export interface PartRevisionsApiGetPartRevisionRequest {
  /**
   * The &#x60;part-revision&#x60; ID.
   * @type {string}
   * @memberof PartRevisionsApiGetPartRevision
   */
  readonly id: string;

  /**
   * Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
   * @type {string}
   * @memberof PartRevisionsApiGetPartRevision
   */
  readonly fieldsPartRevision?: string;
}

/**
 * Request parameters for getPartRevisions operation in PartRevisionsApi.
 * @export
 * @interface PartRevisionsApiGetPartRevisionsRequest
 */
export interface PartRevisionsApiGetPartRevisionsRequest {
  /**
   * The &#x60;part&#x60; ID.
   * @type {string}
   * @memberof PartRevisionsApiGetPartRevisions
   */
  readonly id: string;

  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof PartRevisionsApiGetPartRevisions
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof PartRevisionsApiGetPartRevisions
   */
  readonly pageSize?: number;

  /**
   * Comma-separated list of supplied IDs to filter on.
   * @type {string}
   * @memberof PartRevisionsApiGetPartRevisions
   */
  readonly filterSuppliedId?: string;
}

/**
 * Request parameters for getQueuedPartRevisionDeletion operation in PartRevisionsApi.
 * @export
 * @interface PartRevisionsApiGetQueuedPartRevisionDeletionRequest
 */
export interface PartRevisionsApiGetQueuedPartRevisionDeletionRequest {
  /**
   * The &#x60;queued-part-revision-deletion&#x60; ID.
   * @type {string}
   * @memberof PartRevisionsApiGetQueuedPartRevisionDeletion
   */
  readonly id: string;
}

/**
 * Request parameters for renderPartRevision operation in PartRevisionsApi.
 * @export
 * @interface PartRevisionsApiRenderPartRevisionRequest
 */
export interface PartRevisionsApiRenderPartRevisionRequest {
  /**
   * The &#x60;part-revision&#x60; ID.
   * @type {string}
   * @memberof PartRevisionsApiRenderPartRevision
   */
  readonly id: string;

  /**
   * The height of the image to render.
   * @type {number}
   * @memberof PartRevisionsApiRenderPartRevision
   */
  readonly height?: number;

  /**
   * The width of the image to render.
   * @type {number}
   * @memberof PartRevisionsApiRenderPartRevision
   */
  readonly width?: number;

  /**
   * The &#x60;camera&#x60; position vector.
   * @type {Vector3}
   * @memberof PartRevisionsApiRenderPartRevision
   */
  readonly cameraPosition?: Vector3;

  /**
   * The &#x60;camera&#x60; up vector.
   * @type {Vector3}
   * @memberof PartRevisionsApiRenderPartRevision
   */
  readonly cameraUp?: Vector3;

  /**
   * The &#x60;camera&#x60; lookAt vector.
   * @type {Vector3}
   * @memberof PartRevisionsApiRenderPartRevision
   */
  readonly cameraLookAt?: Vector3;

  /**
   * The perspective camera position.
   * @type {Vector3}
   * @memberof PartRevisionsApiRenderPartRevision
   */
  readonly cameraPerspectivePosition?: Vector3;

  /**
   * The perspective camera look at position.
   * @type {Vector3}
   * @memberof PartRevisionsApiRenderPartRevision
   */
  readonly cameraPerspectiveLookAt?: Vector3;

  /**
   * The perspective camera up vector.
   * @type {Vector3}
   * @memberof PartRevisionsApiRenderPartRevision
   */
  readonly cameraPerspectiveUp?: Vector3;

  /**
   * The orthographic camera view vector.
   * @type {Vector3}
   * @memberof PartRevisionsApiRenderPartRevision
   */
  readonly cameraOrthographicViewVector?: Vector3;

  /**
   * The orthographic camera look at position.
   * @type {Vector3}
   * @memberof PartRevisionsApiRenderPartRevision
   */
  readonly cameraOrthographicLookAt?: Vector3;

  /**
   * The orthographic camera up vector.
   * @type {Vector3}
   * @memberof PartRevisionsApiRenderPartRevision
   */
  readonly cameraOrthographicUp?: Vector3;

  /**
   * The orthographic field-of-view height.
   * @type {number}
   * @memberof PartRevisionsApiRenderPartRevision
   */
  readonly cameraOrthographicFovHeight?: number;
}

/**
 * Request parameters for updatePartRevision operation in PartRevisionsApi.
 * @export
 * @interface PartRevisionsApiUpdatePartRevisionRequest
 */
export interface PartRevisionsApiUpdatePartRevisionRequest {
  /**
   * The &#x60;part-revision&#x60; ID.
   * @type {string}
   * @memberof PartRevisionsApiUpdatePartRevision
   */
  readonly id: string;

  /**
   *
   * @type {UpdatePartRevisionRequest}
   * @memberof PartRevisionsApiUpdatePartRevision
   */
  readonly updatePartRevisionRequest: UpdatePartRevisionRequest;
}

/**
 * PartRevisionsApi - object-oriented interface
 * @export
 * @class PartRevisionsApi
 * @extends {BaseAPI}
 */
export class PartRevisionsApi extends BaseAPI {
  /**
   * Delete a `part-revision`.
   * @param {PartRevisionsApiDeletePartRevisionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartRevisionsApi
   */
  public deletePartRevision(
    requestParameters: PartRevisionsApiDeletePartRevisionRequest,
    options?: AxiosRequestConfig
  ) {
    return PartRevisionsApiFp(this.configuration)
      .deletePartRevision(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `part-revision` by ID.
   * @param {PartRevisionsApiGetPartRevisionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartRevisionsApi
   */
  public getPartRevision(
    requestParameters: PartRevisionsApiGetPartRevisionRequest,
    options?: AxiosRequestConfig
  ) {
    return PartRevisionsApiFp(this.configuration)
      .getPartRevision(
        requestParameters.id,
        requestParameters.fieldsPartRevision,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get `part-revisions` for a `part`.
   * @param {PartRevisionsApiGetPartRevisionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartRevisionsApi
   */
  public getPartRevisions(
    requestParameters: PartRevisionsApiGetPartRevisionsRequest,
    options?: AxiosRequestConfig
  ) {
    return PartRevisionsApiFp(this.configuration)
      .getPartRevisions(
        requestParameters.id,
        requestParameters.pageCursor,
        requestParameters.pageSize,
        requestParameters.filterSuppliedId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `queued-part-revision-deletion` by ID.
   * @param {PartRevisionsApiGetQueuedPartRevisionDeletionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartRevisionsApi
   */
  public getQueuedPartRevisionDeletion(
    requestParameters: PartRevisionsApiGetQueuedPartRevisionDeletionRequest,
    options?: AxiosRequestConfig
  ) {
    return PartRevisionsApiFp(this.configuration)
      .getQueuedPartRevisionDeletion(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a rendered image of a `part-revision`.
   * @param {PartRevisionsApiRenderPartRevisionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartRevisionsApi
   */
  public renderPartRevision(
    requestParameters: PartRevisionsApiRenderPartRevisionRequest,
    options?: AxiosRequestConfig
  ) {
    return PartRevisionsApiFp(this.configuration)
      .renderPartRevision(
        requestParameters.id,
        requestParameters.height,
        requestParameters.width,
        requestParameters.cameraPosition,
        requestParameters.cameraUp,
        requestParameters.cameraLookAt,
        requestParameters.cameraPerspectivePosition,
        requestParameters.cameraPerspectiveLookAt,
        requestParameters.cameraPerspectiveUp,
        requestParameters.cameraOrthographicViewVector,
        requestParameters.cameraOrthographicLookAt,
        requestParameters.cameraOrthographicUp,
        requestParameters.cameraOrthographicFovHeight,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update a `part-revision`. When given a `file` relationship as a payload, this will invoke a translation job, similar to the POST /parts endpoint. The response code will be a 202 and will respond with an async workflow, and return an Accepted[QueuedJob]. The geometry of the part and all of its children will be replaced with the geometry specified within the translated file given from this relationship. Some of the properties given here are only used for the translation of the file. Namely, `indexMetadata`, `name`, `suppliedIdKey`, `suppliedRevisionIdKey`, and `suppliedInstanceIdKey`. Note that geometry updates are eventually consistent and will not update existing scenes. For updates to the revision when the file relationship is not present will respond with a standard 200 ok code when successful. Note that metadata updates are eventually consistent and will not update existing scenes. To view updated metadata within a scene, a new scene must be created or the updated part-revision must be removed and re-added to an existing scene.
   * @param {PartRevisionsApiUpdatePartRevisionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartRevisionsApi
   */
  public updatePartRevision(
    requestParameters: PartRevisionsApiUpdatePartRevisionRequest,
    options?: AxiosRequestConfig
  ) {
    return PartRevisionsApiFp(this.configuration)
      .updatePartRevision(
        requestParameters.id,
        requestParameters.updatePartRevisionRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PartsApi - axios parameter creator
 * @export
 */
export const PartsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a `part`.  This endpoint includes multiple successful response codes: [`201`, `202`].  When not given a relationship, this endpoint will create a part with an empty part revision and return a `201` status code of the part.  When given a relationship to translate, this endpoint will return a `202` status code with the location of a `queued-translation`. The status of the translation can be queried via `getQueuedTranslation`. After the translation is complete, a `part` and `part-revision` that references the translated geometry.  A unique suppliedId/suppliedRevisionId combination will create a new part and new part revision. For instance, sending my-part-id/my-revision-id will create a new part and new revision with those corresponding supplied ids. To create a new revision for `my-part-id`, likewise you can invoke this endpoint with a new revision id: `my-part-id/my-new-revision-id` and a new revision will be created for the existing part.  See our [Import Data](https://developer.vertexvis.com/docs/guides/import-data-with-api) guides for more information.
     * @param {CreatePartRequest} createPartRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPart: async (
      createPartRequest: CreatePartRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPartRequest' is not null or undefined
      assertParamExists('createPart', 'createPartRequest', createPartRequest);
      const localVarPath = `/parts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPartRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a `part`.
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePart: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deletePart', 'id', id);
      const localVarPath = `/parts/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `part` by ID.
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPart: async (
      id: string,
      include?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPart', 'id', id);
      const localVarPath = `/parts/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (include !== undefined) {
        localVarQueryParameter['include'] = include;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get `parts`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {string} [filterOwnerId] Owner ID to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getParts: async (
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      filterOwnerId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/parts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (filterSuppliedId !== undefined) {
        localVarQueryParameter['filter[suppliedId]'] = filterSuppliedId;
      }

      if (filterOwnerId !== undefined) {
        localVarQueryParameter['filter[ownerId]'] = filterOwnerId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `queued-part-deletion` by ID.
     * @param {string} id The &#x60;queued-part-deletion&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedPartDeletion: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getQueuedPartDeletion', 'id', id);
      const localVarPath = `/queued-part-deletions/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a `part` by ID
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {UpdatePartRequest} updatePartRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePart: async (
      id: string,
      updatePartRequest: UpdatePartRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updatePart', 'id', id);
      // verify required parameter 'updatePartRequest' is not null or undefined
      assertParamExists('updatePart', 'updatePartRequest', updatePartRequest);
      const localVarPath = `/parts/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePartRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PartsApi - functional programming interface
 * @export
 */
export const PartsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PartsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a `part`.  This endpoint includes multiple successful response codes: [`201`, `202`].  When not given a relationship, this endpoint will create a part with an empty part revision and return a `201` status code of the part.  When given a relationship to translate, this endpoint will return a `202` status code with the location of a `queued-translation`. The status of the translation can be queried via `getQueuedTranslation`. After the translation is complete, a `part` and `part-revision` that references the translated geometry.  A unique suppliedId/suppliedRevisionId combination will create a new part and new part revision. For instance, sending my-part-id/my-revision-id will create a new part and new revision with those corresponding supplied ids. To create a new revision for `my-part-id`, likewise you can invoke this endpoint with a new revision id: `my-part-id/my-new-revision-id` and a new revision will be created for the existing part.  See our [Import Data](https://developer.vertexvis.com/docs/guides/import-data-with-api) guides for more information.
     * @param {CreatePartRequest} createPartRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPart(
      createPartRequest: CreatePartRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Part>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPart(
        createPartRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete a `part`.
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePart(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletePart(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `part` by ID.
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPart(
      id: string,
      include?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Part>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPart(
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get `parts`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {string} [filterOwnerId] Owner ID to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getParts(
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      filterOwnerId?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getParts(
        pageCursor,
        pageSize,
        filterSuppliedId,
        filterOwnerId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `queued-part-deletion` by ID.
     * @param {string} id The &#x60;queued-part-deletion&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedPartDeletion(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getQueuedPartDeletion(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update a `part` by ID
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {UpdatePartRequest} updatePartRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePart(
      id: string,
      updatePartRequest: UpdatePartRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePart(
        id,
        updatePartRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PartsApi - factory interface
 * @export
 */
export const PartsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PartsApiFp(configuration);
  return {
    /**
     * Create a `part`.  This endpoint includes multiple successful response codes: [`201`, `202`].  When not given a relationship, this endpoint will create a part with an empty part revision and return a `201` status code of the part.  When given a relationship to translate, this endpoint will return a `202` status code with the location of a `queued-translation`. The status of the translation can be queried via `getQueuedTranslation`. After the translation is complete, a `part` and `part-revision` that references the translated geometry.  A unique suppliedId/suppliedRevisionId combination will create a new part and new part revision. For instance, sending my-part-id/my-revision-id will create a new part and new revision with those corresponding supplied ids. To create a new revision for `my-part-id`, likewise you can invoke this endpoint with a new revision id: `my-part-id/my-new-revision-id` and a new revision will be created for the existing part.  See our [Import Data](https://developer.vertexvis.com/docs/guides/import-data-with-api) guides for more information.
     * @param {CreatePartRequest} createPartRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPart(
      createPartRequest: CreatePartRequest,
      options?: any
    ): AxiosPromise<Part> {
      return localVarFp
        .createPart(createPartRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a `part`.
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePart(id: string, options?: any): AxiosPromise<QueuedJob> {
      return localVarFp
        .deletePart(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `part` by ID.
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPart(id: string, include?: string, options?: any): AxiosPromise<Part> {
      return localVarFp
        .getPart(id, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get `parts`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {string} [filterOwnerId] Owner ID to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getParts(
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      filterOwnerId?: string,
      options?: any
    ): AxiosPromise<PartList> {
      return localVarFp
        .getParts(
          pageCursor,
          pageSize,
          filterSuppliedId,
          filterOwnerId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `queued-part-deletion` by ID.
     * @param {string} id The &#x60;queued-part-deletion&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedPartDeletion(id: string, options?: any): AxiosPromise<QueuedJob> {
      return localVarFp
        .getQueuedPartDeletion(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update a `part` by ID
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {UpdatePartRequest} updatePartRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePart(
      id: string,
      updatePartRequest: UpdatePartRequest,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .updatePart(id, updatePartRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createPart operation in PartsApi.
 * @export
 * @interface PartsApiCreatePartRequest
 */
export interface PartsApiCreatePartRequest {
  /**
   *
   * @type {CreatePartRequest}
   * @memberof PartsApiCreatePart
   */
  readonly createPartRequest: CreatePartRequest;
}

/**
 * Request parameters for deletePart operation in PartsApi.
 * @export
 * @interface PartsApiDeletePartRequest
 */
export interface PartsApiDeletePartRequest {
  /**
   * The &#x60;part&#x60; ID.
   * @type {string}
   * @memberof PartsApiDeletePart
   */
  readonly id: string;
}

/**
 * Request parameters for getPart operation in PartsApi.
 * @export
 * @interface PartsApiGetPartRequest
 */
export interface PartsApiGetPartRequest {
  /**
   * The &#x60;part&#x60; ID.
   * @type {string}
   * @memberof PartsApiGetPart
   */
  readonly id: string;

  /**
   * Comma-separated list of relationships to include in response.
   * @type {string}
   * @memberof PartsApiGetPart
   */
  readonly include?: string;
}

/**
 * Request parameters for getParts operation in PartsApi.
 * @export
 * @interface PartsApiGetPartsRequest
 */
export interface PartsApiGetPartsRequest {
  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof PartsApiGetParts
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof PartsApiGetParts
   */
  readonly pageSize?: number;

  /**
   * Comma-separated list of supplied IDs to filter on.
   * @type {string}
   * @memberof PartsApiGetParts
   */
  readonly filterSuppliedId?: string;

  /**
   * Owner ID to filter on.
   * @type {string}
   * @memberof PartsApiGetParts
   */
  readonly filterOwnerId?: string;
}

/**
 * Request parameters for getQueuedPartDeletion operation in PartsApi.
 * @export
 * @interface PartsApiGetQueuedPartDeletionRequest
 */
export interface PartsApiGetQueuedPartDeletionRequest {
  /**
   * The &#x60;queued-part-deletion&#x60; ID.
   * @type {string}
   * @memberof PartsApiGetQueuedPartDeletion
   */
  readonly id: string;
}

/**
 * Request parameters for updatePart operation in PartsApi.
 * @export
 * @interface PartsApiUpdatePartRequest
 */
export interface PartsApiUpdatePartRequest {
  /**
   * The &#x60;part&#x60; ID.
   * @type {string}
   * @memberof PartsApiUpdatePart
   */
  readonly id: string;

  /**
   *
   * @type {UpdatePartRequest}
   * @memberof PartsApiUpdatePart
   */
  readonly updatePartRequest: UpdatePartRequest;
}

/**
 * PartsApi - object-oriented interface
 * @export
 * @class PartsApi
 * @extends {BaseAPI}
 */
export class PartsApi extends BaseAPI {
  /**
   * Create a `part`.  This endpoint includes multiple successful response codes: [`201`, `202`].  When not given a relationship, this endpoint will create a part with an empty part revision and return a `201` status code of the part.  When given a relationship to translate, this endpoint will return a `202` status code with the location of a `queued-translation`. The status of the translation can be queried via `getQueuedTranslation`. After the translation is complete, a `part` and `part-revision` that references the translated geometry.  A unique suppliedId/suppliedRevisionId combination will create a new part and new part revision. For instance, sending my-part-id/my-revision-id will create a new part and new revision with those corresponding supplied ids. To create a new revision for `my-part-id`, likewise you can invoke this endpoint with a new revision id: `my-part-id/my-new-revision-id` and a new revision will be created for the existing part.  See our [Import Data](https://developer.vertexvis.com/docs/guides/import-data-with-api) guides for more information.
   * @param {PartsApiCreatePartRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartsApi
   */
  public createPart(
    requestParameters: PartsApiCreatePartRequest,
    options?: AxiosRequestConfig
  ) {
    return PartsApiFp(this.configuration)
      .createPart(requestParameters.createPartRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a `part`.
   * @param {PartsApiDeletePartRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartsApi
   */
  public deletePart(
    requestParameters: PartsApiDeletePartRequest,
    options?: AxiosRequestConfig
  ) {
    return PartsApiFp(this.configuration)
      .deletePart(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `part` by ID.
   * @param {PartsApiGetPartRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartsApi
   */
  public getPart(
    requestParameters: PartsApiGetPartRequest,
    options?: AxiosRequestConfig
  ) {
    return PartsApiFp(this.configuration)
      .getPart(requestParameters.id, requestParameters.include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get `parts`.
   * @param {PartsApiGetPartsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartsApi
   */
  public getParts(
    requestParameters: PartsApiGetPartsRequest = {},
    options?: AxiosRequestConfig
  ) {
    return PartsApiFp(this.configuration)
      .getParts(
        requestParameters.pageCursor,
        requestParameters.pageSize,
        requestParameters.filterSuppliedId,
        requestParameters.filterOwnerId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `queued-part-deletion` by ID.
   * @param {PartsApiGetQueuedPartDeletionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartsApi
   */
  public getQueuedPartDeletion(
    requestParameters: PartsApiGetQueuedPartDeletionRequest,
    options?: AxiosRequestConfig
  ) {
    return PartsApiFp(this.configuration)
      .getQueuedPartDeletion(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update a `part` by ID
   * @param {PartsApiUpdatePartRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartsApi
   */
  public updatePart(
    requestParameters: PartsApiUpdatePartRequest,
    options?: AxiosRequestConfig
  ) {
    return PartsApiFp(this.configuration)
      .updatePart(
        requestParameters.id,
        requestParameters.updatePartRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PermissionGrantsApi - axios parameter creator
 * @export
 */
export const PermissionGrantsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a permission grant for a grantee to a subject resource
     * @summary Create a permission grant for a grantee to a subject resource
     * @param {CreatePermissionGrant} createPermissionGrant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPermissionGrant: async (
      createPermissionGrant: CreatePermissionGrant,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPermissionGrant' is not null or undefined
      assertParamExists(
        'createPermissionGrant',
        'createPermissionGrant',
        createPermissionGrant
      );
      const localVarPath = `/permission-grants`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPermissionGrant,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a permission grant by ID
     * @summary Get a permission grant by ID
     * @param {string} id The permission grant ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPermissionGrant: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPermissionGrant', 'id', id);
      const localVarPath = `/permission-grants/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List all permission grants
     * @summary List all permission grants
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPermissionGrants: async (
      pageCursor?: string,
      pageSize?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/permission-grants`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Remove a permission grant by ID
     * @summary Remove a permission grant by ID
     * @param {string} id The permission grant ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePermissionGrant: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('removePermissionGrant', 'id', id);
      const localVarPath = `/permission-grants/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PermissionGrantsApi - functional programming interface
 * @export
 */
export const PermissionGrantsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PermissionGrantsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a permission grant for a grantee to a subject resource
     * @summary Create a permission grant for a grantee to a subject resource
     * @param {CreatePermissionGrant} createPermissionGrant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPermissionGrant(
      createPermissionGrant: CreatePermissionGrant,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PermissionGrant>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createPermissionGrant(
          createPermissionGrant,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a permission grant by ID
     * @summary Get a permission grant by ID
     * @param {string} id The permission grant ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPermissionGrant(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PermissionGrant>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPermissionGrant(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * List all permission grants
     * @summary List all permission grants
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPermissionGrants(
      pageCursor?: string,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PermissionGrantList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listPermissionGrants(
          pageCursor,
          pageSize,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Remove a permission grant by ID
     * @summary Remove a permission grant by ID
     * @param {string} id The permission grant ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removePermissionGrant(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.removePermissionGrant(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PermissionGrantsApi - factory interface
 * @export
 */
export const PermissionGrantsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PermissionGrantsApiFp(configuration);
  return {
    /**
     * Create a permission grant for a grantee to a subject resource
     * @summary Create a permission grant for a grantee to a subject resource
     * @param {CreatePermissionGrant} createPermissionGrant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPermissionGrant(
      createPermissionGrant: CreatePermissionGrant,
      options?: any
    ): AxiosPromise<PermissionGrant> {
      return localVarFp
        .createPermissionGrant(createPermissionGrant, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a permission grant by ID
     * @summary Get a permission grant by ID
     * @param {string} id The permission grant ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPermissionGrant(
      id: string,
      options?: any
    ): AxiosPromise<PermissionGrant> {
      return localVarFp
        .getPermissionGrant(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List all permission grants
     * @summary List all permission grants
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPermissionGrants(
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<PermissionGrantList> {
      return localVarFp
        .listPermissionGrants(pageCursor, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Remove a permission grant by ID
     * @summary Remove a permission grant by ID
     * @param {string} id The permission grant ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePermissionGrant(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .removePermissionGrant(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createPermissionGrant operation in PermissionGrantsApi.
 * @export
 * @interface PermissionGrantsApiCreatePermissionGrantRequest
 */
export interface PermissionGrantsApiCreatePermissionGrantRequest {
  /**
   *
   * @type {CreatePermissionGrant}
   * @memberof PermissionGrantsApiCreatePermissionGrant
   */
  readonly createPermissionGrant: CreatePermissionGrant;
}

/**
 * Request parameters for getPermissionGrant operation in PermissionGrantsApi.
 * @export
 * @interface PermissionGrantsApiGetPermissionGrantRequest
 */
export interface PermissionGrantsApiGetPermissionGrantRequest {
  /**
   * The permission grant ID.
   * @type {string}
   * @memberof PermissionGrantsApiGetPermissionGrant
   */
  readonly id: string;
}

/**
 * Request parameters for listPermissionGrants operation in PermissionGrantsApi.
 * @export
 * @interface PermissionGrantsApiListPermissionGrantsRequest
 */
export interface PermissionGrantsApiListPermissionGrantsRequest {
  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof PermissionGrantsApiListPermissionGrants
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof PermissionGrantsApiListPermissionGrants
   */
  readonly pageSize?: number;
}

/**
 * Request parameters for removePermissionGrant operation in PermissionGrantsApi.
 * @export
 * @interface PermissionGrantsApiRemovePermissionGrantRequest
 */
export interface PermissionGrantsApiRemovePermissionGrantRequest {
  /**
   * The permission grant ID.
   * @type {string}
   * @memberof PermissionGrantsApiRemovePermissionGrant
   */
  readonly id: string;
}

/**
 * PermissionGrantsApi - object-oriented interface
 * @export
 * @class PermissionGrantsApi
 * @extends {BaseAPI}
 */
export class PermissionGrantsApi extends BaseAPI {
  /**
   * Create a permission grant for a grantee to a subject resource
   * @summary Create a permission grant for a grantee to a subject resource
   * @param {PermissionGrantsApiCreatePermissionGrantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PermissionGrantsApi
   */
  public createPermissionGrant(
    requestParameters: PermissionGrantsApiCreatePermissionGrantRequest,
    options?: AxiosRequestConfig
  ) {
    return PermissionGrantsApiFp(this.configuration)
      .createPermissionGrant(requestParameters.createPermissionGrant, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a permission grant by ID
   * @summary Get a permission grant by ID
   * @param {PermissionGrantsApiGetPermissionGrantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PermissionGrantsApi
   */
  public getPermissionGrant(
    requestParameters: PermissionGrantsApiGetPermissionGrantRequest,
    options?: AxiosRequestConfig
  ) {
    return PermissionGrantsApiFp(this.configuration)
      .getPermissionGrant(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List all permission grants
   * @summary List all permission grants
   * @param {PermissionGrantsApiListPermissionGrantsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PermissionGrantsApi
   */
  public listPermissionGrants(
    requestParameters: PermissionGrantsApiListPermissionGrantsRequest = {},
    options?: AxiosRequestConfig
  ) {
    return PermissionGrantsApiFp(this.configuration)
      .listPermissionGrants(
        requestParameters.pageCursor,
        requestParameters.pageSize,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Remove a permission grant by ID
   * @summary Remove a permission grant by ID
   * @param {PermissionGrantsApiRemovePermissionGrantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PermissionGrantsApi
   */
  public removePermissionGrant(
    requestParameters: PermissionGrantsApiRemovePermissionGrantRequest,
    options?: AxiosRequestConfig
  ) {
    return PermissionGrantsApiFp(this.configuration)
      .removePermissionGrant(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PmiApi - axios parameter creator
 * @export
 */
export const PmiApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * List `pmi-annotation`s.
     * @param {string} [filterModelViewId] Filter annotations belonging to a model view.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPmiAnnotations: async (
      filterModelViewId?: string,
      pageCursor?: string,
      pageSize?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/pmi-annotations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (filterModelViewId !== undefined) {
        localVarQueryParameter['filter[modelViewId]'] = filterModelViewId;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PmiApi - functional programming interface
 * @export
 */
export const PmiApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PmiApiAxiosParamCreator(configuration);
  return {
    /**
     * List `pmi-annotation`s.
     * @param {string} [filterModelViewId] Filter annotations belonging to a model view.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPmiAnnotations(
      filterModelViewId?: string,
      pageCursor?: string,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PmiAnnotationList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPmiAnnotations(
          filterModelViewId,
          pageCursor,
          pageSize,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PmiApi - factory interface
 * @export
 */
export const PmiApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PmiApiFp(configuration);
  return {
    /**
     * List `pmi-annotation`s.
     * @param {string} [filterModelViewId] Filter annotations belonging to a model view.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPmiAnnotations(
      filterModelViewId?: string,
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<PmiAnnotationList> {
      return localVarFp
        .getPmiAnnotations(filterModelViewId, pageCursor, pageSize, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for getPmiAnnotations operation in PmiApi.
 * @export
 * @interface PmiApiGetPmiAnnotationsRequest
 */
export interface PmiApiGetPmiAnnotationsRequest {
  /**
   * Filter annotations belonging to a model view.
   * @type {string}
   * @memberof PmiApiGetPmiAnnotations
   */
  readonly filterModelViewId?: string;

  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof PmiApiGetPmiAnnotations
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof PmiApiGetPmiAnnotations
   */
  readonly pageSize?: number;
}

/**
 * PmiApi - object-oriented interface
 * @export
 * @class PmiApi
 * @extends {BaseAPI}
 */
export class PmiApi extends BaseAPI {
  /**
   * List `pmi-annotation`s.
   * @param {PmiApiGetPmiAnnotationsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PmiApi
   */
  public getPmiAnnotations(
    requestParameters: PmiApiGetPmiAnnotationsRequest = {},
    options?: AxiosRequestConfig
  ) {
    return PmiApiFp(this.configuration)
      .getPmiAnnotations(
        requestParameters.filterModelViewId,
        requestParameters.pageCursor,
        requestParameters.pageSize,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PropertyEntriesApi - axios parameter creator
 * @export
 */
export const PropertyEntriesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Get `property-entries` by a resource ID
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterResourceId] A resource ID to filter on
     * @param {string} [filterResourceType] The provided type for the resource ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPropertyEntries: async (
      pageCursor?: string,
      pageSize?: number,
      filterResourceId?: string,
      filterResourceType?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/property-entries`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (filterResourceId !== undefined) {
        localVarQueryParameter['filter[resourceId]'] = filterResourceId;
      }

      if (filterResourceType !== undefined) {
        localVarQueryParameter['filter[resourceType]'] = filterResourceType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Upsert property-entries for a provided resource.
     * @param {UpsertPropertyEntriesRequest} upsertPropertyEntriesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upsertPropertyEntries: async (
      upsertPropertyEntriesRequest: UpsertPropertyEntriesRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'upsertPropertyEntriesRequest' is not null or undefined
      assertParamExists(
        'upsertPropertyEntries',
        'upsertPropertyEntriesRequest',
        upsertPropertyEntriesRequest
      );
      const localVarPath = `/property-entries`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        upsertPropertyEntriesRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PropertyEntriesApi - functional programming interface
 * @export
 */
export const PropertyEntriesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PropertyEntriesApiAxiosParamCreator(configuration);
  return {
    /**
     * Get `property-entries` by a resource ID
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterResourceId] A resource ID to filter on
     * @param {string} [filterResourceType] The provided type for the resource ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPropertyEntries(
      pageCursor?: string,
      pageSize?: number,
      filterResourceId?: string,
      filterResourceType?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PropertyEntryList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPropertyEntries(
          pageCursor,
          pageSize,
          filterResourceId,
          filterResourceType,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Upsert property-entries for a provided resource.
     * @param {UpsertPropertyEntriesRequest} upsertPropertyEntriesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async upsertPropertyEntries(
      upsertPropertyEntriesRequest: UpsertPropertyEntriesRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.upsertPropertyEntries(
          upsertPropertyEntriesRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PropertyEntriesApi - factory interface
 * @export
 */
export const PropertyEntriesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PropertyEntriesApiFp(configuration);
  return {
    /**
     * Get `property-entries` by a resource ID
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterResourceId] A resource ID to filter on
     * @param {string} [filterResourceType] The provided type for the resource ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPropertyEntries(
      pageCursor?: string,
      pageSize?: number,
      filterResourceId?: string,
      filterResourceType?: string,
      options?: any
    ): AxiosPromise<PropertyEntryList> {
      return localVarFp
        .getPropertyEntries(
          pageCursor,
          pageSize,
          filterResourceId,
          filterResourceType,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Upsert property-entries for a provided resource.
     * @param {UpsertPropertyEntriesRequest} upsertPropertyEntriesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upsertPropertyEntries(
      upsertPropertyEntriesRequest: UpsertPropertyEntriesRequest,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .upsertPropertyEntries(upsertPropertyEntriesRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for getPropertyEntries operation in PropertyEntriesApi.
 * @export
 * @interface PropertyEntriesApiGetPropertyEntriesRequest
 */
export interface PropertyEntriesApiGetPropertyEntriesRequest {
  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof PropertyEntriesApiGetPropertyEntries
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof PropertyEntriesApiGetPropertyEntries
   */
  readonly pageSize?: number;

  /**
   * A resource ID to filter on
   * @type {string}
   * @memberof PropertyEntriesApiGetPropertyEntries
   */
  readonly filterResourceId?: string;

  /**
   * The provided type for the resource ids
   * @type {string}
   * @memberof PropertyEntriesApiGetPropertyEntries
   */
  readonly filterResourceType?: string;
}

/**
 * Request parameters for upsertPropertyEntries operation in PropertyEntriesApi.
 * @export
 * @interface PropertyEntriesApiUpsertPropertyEntriesRequest
 */
export interface PropertyEntriesApiUpsertPropertyEntriesRequest {
  /**
   *
   * @type {UpsertPropertyEntriesRequest}
   * @memberof PropertyEntriesApiUpsertPropertyEntries
   */
  readonly upsertPropertyEntriesRequest: UpsertPropertyEntriesRequest;
}

/**
 * PropertyEntriesApi - object-oriented interface
 * @export
 * @class PropertyEntriesApi
 * @extends {BaseAPI}
 */
export class PropertyEntriesApi extends BaseAPI {
  /**
   * Get `property-entries` by a resource ID
   * @param {PropertyEntriesApiGetPropertyEntriesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyEntriesApi
   */
  public getPropertyEntries(
    requestParameters: PropertyEntriesApiGetPropertyEntriesRequest = {},
    options?: AxiosRequestConfig
  ) {
    return PropertyEntriesApiFp(this.configuration)
      .getPropertyEntries(
        requestParameters.pageCursor,
        requestParameters.pageSize,
        requestParameters.filterResourceId,
        requestParameters.filterResourceType,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Upsert property-entries for a provided resource.
   * @param {PropertyEntriesApiUpsertPropertyEntriesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PropertyEntriesApi
   */
  public upsertPropertyEntries(
    requestParameters: PropertyEntriesApiUpsertPropertyEntriesRequest,
    options?: AxiosRequestConfig
  ) {
    return PropertyEntriesApiFp(this.configuration)
      .upsertPropertyEntries(
        requestParameters.upsertPropertyEntriesRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RepliesApi - axios parameter creator
 * @export
 */
export const RepliesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a `reply` belonging to a `thread`.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {CreateReplyRequest} createReplyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createReply: async (
      id: string,
      createReplyRequest: CreateReplyRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createReply', 'id', id);
      // verify required parameter 'createReplyRequest' is not null or undefined
      assertParamExists(
        'createReply',
        'createReplyRequest',
        createReplyRequest
      );
      const localVarPath = `/threads/{id}/replies`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createReplyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Remove a reply.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteReply: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteReply', 'id', id);
      const localVarPath = `/replies/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `reply`.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReply: async (
      id: string,
      include?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getReply', 'id', id);
      const localVarPath = `/replies/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (include !== undefined) {
        localVarQueryParameter['include'] = include;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List `replies`
     * @param {string} [filterThreadId] Comma-separated list of supplied IDs to filter on.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReplies: async (
      filterThreadId?: string,
      pageCursor?: string,
      pageSize?: number,
      include?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/replies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (filterThreadId !== undefined) {
        localVarQueryParameter['filter[threadId]'] = filterThreadId;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (include !== undefined) {
        localVarQueryParameter['include'] = include;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a `reply`.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {UpdateReplyRequest} updateReplyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateReply: async (
      id: string,
      updateReplyRequest: UpdateReplyRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateReply', 'id', id);
      // verify required parameter 'updateReplyRequest' is not null or undefined
      assertParamExists(
        'updateReply',
        'updateReplyRequest',
        updateReplyRequest
      );
      const localVarPath = `/replies/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateReplyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RepliesApi - functional programming interface
 * @export
 */
export const RepliesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RepliesApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a `reply` belonging to a `thread`.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {CreateReplyRequest} createReplyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createReply(
      id: string,
      createReplyRequest: CreateReplyRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reply>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createReply(
        id,
        createReplyRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Remove a reply.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteReply(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReply(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `reply`.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getReply(
      id: string,
      include?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reply>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getReply(
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * List `replies`
     * @param {string} [filterThreadId] Comma-separated list of supplied IDs to filter on.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listReplies(
      filterThreadId?: string,
      pageCursor?: string,
      pageSize?: number,
      include?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReplyList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listReplies(
        filterThreadId,
        pageCursor,
        pageSize,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update a `reply`.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {UpdateReplyRequest} updateReplyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateReply(
      id: string,
      updateReplyRequest: UpdateReplyRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reply>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateReply(
        id,
        updateReplyRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * RepliesApi - factory interface
 * @export
 */
export const RepliesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RepliesApiFp(configuration);
  return {
    /**
     * Create a `reply` belonging to a `thread`.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {CreateReplyRequest} createReplyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createReply(
      id: string,
      createReplyRequest: CreateReplyRequest,
      options?: any
    ): AxiosPromise<Reply> {
      return localVarFp
        .createReply(id, createReplyRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Remove a reply.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteReply(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteReply(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `reply`.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReply(id: string, include?: string, options?: any): AxiosPromise<Reply> {
      return localVarFp
        .getReply(id, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List `replies`
     * @param {string} [filterThreadId] Comma-separated list of supplied IDs to filter on.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReplies(
      filterThreadId?: string,
      pageCursor?: string,
      pageSize?: number,
      include?: string,
      options?: any
    ): AxiosPromise<ReplyList> {
      return localVarFp
        .listReplies(filterThreadId, pageCursor, pageSize, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update a `reply`.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {UpdateReplyRequest} updateReplyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateReply(
      id: string,
      updateReplyRequest: UpdateReplyRequest,
      options?: any
    ): AxiosPromise<Reply> {
      return localVarFp
        .updateReply(id, updateReplyRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createReply operation in RepliesApi.
 * @export
 * @interface RepliesApiCreateReplyRequest
 */
export interface RepliesApiCreateReplyRequest {
  /**
   * The &#x60;thread&#x60; ID.
   * @type {string}
   * @memberof RepliesApiCreateReply
   */
  readonly id: string;

  /**
   *
   * @type {CreateReplyRequest}
   * @memberof RepliesApiCreateReply
   */
  readonly createReplyRequest: CreateReplyRequest;
}

/**
 * Request parameters for deleteReply operation in RepliesApi.
 * @export
 * @interface RepliesApiDeleteReplyRequest
 */
export interface RepliesApiDeleteReplyRequest {
  /**
   * The &#x60;thread&#x60; ID.
   * @type {string}
   * @memberof RepliesApiDeleteReply
   */
  readonly id: string;
}

/**
 * Request parameters for getReply operation in RepliesApi.
 * @export
 * @interface RepliesApiGetReplyRequest
 */
export interface RepliesApiGetReplyRequest {
  /**
   * The &#x60;thread&#x60; ID.
   * @type {string}
   * @memberof RepliesApiGetReply
   */
  readonly id: string;

  /**
   * Comma-separated list of relationships to include in response.
   * @type {string}
   * @memberof RepliesApiGetReply
   */
  readonly include?: string;
}

/**
 * Request parameters for listReplies operation in RepliesApi.
 * @export
 * @interface RepliesApiListRepliesRequest
 */
export interface RepliesApiListRepliesRequest {
  /**
   * Comma-separated list of supplied IDs to filter on.
   * @type {string}
   * @memberof RepliesApiListReplies
   */
  readonly filterThreadId?: string;

  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof RepliesApiListReplies
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof RepliesApiListReplies
   */
  readonly pageSize?: number;

  /**
   * Comma-separated list of relationships to include in response.
   * @type {string}
   * @memberof RepliesApiListReplies
   */
  readonly include?: string;
}

/**
 * Request parameters for updateReply operation in RepliesApi.
 * @export
 * @interface RepliesApiUpdateReplyRequest
 */
export interface RepliesApiUpdateReplyRequest {
  /**
   * The &#x60;thread&#x60; ID.
   * @type {string}
   * @memberof RepliesApiUpdateReply
   */
  readonly id: string;

  /**
   *
   * @type {UpdateReplyRequest}
   * @memberof RepliesApiUpdateReply
   */
  readonly updateReplyRequest: UpdateReplyRequest;
}

/**
 * RepliesApi - object-oriented interface
 * @export
 * @class RepliesApi
 * @extends {BaseAPI}
 */
export class RepliesApi extends BaseAPI {
  /**
   * Create a `reply` belonging to a `thread`.
   * @param {RepliesApiCreateReplyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepliesApi
   */
  public createReply(
    requestParameters: RepliesApiCreateReplyRequest,
    options?: AxiosRequestConfig
  ) {
    return RepliesApiFp(this.configuration)
      .createReply(
        requestParameters.id,
        requestParameters.createReplyRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Remove a reply.
   * @param {RepliesApiDeleteReplyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepliesApi
   */
  public deleteReply(
    requestParameters: RepliesApiDeleteReplyRequest,
    options?: AxiosRequestConfig
  ) {
    return RepliesApiFp(this.configuration)
      .deleteReply(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `reply`.
   * @param {RepliesApiGetReplyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepliesApi
   */
  public getReply(
    requestParameters: RepliesApiGetReplyRequest,
    options?: AxiosRequestConfig
  ) {
    return RepliesApiFp(this.configuration)
      .getReply(requestParameters.id, requestParameters.include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List `replies`
   * @param {RepliesApiListRepliesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepliesApi
   */
  public listReplies(
    requestParameters: RepliesApiListRepliesRequest = {},
    options?: AxiosRequestConfig
  ) {
    return RepliesApiFp(this.configuration)
      .listReplies(
        requestParameters.filterThreadId,
        requestParameters.pageCursor,
        requestParameters.pageSize,
        requestParameters.include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update a `reply`.
   * @param {RepliesApiUpdateReplyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepliesApi
   */
  public updateReply(
    requestParameters: RepliesApiUpdateReplyRequest,
    options?: AxiosRequestConfig
  ) {
    return RepliesApiFp(this.configuration)
      .updateReply(
        requestParameters.id,
        requestParameters.updateReplyRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SceneAlterationsApi - axios parameter creator
 * @export
 */
export const SceneAlterationsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a `scene-alteration` for a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateSceneAlterationRequest | CreateSceneExpressionAlterationRequest} createSceneAlterationRequestCreateSceneExpressionAlterationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneAlteration: async (
      id: string,
      createSceneAlterationRequestCreateSceneExpressionAlterationRequest:
        | CreateSceneAlterationRequest
        | CreateSceneExpressionAlterationRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createSceneAlteration', 'id', id);
      // verify required parameter 'createSceneAlterationRequestCreateSceneExpressionAlterationRequest' is not null or undefined
      assertParamExists(
        'createSceneAlteration',
        'createSceneAlterationRequestCreateSceneExpressionAlterationRequest',
        createSceneAlterationRequestCreateSceneExpressionAlterationRequest
      );
      const localVarPath = `/scene-views/{id}/scene-alterations`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createSceneAlterationRequestCreateSceneExpressionAlterationRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `queued-scene-alteration` by ID.
     * @param {string} id The &#x60;queued-scene-alteration&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedSceneAlteration: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getQueuedSceneAlteration', 'id', id);
      const localVarPath = `/queued-scene-alterations/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `scene-alteration` by ID.
     * @param {string} id The &#x60;scene-alteration&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneAlteration: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getSceneAlteration', 'id', id);
      const localVarPath = `/scene-alterations/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get `scene-alterations` for a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneAlterations: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getSceneAlterations', 'id', id);
      const localVarPath = `/scene-views/{id}/scene-alterations`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SceneAlterationsApi - functional programming interface
 * @export
 */
export const SceneAlterationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SceneAlterationsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a `scene-alteration` for a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateSceneAlterationRequest | CreateSceneExpressionAlterationRequest} createSceneAlterationRequestCreateSceneExpressionAlterationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneAlteration(
      id: string,
      createSceneAlterationRequestCreateSceneExpressionAlterationRequest:
        | CreateSceneAlterationRequest
        | CreateSceneExpressionAlterationRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createSceneAlteration(
          id,
          createSceneAlterationRequestCreateSceneExpressionAlterationRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `queued-scene-alteration` by ID.
     * @param {string} id The &#x60;queued-scene-alteration&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedSceneAlteration(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getQueuedSceneAlteration(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `scene-alteration` by ID.
     * @param {string} id The &#x60;scene-alteration&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneAlteration(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneAlteration>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSceneAlteration(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get `scene-alterations` for a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneAlterations(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneAlterationList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSceneAlterations(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SceneAlterationsApi - factory interface
 * @export
 */
export const SceneAlterationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SceneAlterationsApiFp(configuration);
  return {
    /**
     * Create a `scene-alteration` for a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateSceneAlterationRequest | CreateSceneExpressionAlterationRequest} createSceneAlterationRequestCreateSceneExpressionAlterationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneAlteration(
      id: string,
      createSceneAlterationRequestCreateSceneExpressionAlterationRequest:
        | CreateSceneAlterationRequest
        | CreateSceneExpressionAlterationRequest,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return localVarFp
        .createSceneAlteration(
          id,
          createSceneAlterationRequestCreateSceneExpressionAlterationRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `queued-scene-alteration` by ID.
     * @param {string} id The &#x60;queued-scene-alteration&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedSceneAlteration(
      id: string,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return localVarFp
        .getQueuedSceneAlteration(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `scene-alteration` by ID.
     * @param {string} id The &#x60;scene-alteration&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneAlteration(
      id: string,
      options?: any
    ): AxiosPromise<SceneAlteration> {
      return localVarFp
        .getSceneAlteration(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get `scene-alterations` for a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneAlterations(
      id: string,
      options?: any
    ): AxiosPromise<SceneAlterationList> {
      return localVarFp
        .getSceneAlterations(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createSceneAlteration operation in SceneAlterationsApi.
 * @export
 * @interface SceneAlterationsApiCreateSceneAlterationRequest
 */
export interface SceneAlterationsApiCreateSceneAlterationRequest {
  /**
   * The &#x60;scene-view&#x60; ID.
   * @type {string}
   * @memberof SceneAlterationsApiCreateSceneAlteration
   */
  readonly id: string;

  /**
   *
   * @type {CreateSceneAlterationRequest | CreateSceneExpressionAlterationRequest}
   * @memberof SceneAlterationsApiCreateSceneAlteration
   */
  readonly createSceneAlterationRequestCreateSceneExpressionAlterationRequest:
    | CreateSceneAlterationRequest
    | CreateSceneExpressionAlterationRequest;
}

/**
 * Request parameters for getQueuedSceneAlteration operation in SceneAlterationsApi.
 * @export
 * @interface SceneAlterationsApiGetQueuedSceneAlterationRequest
 */
export interface SceneAlterationsApiGetQueuedSceneAlterationRequest {
  /**
   * The &#x60;queued-scene-alteration&#x60; ID.
   * @type {string}
   * @memberof SceneAlterationsApiGetQueuedSceneAlteration
   */
  readonly id: string;
}

/**
 * Request parameters for getSceneAlteration operation in SceneAlterationsApi.
 * @export
 * @interface SceneAlterationsApiGetSceneAlterationRequest
 */
export interface SceneAlterationsApiGetSceneAlterationRequest {
  /**
   * The &#x60;scene-alteration&#x60; ID.
   * @type {string}
   * @memberof SceneAlterationsApiGetSceneAlteration
   */
  readonly id: string;
}

/**
 * Request parameters for getSceneAlterations operation in SceneAlterationsApi.
 * @export
 * @interface SceneAlterationsApiGetSceneAlterationsRequest
 */
export interface SceneAlterationsApiGetSceneAlterationsRequest {
  /**
   * The &#x60;scene-view&#x60; ID.
   * @type {string}
   * @memberof SceneAlterationsApiGetSceneAlterations
   */
  readonly id: string;
}

/**
 * SceneAlterationsApi - object-oriented interface
 * @export
 * @class SceneAlterationsApi
 * @extends {BaseAPI}
 */
export class SceneAlterationsApi extends BaseAPI {
  /**
   * Create a `scene-alteration` for a `scene-view`.
   * @param {SceneAlterationsApiCreateSceneAlterationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneAlterationsApi
   */
  public createSceneAlteration(
    requestParameters: SceneAlterationsApiCreateSceneAlterationRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneAlterationsApiFp(this.configuration)
      .createSceneAlteration(
        requestParameters.id,
        requestParameters.createSceneAlterationRequestCreateSceneExpressionAlterationRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `queued-scene-alteration` by ID.
   * @param {SceneAlterationsApiGetQueuedSceneAlterationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneAlterationsApi
   */
  public getQueuedSceneAlteration(
    requestParameters: SceneAlterationsApiGetQueuedSceneAlterationRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneAlterationsApiFp(this.configuration)
      .getQueuedSceneAlteration(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `scene-alteration` by ID.
   * @param {SceneAlterationsApiGetSceneAlterationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneAlterationsApi
   */
  public getSceneAlteration(
    requestParameters: SceneAlterationsApiGetSceneAlterationRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneAlterationsApiFp(this.configuration)
      .getSceneAlteration(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get `scene-alterations` for a `scene-view`.
   * @param {SceneAlterationsApiGetSceneAlterationsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneAlterationsApi
   */
  public getSceneAlterations(
    requestParameters: SceneAlterationsApiGetSceneAlterationsRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneAlterationsApiFp(this.configuration)
      .getSceneAlterations(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SceneAnnotationsApi - axios parameter creator
 * @export
 */
export const SceneAnnotationsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create an annotation belonging to an annotation set. **Preview:** This is a preview API and is subject to change.
     * @param {string} id The &#x60;scene-annotation-set&#x60; ID.
     * @param {CreateSceneAnnotationRequest} createSceneAnnotationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneAnnotation: async (
      id: string,
      createSceneAnnotationRequest: CreateSceneAnnotationRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createSceneAnnotation', 'id', id);
      // verify required parameter 'createSceneAnnotationRequest' is not null or undefined
      assertParamExists(
        'createSceneAnnotation',
        'createSceneAnnotationRequest',
        createSceneAnnotationRequest
      );
      const localVarPath =
        `/scene-annotation-sets/{id}/scene-annotations`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(id))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createSceneAnnotationRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create an annotation set that is associated with a scene. **Preview:** This is a preview API and is subject to change.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneAnnotationSetRequest} createSceneAnnotationSetRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneAnnotationSet: async (
      id: string,
      createSceneAnnotationSetRequest: CreateSceneAnnotationSetRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createSceneAnnotationSet', 'id', id);
      // verify required parameter 'createSceneAnnotationSetRequest' is not null or undefined
      assertParamExists(
        'createSceneAnnotationSet',
        'createSceneAnnotationSetRequest',
        createSceneAnnotationSetRequest
      );
      const localVarPath = `/scenes/{id}/scene-annotation-sets`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createSceneAnnotationSetRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a scene annotation. **Preview:** This is a preview API and is subject to change.
     * @param {string} id The &#x60;scene-annotation&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSceneAnnotation: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteSceneAnnotation', 'id', id);
      const localVarPath = `/scene-annotations/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get `scene-annotation-sets` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterId] Comma-separated list of IDs to filter on.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneAnnotationSets: async (
      id: string,
      pageCursor?: string,
      pageSize?: number,
      filterId?: string,
      filterSuppliedId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getSceneAnnotationSets', 'id', id);
      const localVarPath = `/scenes/{id}/scene-annotation-sets`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId;
      }

      if (filterSuppliedId !== undefined) {
        localVarQueryParameter['filter[suppliedId]'] = filterSuppliedId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update the attributes of an annotation. **Preview:** This is a preview API and is subject to change.
     * @param {string} id The &#x60;scene-annotation&#x60; ID.
     * @param {UpdateSceneAnnotationRequest} updateSceneAnnotationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneAnnotation: async (
      id: string,
      updateSceneAnnotationRequest: UpdateSceneAnnotationRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateSceneAnnotation', 'id', id);
      // verify required parameter 'updateSceneAnnotationRequest' is not null or undefined
      assertParamExists(
        'updateSceneAnnotation',
        'updateSceneAnnotationRequest',
        updateSceneAnnotationRequest
      );
      const localVarPath = `/scene-annotations/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateSceneAnnotationRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SceneAnnotationsApi - functional programming interface
 * @export
 */
export const SceneAnnotationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SceneAnnotationsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create an annotation belonging to an annotation set. **Preview:** This is a preview API and is subject to change.
     * @param {string} id The &#x60;scene-annotation-set&#x60; ID.
     * @param {CreateSceneAnnotationRequest} createSceneAnnotationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneAnnotation(
      id: string,
      createSceneAnnotationRequest: CreateSceneAnnotationRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneAnnotation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createSceneAnnotation(
          id,
          createSceneAnnotationRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Create an annotation set that is associated with a scene. **Preview:** This is a preview API and is subject to change.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneAnnotationSetRequest} createSceneAnnotationSetRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneAnnotationSet(
      id: string,
      createSceneAnnotationSetRequest: CreateSceneAnnotationSetRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneAnnotationSet>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createSceneAnnotationSet(
          id,
          createSceneAnnotationSetRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete a scene annotation. **Preview:** This is a preview API and is subject to change.
     * @param {string} id The &#x60;scene-annotation&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSceneAnnotation(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteSceneAnnotation(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get `scene-annotation-sets` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterId] Comma-separated list of IDs to filter on.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneAnnotationSets(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      filterId?: string,
      filterSuppliedId?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneAnnotationSetList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSceneAnnotationSets(
          id,
          pageCursor,
          pageSize,
          filterId,
          filterSuppliedId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update the attributes of an annotation. **Preview:** This is a preview API and is subject to change.
     * @param {string} id The &#x60;scene-annotation&#x60; ID.
     * @param {UpdateSceneAnnotationRequest} updateSceneAnnotationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSceneAnnotation(
      id: string,
      updateSceneAnnotationRequest: UpdateSceneAnnotationRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneAnnotation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateSceneAnnotation(
          id,
          updateSceneAnnotationRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SceneAnnotationsApi - factory interface
 * @export
 */
export const SceneAnnotationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SceneAnnotationsApiFp(configuration);
  return {
    /**
     * Create an annotation belonging to an annotation set. **Preview:** This is a preview API and is subject to change.
     * @param {string} id The &#x60;scene-annotation-set&#x60; ID.
     * @param {CreateSceneAnnotationRequest} createSceneAnnotationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneAnnotation(
      id: string,
      createSceneAnnotationRequest: CreateSceneAnnotationRequest,
      options?: any
    ): AxiosPromise<SceneAnnotation> {
      return localVarFp
        .createSceneAnnotation(id, createSceneAnnotationRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create an annotation set that is associated with a scene. **Preview:** This is a preview API and is subject to change.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneAnnotationSetRequest} createSceneAnnotationSetRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneAnnotationSet(
      id: string,
      createSceneAnnotationSetRequest: CreateSceneAnnotationSetRequest,
      options?: any
    ): AxiosPromise<SceneAnnotationSet> {
      return localVarFp
        .createSceneAnnotationSet(id, createSceneAnnotationSetRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a scene annotation. **Preview:** This is a preview API and is subject to change.
     * @param {string} id The &#x60;scene-annotation&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSceneAnnotation(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteSceneAnnotation(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get `scene-annotation-sets` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterId] Comma-separated list of IDs to filter on.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneAnnotationSets(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      filterId?: string,
      filterSuppliedId?: string,
      options?: any
    ): AxiosPromise<SceneAnnotationSetList> {
      return localVarFp
        .getSceneAnnotationSets(
          id,
          pageCursor,
          pageSize,
          filterId,
          filterSuppliedId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Update the attributes of an annotation. **Preview:** This is a preview API and is subject to change.
     * @param {string} id The &#x60;scene-annotation&#x60; ID.
     * @param {UpdateSceneAnnotationRequest} updateSceneAnnotationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneAnnotation(
      id: string,
      updateSceneAnnotationRequest: UpdateSceneAnnotationRequest,
      options?: any
    ): AxiosPromise<SceneAnnotation> {
      return localVarFp
        .updateSceneAnnotation(id, updateSceneAnnotationRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createSceneAnnotation operation in SceneAnnotationsApi.
 * @export
 * @interface SceneAnnotationsApiCreateSceneAnnotationRequest
 */
export interface SceneAnnotationsApiCreateSceneAnnotationRequest {
  /**
   * The &#x60;scene-annotation-set&#x60; ID.
   * @type {string}
   * @memberof SceneAnnotationsApiCreateSceneAnnotation
   */
  readonly id: string;

  /**
   *
   * @type {CreateSceneAnnotationRequest}
   * @memberof SceneAnnotationsApiCreateSceneAnnotation
   */
  readonly createSceneAnnotationRequest: CreateSceneAnnotationRequest;
}

/**
 * Request parameters for createSceneAnnotationSet operation in SceneAnnotationsApi.
 * @export
 * @interface SceneAnnotationsApiCreateSceneAnnotationSetRequest
 */
export interface SceneAnnotationsApiCreateSceneAnnotationSetRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof SceneAnnotationsApiCreateSceneAnnotationSet
   */
  readonly id: string;

  /**
   *
   * @type {CreateSceneAnnotationSetRequest}
   * @memberof SceneAnnotationsApiCreateSceneAnnotationSet
   */
  readonly createSceneAnnotationSetRequest: CreateSceneAnnotationSetRequest;
}

/**
 * Request parameters for deleteSceneAnnotation operation in SceneAnnotationsApi.
 * @export
 * @interface SceneAnnotationsApiDeleteSceneAnnotationRequest
 */
export interface SceneAnnotationsApiDeleteSceneAnnotationRequest {
  /**
   * The &#x60;scene-annotation&#x60; ID.
   * @type {string}
   * @memberof SceneAnnotationsApiDeleteSceneAnnotation
   */
  readonly id: string;
}

/**
 * Request parameters for getSceneAnnotationSets operation in SceneAnnotationsApi.
 * @export
 * @interface SceneAnnotationsApiGetSceneAnnotationSetsRequest
 */
export interface SceneAnnotationsApiGetSceneAnnotationSetsRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof SceneAnnotationsApiGetSceneAnnotationSets
   */
  readonly id: string;

  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof SceneAnnotationsApiGetSceneAnnotationSets
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof SceneAnnotationsApiGetSceneAnnotationSets
   */
  readonly pageSize?: number;

  /**
   * Comma-separated list of IDs to filter on.
   * @type {string}
   * @memberof SceneAnnotationsApiGetSceneAnnotationSets
   */
  readonly filterId?: string;

  /**
   * Comma-separated list of supplied IDs to filter on.
   * @type {string}
   * @memberof SceneAnnotationsApiGetSceneAnnotationSets
   */
  readonly filterSuppliedId?: string;
}

/**
 * Request parameters for updateSceneAnnotation operation in SceneAnnotationsApi.
 * @export
 * @interface SceneAnnotationsApiUpdateSceneAnnotationRequest
 */
export interface SceneAnnotationsApiUpdateSceneAnnotationRequest {
  /**
   * The &#x60;scene-annotation&#x60; ID.
   * @type {string}
   * @memberof SceneAnnotationsApiUpdateSceneAnnotation
   */
  readonly id: string;

  /**
   *
   * @type {UpdateSceneAnnotationRequest}
   * @memberof SceneAnnotationsApiUpdateSceneAnnotation
   */
  readonly updateSceneAnnotationRequest: UpdateSceneAnnotationRequest;
}

/**
 * SceneAnnotationsApi - object-oriented interface
 * @export
 * @class SceneAnnotationsApi
 * @extends {BaseAPI}
 */
export class SceneAnnotationsApi extends BaseAPI {
  /**
   * Create an annotation belonging to an annotation set. **Preview:** This is a preview API and is subject to change.
   * @param {SceneAnnotationsApiCreateSceneAnnotationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneAnnotationsApi
   */
  public createSceneAnnotation(
    requestParameters: SceneAnnotationsApiCreateSceneAnnotationRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneAnnotationsApiFp(this.configuration)
      .createSceneAnnotation(
        requestParameters.id,
        requestParameters.createSceneAnnotationRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create an annotation set that is associated with a scene. **Preview:** This is a preview API and is subject to change.
   * @param {SceneAnnotationsApiCreateSceneAnnotationSetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneAnnotationsApi
   */
  public createSceneAnnotationSet(
    requestParameters: SceneAnnotationsApiCreateSceneAnnotationSetRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneAnnotationsApiFp(this.configuration)
      .createSceneAnnotationSet(
        requestParameters.id,
        requestParameters.createSceneAnnotationSetRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a scene annotation. **Preview:** This is a preview API and is subject to change.
   * @param {SceneAnnotationsApiDeleteSceneAnnotationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneAnnotationsApi
   */
  public deleteSceneAnnotation(
    requestParameters: SceneAnnotationsApiDeleteSceneAnnotationRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneAnnotationsApiFp(this.configuration)
      .deleteSceneAnnotation(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get `scene-annotation-sets` for a `scene`.
   * @param {SceneAnnotationsApiGetSceneAnnotationSetsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneAnnotationsApi
   */
  public getSceneAnnotationSets(
    requestParameters: SceneAnnotationsApiGetSceneAnnotationSetsRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneAnnotationsApiFp(this.configuration)
      .getSceneAnnotationSets(
        requestParameters.id,
        requestParameters.pageCursor,
        requestParameters.pageSize,
        requestParameters.filterId,
        requestParameters.filterSuppliedId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update the attributes of an annotation. **Preview:** This is a preview API and is subject to change.
   * @param {SceneAnnotationsApiUpdateSceneAnnotationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneAnnotationsApi
   */
  public updateSceneAnnotation(
    requestParameters: SceneAnnotationsApiUpdateSceneAnnotationRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneAnnotationsApiFp(this.configuration)
      .updateSceneAnnotation(
        requestParameters.id,
        requestParameters.updateSceneAnnotationRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SceneItemOverridesApi - axios parameter creator
 * @export
 */
export const SceneItemOverridesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a `scene-item-override` for a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateSceneItemOverrideRequest} createSceneItemOverrideRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneItemOverride: async (
      id: string,
      createSceneItemOverrideRequest: CreateSceneItemOverrideRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createSceneItemOverride', 'id', id);
      // verify required parameter 'createSceneItemOverrideRequest' is not null or undefined
      assertParamExists(
        'createSceneItemOverride',
        'createSceneItemOverrideRequest',
        createSceneItemOverrideRequest
      );
      const localVarPath = `/scene-views/{id}/scene-item-overrides`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createSceneItemOverrideRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a `scene-item-override`.
     * @param {string} id The &#x60;scene-item-override&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSceneItemOverride: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteSceneItemOverride', 'id', id);
      const localVarPath = `/scene-item-overrides/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get `scene-item-overrides` for a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneItemOverrides: async (
      id: string,
      pageCursor?: string,
      pageSize?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getSceneItemOverrides', 'id', id);
      const localVarPath = `/scene-views/{id}/scene-item-overrides`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a `scene-item-override`.
     * @param {string} id The &#x60;scene-item-override&#x60; ID.
     * @param {UpdateSceneItemOverrideRequest} updateSceneItemOverrideRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneItemOverride: async (
      id: string,
      updateSceneItemOverrideRequest: UpdateSceneItemOverrideRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateSceneItemOverride', 'id', id);
      // verify required parameter 'updateSceneItemOverrideRequest' is not null or undefined
      assertParamExists(
        'updateSceneItemOverride',
        'updateSceneItemOverrideRequest',
        updateSceneItemOverrideRequest
      );
      const localVarPath = `/scene-item-overrides/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateSceneItemOverrideRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SceneItemOverridesApi - functional programming interface
 * @export
 */
export const SceneItemOverridesApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    SceneItemOverridesApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a `scene-item-override` for a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateSceneItemOverrideRequest} createSceneItemOverrideRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneItemOverride(
      id: string,
      createSceneItemOverrideRequest: CreateSceneItemOverrideRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneItemOverride>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createSceneItemOverride(
          id,
          createSceneItemOverrideRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete a `scene-item-override`.
     * @param {string} id The &#x60;scene-item-override&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSceneItemOverride(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteSceneItemOverride(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get `scene-item-overrides` for a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneItemOverrides(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneItemOverrideList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSceneItemOverrides(
          id,
          pageCursor,
          pageSize,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update a `scene-item-override`.
     * @param {string} id The &#x60;scene-item-override&#x60; ID.
     * @param {UpdateSceneItemOverrideRequest} updateSceneItemOverrideRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSceneItemOverride(
      id: string,
      updateSceneItemOverrideRequest: UpdateSceneItemOverrideRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneItemOverride>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateSceneItemOverride(
          id,
          updateSceneItemOverrideRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SceneItemOverridesApi - factory interface
 * @export
 */
export const SceneItemOverridesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SceneItemOverridesApiFp(configuration);
  return {
    /**
     * Create a `scene-item-override` for a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateSceneItemOverrideRequest} createSceneItemOverrideRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneItemOverride(
      id: string,
      createSceneItemOverrideRequest: CreateSceneItemOverrideRequest,
      options?: any
    ): AxiosPromise<SceneItemOverride> {
      return localVarFp
        .createSceneItemOverride(id, createSceneItemOverrideRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a `scene-item-override`.
     * @param {string} id The &#x60;scene-item-override&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSceneItemOverride(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteSceneItemOverride(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get `scene-item-overrides` for a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneItemOverrides(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<SceneItemOverrideList> {
      return localVarFp
        .getSceneItemOverrides(id, pageCursor, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update a `scene-item-override`.
     * @param {string} id The &#x60;scene-item-override&#x60; ID.
     * @param {UpdateSceneItemOverrideRequest} updateSceneItemOverrideRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneItemOverride(
      id: string,
      updateSceneItemOverrideRequest: UpdateSceneItemOverrideRequest,
      options?: any
    ): AxiosPromise<SceneItemOverride> {
      return localVarFp
        .updateSceneItemOverride(id, updateSceneItemOverrideRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createSceneItemOverride operation in SceneItemOverridesApi.
 * @export
 * @interface SceneItemOverridesApiCreateSceneItemOverrideRequest
 */
export interface SceneItemOverridesApiCreateSceneItemOverrideRequest {
  /**
   * The &#x60;scene-view&#x60; ID.
   * @type {string}
   * @memberof SceneItemOverridesApiCreateSceneItemOverride
   */
  readonly id: string;

  /**
   *
   * @type {CreateSceneItemOverrideRequest}
   * @memberof SceneItemOverridesApiCreateSceneItemOverride
   */
  readonly createSceneItemOverrideRequest: CreateSceneItemOverrideRequest;
}

/**
 * Request parameters for deleteSceneItemOverride operation in SceneItemOverridesApi.
 * @export
 * @interface SceneItemOverridesApiDeleteSceneItemOverrideRequest
 */
export interface SceneItemOverridesApiDeleteSceneItemOverrideRequest {
  /**
   * The &#x60;scene-item-override&#x60; ID.
   * @type {string}
   * @memberof SceneItemOverridesApiDeleteSceneItemOverride
   */
  readonly id: string;
}

/**
 * Request parameters for getSceneItemOverrides operation in SceneItemOverridesApi.
 * @export
 * @interface SceneItemOverridesApiGetSceneItemOverridesRequest
 */
export interface SceneItemOverridesApiGetSceneItemOverridesRequest {
  /**
   * The &#x60;scene-view&#x60; ID.
   * @type {string}
   * @memberof SceneItemOverridesApiGetSceneItemOverrides
   */
  readonly id: string;

  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof SceneItemOverridesApiGetSceneItemOverrides
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof SceneItemOverridesApiGetSceneItemOverrides
   */
  readonly pageSize?: number;
}

/**
 * Request parameters for updateSceneItemOverride operation in SceneItemOverridesApi.
 * @export
 * @interface SceneItemOverridesApiUpdateSceneItemOverrideRequest
 */
export interface SceneItemOverridesApiUpdateSceneItemOverrideRequest {
  /**
   * The &#x60;scene-item-override&#x60; ID.
   * @type {string}
   * @memberof SceneItemOverridesApiUpdateSceneItemOverride
   */
  readonly id: string;

  /**
   *
   * @type {UpdateSceneItemOverrideRequest}
   * @memberof SceneItemOverridesApiUpdateSceneItemOverride
   */
  readonly updateSceneItemOverrideRequest: UpdateSceneItemOverrideRequest;
}

/**
 * SceneItemOverridesApi - object-oriented interface
 * @export
 * @class SceneItemOverridesApi
 * @extends {BaseAPI}
 */
export class SceneItemOverridesApi extends BaseAPI {
  /**
   * Create a `scene-item-override` for a `scene-view`.
   * @param {SceneItemOverridesApiCreateSceneItemOverrideRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemOverridesApi
   */
  public createSceneItemOverride(
    requestParameters: SceneItemOverridesApiCreateSceneItemOverrideRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneItemOverridesApiFp(this.configuration)
      .createSceneItemOverride(
        requestParameters.id,
        requestParameters.createSceneItemOverrideRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a `scene-item-override`.
   * @param {SceneItemOverridesApiDeleteSceneItemOverrideRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemOverridesApi
   */
  public deleteSceneItemOverride(
    requestParameters: SceneItemOverridesApiDeleteSceneItemOverrideRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneItemOverridesApiFp(this.configuration)
      .deleteSceneItemOverride(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get `scene-item-overrides` for a `scene-view`.
   * @param {SceneItemOverridesApiGetSceneItemOverridesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemOverridesApi
   */
  public getSceneItemOverrides(
    requestParameters: SceneItemOverridesApiGetSceneItemOverridesRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneItemOverridesApiFp(this.configuration)
      .getSceneItemOverrides(
        requestParameters.id,
        requestParameters.pageCursor,
        requestParameters.pageSize,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update a `scene-item-override`.
   * @param {SceneItemOverridesApiUpdateSceneItemOverrideRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemOverridesApi
   */
  public updateSceneItemOverride(
    requestParameters: SceneItemOverridesApiUpdateSceneItemOverrideRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneItemOverridesApiFp(this.configuration)
      .updateSceneItemOverride(
        requestParameters.id,
        requestParameters.updateSceneItemOverrideRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SceneItemsApi - axios parameter creator
 * @export
 */
export const SceneItemsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a `scene-item` for a `scene`. Provide the source geometry either via `part-revision` or `geometry-set` UUID using `relationship.source` or by supplied IDs using `attributes.source`. Provide an existing `scene` using `relationship.source` to clone it. Provide the hierarchical parent either via `scene-item` UUID using `relationship.source` or by supplied ID using `attributes.parent`. To reduce the time taken creating many hierarchical `scene-items`, make a best effort to create parents before children. One way to do this is by sorting the items by depth and starting at the root. This API is asynchronous, returning the location of a `queued-scene-item`. Check the status via the getQueuedSceneItem API. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneItemRequest} createSceneItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneItem: async (
      id: string,
      createSceneItemRequest: CreateSceneItemRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createSceneItem', 'id', id);
      // verify required parameter 'createSceneItemRequest' is not null or undefined
      assertParamExists(
        'createSceneItem',
        'createSceneItemRequest',
        createSceneItemRequest
      );
      const localVarPath = `/scenes/{id}/scene-items`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createSceneItemRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a `scene-item`.
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSceneItem: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteSceneItem', 'id', id);
      const localVarPath = `/scene-items/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `queued-scene-item`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `scene-item`. Once created, commit the scene via the updateScene API. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
     * @param {string} id The &#x60;queued-scene-item&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedSceneItem: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getQueuedSceneItem', 'id', id);
      const localVarPath = `/queued-scene-items/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `queued-scene-item-deletion` by ID.
     * @param {string} id The &#x60;queued-scene-item-deletion&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedSceneItemDeletion: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getQueuedSceneItemDeletion', 'id', id);
      const localVarPath = `/queued-scene-item-deletions/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `scene-item` by ID.
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {string} [fieldsSceneItem] Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;boundingBox&#x60;, &#x60;worldTransform&#x60; and &#x60;metadata&#x60; are only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneItem: async (
      id: string,
      fieldsSceneItem?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getSceneItem', 'id', id);
      const localVarPath = `/scene-items/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (fieldsSceneItem !== undefined) {
        localVarQueryParameter['fields[scene-item]'] = fieldsSceneItem;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get `scene-items` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSource] Source ID to filter on.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {string} [filterParent] Parent ID to filter on. Sending null will return items without a parent.
     * @param {boolean} [filterHasChildren] Filter scene-items based on whether they are the parent of at least one other scene-item
     * @param {boolean} [filterHasGeometrySet] Filter scene-items based on whether they have an associated geometry-set.
     * @param {string} [sort] A sort to apply to the collection. A \&quot;minus\&quot; prefixed before the field name is used to specify descending sort order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneItems: async (
      id: string,
      pageCursor?: string,
      pageSize?: number,
      filterSource?: string,
      filterSuppliedId?: string,
      filterParent?: string,
      filterHasChildren?: boolean,
      filterHasGeometrySet?: boolean,
      sort?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getSceneItems', 'id', id);
      const localVarPath = `/scenes/{id}/scene-items`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (filterSource !== undefined) {
        localVarQueryParameter['filter[source]'] = filterSource;
      }

      if (filterSuppliedId !== undefined) {
        localVarQueryParameter['filter[suppliedId]'] = filterSuppliedId;
      }

      if (filterParent !== undefined) {
        localVarQueryParameter['filter[parent]'] = filterParent;
      }

      if (filterHasChildren !== undefined) {
        localVarQueryParameter['filter[hasChildren]'] = filterHasChildren;
      }

      if (filterHasGeometrySet !== undefined) {
        localVarQueryParameter['filter[hasGeometrySet]'] = filterHasGeometrySet;
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a `scene-item`.
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {UpdateSceneItemRequest} updateSceneItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneItem: async (
      id: string,
      updateSceneItemRequest: UpdateSceneItemRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateSceneItem', 'id', id);
      // verify required parameter 'updateSceneItemRequest' is not null or undefined
      assertParamExists(
        'updateSceneItem',
        'updateSceneItemRequest',
        updateSceneItemRequest
      );
      const localVarPath = `/scene-items/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateSceneItemRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SceneItemsApi - functional programming interface
 * @export
 */
export const SceneItemsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SceneItemsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a `scene-item` for a `scene`. Provide the source geometry either via `part-revision` or `geometry-set` UUID using `relationship.source` or by supplied IDs using `attributes.source`. Provide an existing `scene` using `relationship.source` to clone it. Provide the hierarchical parent either via `scene-item` UUID using `relationship.source` or by supplied ID using `attributes.parent`. To reduce the time taken creating many hierarchical `scene-items`, make a best effort to create parents before children. One way to do this is by sorting the items by depth and starting at the root. This API is asynchronous, returning the location of a `queued-scene-item`. Check the status via the getQueuedSceneItem API. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneItemRequest} createSceneItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneItem(
      id: string,
      createSceneItemRequest: CreateSceneItemRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createSceneItem(
        id,
        createSceneItemRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete a `scene-item`.
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSceneItem(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSceneItem(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `queued-scene-item`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `scene-item`. Once created, commit the scene via the updateScene API. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
     * @param {string} id The &#x60;queued-scene-item&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedSceneItem(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getQueuedSceneItem(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `queued-scene-item-deletion` by ID.
     * @param {string} id The &#x60;queued-scene-item-deletion&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedSceneItemDeletion(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getQueuedSceneItemDeletion(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `scene-item` by ID.
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {string} [fieldsSceneItem] Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;boundingBox&#x60;, &#x60;worldTransform&#x60; and &#x60;metadata&#x60; are only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneItem(
      id: string,
      fieldsSceneItem?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneItem>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSceneItem(
        id,
        fieldsSceneItem,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get `scene-items` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSource] Source ID to filter on.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {string} [filterParent] Parent ID to filter on. Sending null will return items without a parent.
     * @param {boolean} [filterHasChildren] Filter scene-items based on whether they are the parent of at least one other scene-item
     * @param {boolean} [filterHasGeometrySet] Filter scene-items based on whether they have an associated geometry-set.
     * @param {string} [sort] A sort to apply to the collection. A \&quot;minus\&quot; prefixed before the field name is used to specify descending sort order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneItems(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      filterSource?: string,
      filterSuppliedId?: string,
      filterParent?: string,
      filterHasChildren?: boolean,
      filterHasGeometrySet?: boolean,
      sort?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneItemList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSceneItems(
        id,
        pageCursor,
        pageSize,
        filterSource,
        filterSuppliedId,
        filterParent,
        filterHasChildren,
        filterHasGeometrySet,
        sort,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update a `scene-item`.
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {UpdateSceneItemRequest} updateSceneItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSceneItem(
      id: string,
      updateSceneItemRequest: UpdateSceneItemRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateSceneItem(
        id,
        updateSceneItemRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SceneItemsApi - factory interface
 * @export
 */
export const SceneItemsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SceneItemsApiFp(configuration);
  return {
    /**
     * Create a `scene-item` for a `scene`. Provide the source geometry either via `part-revision` or `geometry-set` UUID using `relationship.source` or by supplied IDs using `attributes.source`. Provide an existing `scene` using `relationship.source` to clone it. Provide the hierarchical parent either via `scene-item` UUID using `relationship.source` or by supplied ID using `attributes.parent`. To reduce the time taken creating many hierarchical `scene-items`, make a best effort to create parents before children. One way to do this is by sorting the items by depth and starting at the root. This API is asynchronous, returning the location of a `queued-scene-item`. Check the status via the getQueuedSceneItem API. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneItemRequest} createSceneItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneItem(
      id: string,
      createSceneItemRequest: CreateSceneItemRequest,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return localVarFp
        .createSceneItem(id, createSceneItemRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a `scene-item`.
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSceneItem(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteSceneItem(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `queued-scene-item`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `scene-item`. Once created, commit the scene via the updateScene API. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
     * @param {string} id The &#x60;queued-scene-item&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedSceneItem(id: string, options?: any): AxiosPromise<QueuedJob> {
      return localVarFp
        .getQueuedSceneItem(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `queued-scene-item-deletion` by ID.
     * @param {string} id The &#x60;queued-scene-item-deletion&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedSceneItemDeletion(
      id: string,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return localVarFp
        .getQueuedSceneItemDeletion(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `scene-item` by ID.
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {string} [fieldsSceneItem] Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;boundingBox&#x60;, &#x60;worldTransform&#x60; and &#x60;metadata&#x60; are only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneItem(
      id: string,
      fieldsSceneItem?: string,
      options?: any
    ): AxiosPromise<SceneItem> {
      return localVarFp
        .getSceneItem(id, fieldsSceneItem, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get `scene-items` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSource] Source ID to filter on.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {string} [filterParent] Parent ID to filter on. Sending null will return items without a parent.
     * @param {boolean} [filterHasChildren] Filter scene-items based on whether they are the parent of at least one other scene-item
     * @param {boolean} [filterHasGeometrySet] Filter scene-items based on whether they have an associated geometry-set.
     * @param {string} [sort] A sort to apply to the collection. A \&quot;minus\&quot; prefixed before the field name is used to specify descending sort order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneItems(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      filterSource?: string,
      filterSuppliedId?: string,
      filterParent?: string,
      filterHasChildren?: boolean,
      filterHasGeometrySet?: boolean,
      sort?: string,
      options?: any
    ): AxiosPromise<SceneItemList> {
      return localVarFp
        .getSceneItems(
          id,
          pageCursor,
          pageSize,
          filterSource,
          filterSuppliedId,
          filterParent,
          filterHasChildren,
          filterHasGeometrySet,
          sort,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Update a `scene-item`.
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {UpdateSceneItemRequest} updateSceneItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneItem(
      id: string,
      updateSceneItemRequest: UpdateSceneItemRequest,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return localVarFp
        .updateSceneItem(id, updateSceneItemRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createSceneItem operation in SceneItemsApi.
 * @export
 * @interface SceneItemsApiCreateSceneItemRequest
 */
export interface SceneItemsApiCreateSceneItemRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof SceneItemsApiCreateSceneItem
   */
  readonly id: string;

  /**
   *
   * @type {CreateSceneItemRequest}
   * @memberof SceneItemsApiCreateSceneItem
   */
  readonly createSceneItemRequest: CreateSceneItemRequest;
}

/**
 * Request parameters for deleteSceneItem operation in SceneItemsApi.
 * @export
 * @interface SceneItemsApiDeleteSceneItemRequest
 */
export interface SceneItemsApiDeleteSceneItemRequest {
  /**
   * The &#x60;scene-item&#x60; ID.
   * @type {string}
   * @memberof SceneItemsApiDeleteSceneItem
   */
  readonly id: string;
}

/**
 * Request parameters for getQueuedSceneItem operation in SceneItemsApi.
 * @export
 * @interface SceneItemsApiGetQueuedSceneItemRequest
 */
export interface SceneItemsApiGetQueuedSceneItemRequest {
  /**
   * The &#x60;queued-scene-item&#x60; ID.
   * @type {string}
   * @memberof SceneItemsApiGetQueuedSceneItem
   */
  readonly id: string;
}

/**
 * Request parameters for getQueuedSceneItemDeletion operation in SceneItemsApi.
 * @export
 * @interface SceneItemsApiGetQueuedSceneItemDeletionRequest
 */
export interface SceneItemsApiGetQueuedSceneItemDeletionRequest {
  /**
   * The &#x60;queued-scene-item-deletion&#x60; ID.
   * @type {string}
   * @memberof SceneItemsApiGetQueuedSceneItemDeletion
   */
  readonly id: string;
}

/**
 * Request parameters for getSceneItem operation in SceneItemsApi.
 * @export
 * @interface SceneItemsApiGetSceneItemRequest
 */
export interface SceneItemsApiGetSceneItemRequest {
  /**
   * The &#x60;scene-item&#x60; ID.
   * @type {string}
   * @memberof SceneItemsApiGetSceneItem
   */
  readonly id: string;

  /**
   * Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;boundingBox&#x60;, &#x60;worldTransform&#x60; and &#x60;metadata&#x60; are only returned if explicitly requested.
   * @type {string}
   * @memberof SceneItemsApiGetSceneItem
   */
  readonly fieldsSceneItem?: string;
}

/**
 * Request parameters for getSceneItems operation in SceneItemsApi.
 * @export
 * @interface SceneItemsApiGetSceneItemsRequest
 */
export interface SceneItemsApiGetSceneItemsRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof SceneItemsApiGetSceneItems
   */
  readonly id: string;

  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof SceneItemsApiGetSceneItems
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof SceneItemsApiGetSceneItems
   */
  readonly pageSize?: number;

  /**
   * Source ID to filter on.
   * @type {string}
   * @memberof SceneItemsApiGetSceneItems
   */
  readonly filterSource?: string;

  /**
   * Comma-separated list of supplied IDs to filter on.
   * @type {string}
   * @memberof SceneItemsApiGetSceneItems
   */
  readonly filterSuppliedId?: string;

  /**
   * Parent ID to filter on. Sending null will return items without a parent.
   * @type {string}
   * @memberof SceneItemsApiGetSceneItems
   */
  readonly filterParent?: string;

  /**
   * Filter scene-items based on whether they are the parent of at least one other scene-item
   * @type {boolean}
   * @memberof SceneItemsApiGetSceneItems
   */
  readonly filterHasChildren?: boolean;

  /**
   * Filter scene-items based on whether they have an associated geometry-set.
   * @type {boolean}
   * @memberof SceneItemsApiGetSceneItems
   */
  readonly filterHasGeometrySet?: boolean;

  /**
   * A sort to apply to the collection. A \&quot;minus\&quot; prefixed before the field name is used to specify descending sort order.
   * @type {string}
   * @memberof SceneItemsApiGetSceneItems
   */
  readonly sort?: string;
}

/**
 * Request parameters for updateSceneItem operation in SceneItemsApi.
 * @export
 * @interface SceneItemsApiUpdateSceneItemRequest
 */
export interface SceneItemsApiUpdateSceneItemRequest {
  /**
   * The &#x60;scene-item&#x60; ID.
   * @type {string}
   * @memberof SceneItemsApiUpdateSceneItem
   */
  readonly id: string;

  /**
   *
   * @type {UpdateSceneItemRequest}
   * @memberof SceneItemsApiUpdateSceneItem
   */
  readonly updateSceneItemRequest: UpdateSceneItemRequest;
}

/**
 * SceneItemsApi - object-oriented interface
 * @export
 * @class SceneItemsApi
 * @extends {BaseAPI}
 */
export class SceneItemsApi extends BaseAPI {
  /**
   * Create a `scene-item` for a `scene`. Provide the source geometry either via `part-revision` or `geometry-set` UUID using `relationship.source` or by supplied IDs using `attributes.source`. Provide an existing `scene` using `relationship.source` to clone it. Provide the hierarchical parent either via `scene-item` UUID using `relationship.source` or by supplied ID using `attributes.parent`. To reduce the time taken creating many hierarchical `scene-items`, make a best effort to create parents before children. One way to do this is by sorting the items by depth and starting at the root. This API is asynchronous, returning the location of a `queued-scene-item`. Check the status via the getQueuedSceneItem API. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
   * @param {SceneItemsApiCreateSceneItemRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemsApi
   */
  public createSceneItem(
    requestParameters: SceneItemsApiCreateSceneItemRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneItemsApiFp(this.configuration)
      .createSceneItem(
        requestParameters.id,
        requestParameters.createSceneItemRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a `scene-item`.
   * @param {SceneItemsApiDeleteSceneItemRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemsApi
   */
  public deleteSceneItem(
    requestParameters: SceneItemsApiDeleteSceneItemRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneItemsApiFp(this.configuration)
      .deleteSceneItem(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `queued-scene-item`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `scene-item`. Once created, commit the scene via the updateScene API. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
   * @param {SceneItemsApiGetQueuedSceneItemRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemsApi
   */
  public getQueuedSceneItem(
    requestParameters: SceneItemsApiGetQueuedSceneItemRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneItemsApiFp(this.configuration)
      .getQueuedSceneItem(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `queued-scene-item-deletion` by ID.
   * @param {SceneItemsApiGetQueuedSceneItemDeletionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemsApi
   */
  public getQueuedSceneItemDeletion(
    requestParameters: SceneItemsApiGetQueuedSceneItemDeletionRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneItemsApiFp(this.configuration)
      .getQueuedSceneItemDeletion(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `scene-item` by ID.
   * @param {SceneItemsApiGetSceneItemRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemsApi
   */
  public getSceneItem(
    requestParameters: SceneItemsApiGetSceneItemRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneItemsApiFp(this.configuration)
      .getSceneItem(
        requestParameters.id,
        requestParameters.fieldsSceneItem,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get `scene-items` for a `scene`.
   * @param {SceneItemsApiGetSceneItemsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemsApi
   */
  public getSceneItems(
    requestParameters: SceneItemsApiGetSceneItemsRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneItemsApiFp(this.configuration)
      .getSceneItems(
        requestParameters.id,
        requestParameters.pageCursor,
        requestParameters.pageSize,
        requestParameters.filterSource,
        requestParameters.filterSuppliedId,
        requestParameters.filterParent,
        requestParameters.filterHasChildren,
        requestParameters.filterHasGeometrySet,
        requestParameters.sort,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update a `scene-item`.
   * @param {SceneItemsApiUpdateSceneItemRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemsApi
   */
  public updateSceneItem(
    requestParameters: SceneItemsApiUpdateSceneItemRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneItemsApiFp(this.configuration)
      .updateSceneItem(
        requestParameters.id,
        requestParameters.updateSceneItemRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SceneSynchronizationsApi - axios parameter creator
 * @export
 */
export const SceneSynchronizationsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a scene item update job.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneSyncRequest} createSceneSyncRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneSync: async (
      id: string,
      createSceneSyncRequest: CreateSceneSyncRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createSceneSync', 'id', id);
      // verify required parameter 'createSceneSyncRequest' is not null or undefined
      assertParamExists(
        'createSceneSync',
        'createSceneSyncRequest',
        createSceneSyncRequest
      );
      const localVarPath = `/scenes/{id}/scene-syncs`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createSceneSyncRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `queued-scene-sync-job`.
     * @param {string} id The &#x60;queued-scene-sync&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedSceneSync: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getQueuedSceneSync', 'id', id);
      const localVarPath = `/queued-scene-syncs/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `scene-sync`.
     * @param {string} id The &#x60;scene-sync&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneSync: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getSceneSync', 'id', id);
      const localVarPath = `/scene-syncs/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the results of a scene synchronization.
     * @param {string} id The &#x60;scene-sync&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSceneItemId] List of scene item IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneSyncItemResults: async (
      id: string,
      pageCursor?: string,
      pageSize?: number,
      filterSceneItemId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getSceneSyncItemResults', 'id', id);
      const localVarPath = `/scene-syncs/{id}/item-results`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (filterSceneItemId !== undefined) {
        localVarQueryParameter['filter[sceneItemId]'] = filterSceneItemId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SceneSynchronizationsApi - functional programming interface
 * @export
 */
export const SceneSynchronizationsApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    SceneSynchronizationsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a scene item update job.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneSyncRequest} createSceneSyncRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneSync(
      id: string,
      createSceneSyncRequest: CreateSceneSyncRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createSceneSync(
        id,
        createSceneSyncRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `queued-scene-sync-job`.
     * @param {string} id The &#x60;queued-scene-sync&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedSceneSync(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getQueuedSceneSync(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `scene-sync`.
     * @param {string} id The &#x60;scene-sync&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneSync(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneSync>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSceneSync(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get the results of a scene synchronization.
     * @param {string} id The &#x60;scene-sync&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSceneItemId] List of scene item IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneSyncItemResults(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      filterSceneItemId?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneSyncItemResultsList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSceneSyncItemResults(
          id,
          pageCursor,
          pageSize,
          filterSceneItemId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SceneSynchronizationsApi - factory interface
 * @export
 */
export const SceneSynchronizationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SceneSynchronizationsApiFp(configuration);
  return {
    /**
     * Create a scene item update job.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneSyncRequest} createSceneSyncRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneSync(
      id: string,
      createSceneSyncRequest: CreateSceneSyncRequest,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return localVarFp
        .createSceneSync(id, createSceneSyncRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `queued-scene-sync-job`.
     * @param {string} id The &#x60;queued-scene-sync&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedSceneSync(id: string, options?: any): AxiosPromise<QueuedJob> {
      return localVarFp
        .getQueuedSceneSync(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `scene-sync`.
     * @param {string} id The &#x60;scene-sync&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneSync(id: string, options?: any): AxiosPromise<SceneSync> {
      return localVarFp
        .getSceneSync(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the results of a scene synchronization.
     * @param {string} id The &#x60;scene-sync&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSceneItemId] List of scene item IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneSyncItemResults(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      filterSceneItemId?: string,
      options?: any
    ): AxiosPromise<SceneSyncItemResultsList> {
      return localVarFp
        .getSceneSyncItemResults(
          id,
          pageCursor,
          pageSize,
          filterSceneItemId,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createSceneSync operation in SceneSynchronizationsApi.
 * @export
 * @interface SceneSynchronizationsApiCreateSceneSyncRequest
 */
export interface SceneSynchronizationsApiCreateSceneSyncRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof SceneSynchronizationsApiCreateSceneSync
   */
  readonly id: string;

  /**
   *
   * @type {CreateSceneSyncRequest}
   * @memberof SceneSynchronizationsApiCreateSceneSync
   */
  readonly createSceneSyncRequest: CreateSceneSyncRequest;
}

/**
 * Request parameters for getQueuedSceneSync operation in SceneSynchronizationsApi.
 * @export
 * @interface SceneSynchronizationsApiGetQueuedSceneSyncRequest
 */
export interface SceneSynchronizationsApiGetQueuedSceneSyncRequest {
  /**
   * The &#x60;queued-scene-sync&#x60; ID.
   * @type {string}
   * @memberof SceneSynchronizationsApiGetQueuedSceneSync
   */
  readonly id: string;
}

/**
 * Request parameters for getSceneSync operation in SceneSynchronizationsApi.
 * @export
 * @interface SceneSynchronizationsApiGetSceneSyncRequest
 */
export interface SceneSynchronizationsApiGetSceneSyncRequest {
  /**
   * The &#x60;scene-sync&#x60; ID.
   * @type {string}
   * @memberof SceneSynchronizationsApiGetSceneSync
   */
  readonly id: string;
}

/**
 * Request parameters for getSceneSyncItemResults operation in SceneSynchronizationsApi.
 * @export
 * @interface SceneSynchronizationsApiGetSceneSyncItemResultsRequest
 */
export interface SceneSynchronizationsApiGetSceneSyncItemResultsRequest {
  /**
   * The &#x60;scene-sync&#x60; ID.
   * @type {string}
   * @memberof SceneSynchronizationsApiGetSceneSyncItemResults
   */
  readonly id: string;

  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof SceneSynchronizationsApiGetSceneSyncItemResults
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof SceneSynchronizationsApiGetSceneSyncItemResults
   */
  readonly pageSize?: number;

  /**
   * List of scene item IDs to filter on.
   * @type {string}
   * @memberof SceneSynchronizationsApiGetSceneSyncItemResults
   */
  readonly filterSceneItemId?: string;
}

/**
 * SceneSynchronizationsApi - object-oriented interface
 * @export
 * @class SceneSynchronizationsApi
 * @extends {BaseAPI}
 */
export class SceneSynchronizationsApi extends BaseAPI {
  /**
   * Create a scene item update job.
   * @param {SceneSynchronizationsApiCreateSceneSyncRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneSynchronizationsApi
   */
  public createSceneSync(
    requestParameters: SceneSynchronizationsApiCreateSceneSyncRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneSynchronizationsApiFp(this.configuration)
      .createSceneSync(
        requestParameters.id,
        requestParameters.createSceneSyncRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `queued-scene-sync-job`.
   * @param {SceneSynchronizationsApiGetQueuedSceneSyncRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneSynchronizationsApi
   */
  public getQueuedSceneSync(
    requestParameters: SceneSynchronizationsApiGetQueuedSceneSyncRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneSynchronizationsApiFp(this.configuration)
      .getQueuedSceneSync(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `scene-sync`.
   * @param {SceneSynchronizationsApiGetSceneSyncRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneSynchronizationsApi
   */
  public getSceneSync(
    requestParameters: SceneSynchronizationsApiGetSceneSyncRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneSynchronizationsApiFp(this.configuration)
      .getSceneSync(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the results of a scene synchronization.
   * @param {SceneSynchronizationsApiGetSceneSyncItemResultsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneSynchronizationsApi
   */
  public getSceneSyncItemResults(
    requestParameters: SceneSynchronizationsApiGetSceneSyncItemResultsRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneSynchronizationsApiFp(this.configuration)
      .getSceneSyncItemResults(
        requestParameters.id,
        requestParameters.pageCursor,
        requestParameters.pageSize,
        requestParameters.filterSceneItemId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SceneViewStatesApi - axios parameter creator
 * @export
 */
export const SceneViewStatesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a `scene-view-state` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneViewStateRequest} createSceneViewStateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneViewState: async (
      id: string,
      createSceneViewStateRequest: CreateSceneViewStateRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createSceneViewState', 'id', id);
      // verify required parameter 'createSceneViewStateRequest' is not null or undefined
      assertParamExists(
        'createSceneViewState',
        'createSceneViewStateRequest',
        createSceneViewStateRequest
      );
      const localVarPath = `/scenes/{id}/scene-view-states`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createSceneViewStateRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a `scene-view-state`.
     * @param {string} id The &#x60;scene-view-state&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSceneViewState: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteSceneViewState', 'id', id);
      const localVarPath = `/scene-view-states/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `scene-view-state` by ID.
     * @param {string} id The &#x60;scene-view-state&#x60; ID.
     * @param {string} [fieldsSceneViewState] Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;thumbnails&#x60; is only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneViewState: async (
      id: string,
      fieldsSceneViewState?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getSceneViewState', 'id', id);
      const localVarPath = `/scene-view-states/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (fieldsSceneViewState !== undefined) {
        localVarQueryParameter['fields[scene-view-state]'] =
          fieldsSceneViewState;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get `scene-view-states` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [fieldsSceneViewState] Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;thumbnails&#x60; is only returned if explicitly requested.
     * @param {string} [filterId] Comma-separated list of IDs to filter on.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneViewStates: async (
      id: string,
      pageCursor?: string,
      pageSize?: number,
      fieldsSceneViewState?: string,
      filterId?: string,
      filterSuppliedId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getSceneViewStates', 'id', id);
      const localVarPath = `/scenes/{id}/scene-view-states`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (fieldsSceneViewState !== undefined) {
        localVarQueryParameter['fields[scene-view-state]'] =
          fieldsSceneViewState;
      }

      if (filterId !== undefined) {
        localVarQueryParameter['filter[id]'] = filterId;
      }

      if (filterSuppliedId !== undefined) {
        localVarQueryParameter['filter[suppliedId]'] = filterSuppliedId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a `scene-view-state`.
     * @param {string} id The &#x60;scene-view-state&#x60; ID.
     * @param {UpdateSceneViewStateRequest} updateSceneViewStateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneViewState: async (
      id: string,
      updateSceneViewStateRequest: UpdateSceneViewStateRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateSceneViewState', 'id', id);
      // verify required parameter 'updateSceneViewStateRequest' is not null or undefined
      assertParamExists(
        'updateSceneViewState',
        'updateSceneViewStateRequest',
        updateSceneViewStateRequest
      );
      const localVarPath = `/scene-view-states/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateSceneViewStateRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SceneViewStatesApi - functional programming interface
 * @export
 */
export const SceneViewStatesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SceneViewStatesApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a `scene-view-state` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneViewStateRequest} createSceneViewStateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneViewState(
      id: string,
      createSceneViewStateRequest: CreateSceneViewStateRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneViewState>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createSceneViewState(
          id,
          createSceneViewStateRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete a `scene-view-state`.
     * @param {string} id The &#x60;scene-view-state&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSceneViewState(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteSceneViewState(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `scene-view-state` by ID.
     * @param {string} id The &#x60;scene-view-state&#x60; ID.
     * @param {string} [fieldsSceneViewState] Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;thumbnails&#x60; is only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneViewState(
      id: string,
      fieldsSceneViewState?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneViewState>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSceneViewState(
          id,
          fieldsSceneViewState,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get `scene-view-states` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [fieldsSceneViewState] Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;thumbnails&#x60; is only returned if explicitly requested.
     * @param {string} [filterId] Comma-separated list of IDs to filter on.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneViewStates(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      fieldsSceneViewState?: string,
      filterId?: string,
      filterSuppliedId?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneViewStateList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSceneViewStates(
          id,
          pageCursor,
          pageSize,
          fieldsSceneViewState,
          filterId,
          filterSuppliedId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update a `scene-view-state`.
     * @param {string} id The &#x60;scene-view-state&#x60; ID.
     * @param {UpdateSceneViewStateRequest} updateSceneViewStateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSceneViewState(
      id: string,
      updateSceneViewStateRequest: UpdateSceneViewStateRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneViewState>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateSceneViewState(
          id,
          updateSceneViewStateRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SceneViewStatesApi - factory interface
 * @export
 */
export const SceneViewStatesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SceneViewStatesApiFp(configuration);
  return {
    /**
     * Create a `scene-view-state` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneViewStateRequest} createSceneViewStateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneViewState(
      id: string,
      createSceneViewStateRequest: CreateSceneViewStateRequest,
      options?: any
    ): AxiosPromise<SceneViewState> {
      return localVarFp
        .createSceneViewState(id, createSceneViewStateRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a `scene-view-state`.
     * @param {string} id The &#x60;scene-view-state&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSceneViewState(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteSceneViewState(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `scene-view-state` by ID.
     * @param {string} id The &#x60;scene-view-state&#x60; ID.
     * @param {string} [fieldsSceneViewState] Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;thumbnails&#x60; is only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneViewState(
      id: string,
      fieldsSceneViewState?: string,
      options?: any
    ): AxiosPromise<SceneViewState> {
      return localVarFp
        .getSceneViewState(id, fieldsSceneViewState, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get `scene-view-states` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [fieldsSceneViewState] Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;thumbnails&#x60; is only returned if explicitly requested.
     * @param {string} [filterId] Comma-separated list of IDs to filter on.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneViewStates(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      fieldsSceneViewState?: string,
      filterId?: string,
      filterSuppliedId?: string,
      options?: any
    ): AxiosPromise<SceneViewStateList> {
      return localVarFp
        .getSceneViewStates(
          id,
          pageCursor,
          pageSize,
          fieldsSceneViewState,
          filterId,
          filterSuppliedId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Update a `scene-view-state`.
     * @param {string} id The &#x60;scene-view-state&#x60; ID.
     * @param {UpdateSceneViewStateRequest} updateSceneViewStateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneViewState(
      id: string,
      updateSceneViewStateRequest: UpdateSceneViewStateRequest,
      options?: any
    ): AxiosPromise<SceneViewState> {
      return localVarFp
        .updateSceneViewState(id, updateSceneViewStateRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createSceneViewState operation in SceneViewStatesApi.
 * @export
 * @interface SceneViewStatesApiCreateSceneViewStateRequest
 */
export interface SceneViewStatesApiCreateSceneViewStateRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof SceneViewStatesApiCreateSceneViewState
   */
  readonly id: string;

  /**
   *
   * @type {CreateSceneViewStateRequest}
   * @memberof SceneViewStatesApiCreateSceneViewState
   */
  readonly createSceneViewStateRequest: CreateSceneViewStateRequest;
}

/**
 * Request parameters for deleteSceneViewState operation in SceneViewStatesApi.
 * @export
 * @interface SceneViewStatesApiDeleteSceneViewStateRequest
 */
export interface SceneViewStatesApiDeleteSceneViewStateRequest {
  /**
   * The &#x60;scene-view-state&#x60; ID.
   * @type {string}
   * @memberof SceneViewStatesApiDeleteSceneViewState
   */
  readonly id: string;
}

/**
 * Request parameters for getSceneViewState operation in SceneViewStatesApi.
 * @export
 * @interface SceneViewStatesApiGetSceneViewStateRequest
 */
export interface SceneViewStatesApiGetSceneViewStateRequest {
  /**
   * The &#x60;scene-view-state&#x60; ID.
   * @type {string}
   * @memberof SceneViewStatesApiGetSceneViewState
   */
  readonly id: string;

  /**
   * Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;thumbnails&#x60; is only returned if explicitly requested.
   * @type {string}
   * @memberof SceneViewStatesApiGetSceneViewState
   */
  readonly fieldsSceneViewState?: string;
}

/**
 * Request parameters for getSceneViewStates operation in SceneViewStatesApi.
 * @export
 * @interface SceneViewStatesApiGetSceneViewStatesRequest
 */
export interface SceneViewStatesApiGetSceneViewStatesRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof SceneViewStatesApiGetSceneViewStates
   */
  readonly id: string;

  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof SceneViewStatesApiGetSceneViewStates
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof SceneViewStatesApiGetSceneViewStates
   */
  readonly pageSize?: number;

  /**
   * Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;thumbnails&#x60; is only returned if explicitly requested.
   * @type {string}
   * @memberof SceneViewStatesApiGetSceneViewStates
   */
  readonly fieldsSceneViewState?: string;

  /**
   * Comma-separated list of IDs to filter on.
   * @type {string}
   * @memberof SceneViewStatesApiGetSceneViewStates
   */
  readonly filterId?: string;

  /**
   * Comma-separated list of supplied IDs to filter on.
   * @type {string}
   * @memberof SceneViewStatesApiGetSceneViewStates
   */
  readonly filterSuppliedId?: string;
}

/**
 * Request parameters for updateSceneViewState operation in SceneViewStatesApi.
 * @export
 * @interface SceneViewStatesApiUpdateSceneViewStateRequest
 */
export interface SceneViewStatesApiUpdateSceneViewStateRequest {
  /**
   * The &#x60;scene-view-state&#x60; ID.
   * @type {string}
   * @memberof SceneViewStatesApiUpdateSceneViewState
   */
  readonly id: string;

  /**
   *
   * @type {UpdateSceneViewStateRequest}
   * @memberof SceneViewStatesApiUpdateSceneViewState
   */
  readonly updateSceneViewStateRequest: UpdateSceneViewStateRequest;
}

/**
 * SceneViewStatesApi - object-oriented interface
 * @export
 * @class SceneViewStatesApi
 * @extends {BaseAPI}
 */
export class SceneViewStatesApi extends BaseAPI {
  /**
   * Create a `scene-view-state` for a `scene`.
   * @param {SceneViewStatesApiCreateSceneViewStateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewStatesApi
   */
  public createSceneViewState(
    requestParameters: SceneViewStatesApiCreateSceneViewStateRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneViewStatesApiFp(this.configuration)
      .createSceneViewState(
        requestParameters.id,
        requestParameters.createSceneViewStateRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a `scene-view-state`.
   * @param {SceneViewStatesApiDeleteSceneViewStateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewStatesApi
   */
  public deleteSceneViewState(
    requestParameters: SceneViewStatesApiDeleteSceneViewStateRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneViewStatesApiFp(this.configuration)
      .deleteSceneViewState(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `scene-view-state` by ID.
   * @param {SceneViewStatesApiGetSceneViewStateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewStatesApi
   */
  public getSceneViewState(
    requestParameters: SceneViewStatesApiGetSceneViewStateRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneViewStatesApiFp(this.configuration)
      .getSceneViewState(
        requestParameters.id,
        requestParameters.fieldsSceneViewState,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get `scene-view-states` for a `scene`.
   * @param {SceneViewStatesApiGetSceneViewStatesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewStatesApi
   */
  public getSceneViewStates(
    requestParameters: SceneViewStatesApiGetSceneViewStatesRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneViewStatesApiFp(this.configuration)
      .getSceneViewStates(
        requestParameters.id,
        requestParameters.pageCursor,
        requestParameters.pageSize,
        requestParameters.fieldsSceneViewState,
        requestParameters.filterId,
        requestParameters.filterSuppliedId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update a `scene-view-state`.
   * @param {SceneViewStatesApiUpdateSceneViewStateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewStatesApi
   */
  public updateSceneViewState(
    requestParameters: SceneViewStatesApiUpdateSceneViewStateRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneViewStatesApiFp(this.configuration)
      .updateSceneViewState(
        requestParameters.id,
        requestParameters.updateSceneViewStateRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SceneViewsApi - axios parameter creator
 * @export
 */
export const SceneViewsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a `scene-view` of a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneViewRequest} createSceneViewRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneView: async (
      id: string,
      createSceneViewRequest: CreateSceneViewRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createSceneView', 'id', id);
      // verify required parameter 'createSceneViewRequest' is not null or undefined
      assertParamExists(
        'createSceneView',
        'createSceneViewRequest',
        createSceneViewRequest
      );
      const localVarPath = `/scenes/{id}/scene-views`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createSceneViewRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSceneView: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteSceneView', 'id', id);
      const localVarPath = `/scene-views/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `scene-view` by ID.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneView: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getSceneView', 'id', id);
      const localVarPath = `/scene-views/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get `scene-view`s for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneViews: async (
      id: string,
      pageCursor?: string,
      pageSize?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getSceneViews', 'id', id);
      const localVarPath = `/scenes/{id}/scene-views`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `scene-item` within a view by ID.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {string} itemId The &#x60;scene-item&#x60; ID.
     * @param {string} [fieldsSceneItem] Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;boundingBox&#x60;, &#x60;worldTransform&#x60; and &#x60;metadata&#x60; are only returned if explicitly requested.
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getViewSceneItem: async (
      id: string,
      itemId: string,
      fieldsSceneItem?: string,
      include?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getViewSceneItem', 'id', id);
      // verify required parameter 'itemId' is not null or undefined
      assertParamExists('getViewSceneItem', 'itemId', itemId);
      const localVarPath = `/scene-views/{id}/scene-items/{itemId}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'itemId'}}`, encodeURIComponent(String(itemId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (fieldsSceneItem !== undefined) {
        localVarQueryParameter['fields[scene-item]'] = fieldsSceneItem;
      }

      if (include !== undefined) {
        localVarQueryParameter['include'] = include;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a rendered image of a `scene-view`. If a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {number} [height] The height of the image to render.
     * @param {number} [width] The width of the image to render.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    renderSceneView: async (
      id: string,
      height?: number,
      width?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('renderSceneView', 'id', id);
      const localVarPath = `/scene-views/{id}/image`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (height !== undefined) {
        localVarQueryParameter['height'] = height;
      }

      if (width !== undefined) {
        localVarQueryParameter['width'] = width;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {UpdateSceneViewRequest} updateSceneViewRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneView: async (
      id: string,
      updateSceneViewRequest: UpdateSceneViewRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateSceneView', 'id', id);
      // verify required parameter 'updateSceneViewRequest' is not null or undefined
      assertParamExists(
        'updateSceneView',
        'updateSceneViewRequest',
        updateSceneViewRequest
      );
      const localVarPath = `/scene-views/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateSceneViewRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SceneViewsApi - functional programming interface
 * @export
 */
export const SceneViewsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SceneViewsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a `scene-view` of a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneViewRequest} createSceneViewRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneView(
      id: string,
      createSceneViewRequest: CreateSceneViewRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneView>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createSceneView(
        id,
        createSceneViewRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSceneView(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSceneView(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `scene-view` by ID.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneView(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneView>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSceneView(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get `scene-view`s for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneViews(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneViewList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSceneViews(
        id,
        pageCursor,
        pageSize,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `scene-item` within a view by ID.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {string} itemId The &#x60;scene-item&#x60; ID.
     * @param {string} [fieldsSceneItem] Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;boundingBox&#x60;, &#x60;worldTransform&#x60; and &#x60;metadata&#x60; are only returned if explicitly requested.
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getViewSceneItem(
      id: string,
      itemId: string,
      fieldsSceneItem?: string,
      include?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneViewItem>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getViewSceneItem(
          id,
          itemId,
          fieldsSceneItem,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a rendered image of a `scene-view`. If a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {number} [height] The height of the image to render.
     * @param {number} [width] The width of the image to render.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async renderSceneView(
      id: string,
      height?: number,
      width?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.renderSceneView(
        id,
        height,
        width,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {UpdateSceneViewRequest} updateSceneViewRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSceneView(
      id: string,
      updateSceneViewRequest: UpdateSceneViewRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneView>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateSceneView(
        id,
        updateSceneViewRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SceneViewsApi - factory interface
 * @export
 */
export const SceneViewsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SceneViewsApiFp(configuration);
  return {
    /**
     * Create a `scene-view` of a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneViewRequest} createSceneViewRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneView(
      id: string,
      createSceneViewRequest: CreateSceneViewRequest,
      options?: any
    ): AxiosPromise<SceneView> {
      return localVarFp
        .createSceneView(id, createSceneViewRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSceneView(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteSceneView(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `scene-view` by ID.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneView(id: string, options?: any): AxiosPromise<SceneView> {
      return localVarFp
        .getSceneView(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get `scene-view`s for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneViews(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<SceneViewList> {
      return localVarFp
        .getSceneViews(id, pageCursor, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `scene-item` within a view by ID.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {string} itemId The &#x60;scene-item&#x60; ID.
     * @param {string} [fieldsSceneItem] Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;boundingBox&#x60;, &#x60;worldTransform&#x60; and &#x60;metadata&#x60; are only returned if explicitly requested.
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getViewSceneItem(
      id: string,
      itemId: string,
      fieldsSceneItem?: string,
      include?: string,
      options?: any
    ): AxiosPromise<SceneViewItem> {
      return localVarFp
        .getViewSceneItem(id, itemId, fieldsSceneItem, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a rendered image of a `scene-view`. If a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {number} [height] The height of the image to render.
     * @param {number} [width] The width of the image to render.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    renderSceneView(
      id: string,
      height?: number,
      width?: number,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .renderSceneView(id, height, width, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {UpdateSceneViewRequest} updateSceneViewRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneView(
      id: string,
      updateSceneViewRequest: UpdateSceneViewRequest,
      options?: any
    ): AxiosPromise<SceneView> {
      return localVarFp
        .updateSceneView(id, updateSceneViewRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createSceneView operation in SceneViewsApi.
 * @export
 * @interface SceneViewsApiCreateSceneViewRequest
 */
export interface SceneViewsApiCreateSceneViewRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof SceneViewsApiCreateSceneView
   */
  readonly id: string;

  /**
   *
   * @type {CreateSceneViewRequest}
   * @memberof SceneViewsApiCreateSceneView
   */
  readonly createSceneViewRequest: CreateSceneViewRequest;
}

/**
 * Request parameters for deleteSceneView operation in SceneViewsApi.
 * @export
 * @interface SceneViewsApiDeleteSceneViewRequest
 */
export interface SceneViewsApiDeleteSceneViewRequest {
  /**
   * The &#x60;scene-view&#x60; ID.
   * @type {string}
   * @memberof SceneViewsApiDeleteSceneView
   */
  readonly id: string;
}

/**
 * Request parameters for getSceneView operation in SceneViewsApi.
 * @export
 * @interface SceneViewsApiGetSceneViewRequest
 */
export interface SceneViewsApiGetSceneViewRequest {
  /**
   * The &#x60;scene-view&#x60; ID.
   * @type {string}
   * @memberof SceneViewsApiGetSceneView
   */
  readonly id: string;
}

/**
 * Request parameters for getSceneViews operation in SceneViewsApi.
 * @export
 * @interface SceneViewsApiGetSceneViewsRequest
 */
export interface SceneViewsApiGetSceneViewsRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof SceneViewsApiGetSceneViews
   */
  readonly id: string;

  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof SceneViewsApiGetSceneViews
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof SceneViewsApiGetSceneViews
   */
  readonly pageSize?: number;
}

/**
 * Request parameters for getViewSceneItem operation in SceneViewsApi.
 * @export
 * @interface SceneViewsApiGetViewSceneItemRequest
 */
export interface SceneViewsApiGetViewSceneItemRequest {
  /**
   * The &#x60;scene-view&#x60; ID.
   * @type {string}
   * @memberof SceneViewsApiGetViewSceneItem
   */
  readonly id: string;

  /**
   * The &#x60;scene-item&#x60; ID.
   * @type {string}
   * @memberof SceneViewsApiGetViewSceneItem
   */
  readonly itemId: string;

  /**
   * Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;boundingBox&#x60;, &#x60;worldTransform&#x60; and &#x60;metadata&#x60; are only returned if explicitly requested.
   * @type {string}
   * @memberof SceneViewsApiGetViewSceneItem
   */
  readonly fieldsSceneItem?: string;

  /**
   * Comma-separated list of relationships to include in response.
   * @type {string}
   * @memberof SceneViewsApiGetViewSceneItem
   */
  readonly include?: string;
}

/**
 * Request parameters for renderSceneView operation in SceneViewsApi.
 * @export
 * @interface SceneViewsApiRenderSceneViewRequest
 */
export interface SceneViewsApiRenderSceneViewRequest {
  /**
   * The &#x60;scene-view&#x60; ID.
   * @type {string}
   * @memberof SceneViewsApiRenderSceneView
   */
  readonly id: string;

  /**
   * The height of the image to render.
   * @type {number}
   * @memberof SceneViewsApiRenderSceneView
   */
  readonly height?: number;

  /**
   * The width of the image to render.
   * @type {number}
   * @memberof SceneViewsApiRenderSceneView
   */
  readonly width?: number;
}

/**
 * Request parameters for updateSceneView operation in SceneViewsApi.
 * @export
 * @interface SceneViewsApiUpdateSceneViewRequest
 */
export interface SceneViewsApiUpdateSceneViewRequest {
  /**
   * The &#x60;scene-view&#x60; ID.
   * @type {string}
   * @memberof SceneViewsApiUpdateSceneView
   */
  readonly id: string;

  /**
   *
   * @type {UpdateSceneViewRequest}
   * @memberof SceneViewsApiUpdateSceneView
   */
  readonly updateSceneViewRequest: UpdateSceneViewRequest;
}

/**
 * SceneViewsApi - object-oriented interface
 * @export
 * @class SceneViewsApi
 * @extends {BaseAPI}
 */
export class SceneViewsApi extends BaseAPI {
  /**
   * Create a `scene-view` of a `scene`.
   * @param {SceneViewsApiCreateSceneViewRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewsApi
   */
  public createSceneView(
    requestParameters: SceneViewsApiCreateSceneViewRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneViewsApiFp(this.configuration)
      .createSceneView(
        requestParameters.id,
        requestParameters.createSceneViewRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a `scene-view`.
   * @param {SceneViewsApiDeleteSceneViewRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewsApi
   */
  public deleteSceneView(
    requestParameters: SceneViewsApiDeleteSceneViewRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneViewsApiFp(this.configuration)
      .deleteSceneView(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `scene-view` by ID.
   * @param {SceneViewsApiGetSceneViewRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewsApi
   */
  public getSceneView(
    requestParameters: SceneViewsApiGetSceneViewRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneViewsApiFp(this.configuration)
      .getSceneView(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get `scene-view`s for a `scene`.
   * @param {SceneViewsApiGetSceneViewsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewsApi
   */
  public getSceneViews(
    requestParameters: SceneViewsApiGetSceneViewsRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneViewsApiFp(this.configuration)
      .getSceneViews(
        requestParameters.id,
        requestParameters.pageCursor,
        requestParameters.pageSize,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `scene-item` within a view by ID.
   * @param {SceneViewsApiGetViewSceneItemRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewsApi
   */
  public getViewSceneItem(
    requestParameters: SceneViewsApiGetViewSceneItemRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneViewsApiFp(this.configuration)
      .getViewSceneItem(
        requestParameters.id,
        requestParameters.itemId,
        requestParameters.fieldsSceneItem,
        requestParameters.include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a rendered image of a `scene-view`. If a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
   * @param {SceneViewsApiRenderSceneViewRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewsApi
   */
  public renderSceneView(
    requestParameters: SceneViewsApiRenderSceneViewRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneViewsApiFp(this.configuration)
      .renderSceneView(
        requestParameters.id,
        requestParameters.height,
        requestParameters.width,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update a `scene-view`.
   * @param {SceneViewsApiUpdateSceneViewRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewsApi
   */
  public updateSceneView(
    requestParameters: SceneViewsApiUpdateSceneViewRequest,
    options?: AxiosRequestConfig
  ) {
    return SceneViewsApiFp(this.configuration)
      .updateSceneView(
        requestParameters.id,
        requestParameters.updateSceneViewRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ScenesApi - axios parameter creator
 * @export
 */
export const ScenesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a `scene`. Once created, add scene items via the createSceneItem API. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
     * @param {CreateSceneRequest} createSceneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createScene: async (
      createSceneRequest: CreateSceneRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createSceneRequest' is not null or undefined
      assertParamExists(
        'createScene',
        'createSceneRequest',
        createSceneRequest
      );
      const localVarPath = `/scenes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createSceneRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteScene: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteScene', 'id', id);
      const localVarPath = `/scenes/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `queued-scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedScene: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getQueuedScene', 'id', id);
      const localVarPath = `/queued-scenes/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `scene` by ID.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {string} [fieldsScene] Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;sceneItemCount&#x60; and &#x60;metadata&#x60; are only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScene: async (
      id: string,
      fieldsScene?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getScene', 'id', id);
      const localVarPath = `/scenes/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (fieldsScene !== undefined) {
        localVarQueryParameter['fields[scene]'] = fieldsScene;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get `scenes`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterName] Comma-separated list of names to filter on.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {string} [fieldsScene] Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;metadata&#x60; is only returned if explicitly requested.
     * @param {{ [key: string]: string; }} [filterMetadata] Filter scenes that contain all the given metadata key-value pairs. Should be specified in query parameter map notation: &#x60;filter[metadata][key1]&#x3D;value1&amp;filter[metadata][key]&#x3D;value2&#x60;.
     * @param {string} [filterSceneItemsSourcePartRevision] Comma-separated list of scene-item source part revision IDs to filter on.
     * @param {string} [filterSceneItemsSourceGeometrySet] Comma-separated list of scene-item source geometry set IDs to filter on.
     * @param {string} [filterSceneItemsSourceScene] Comma-separated list of scene-item source scene IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScenes: async (
      pageCursor?: string,
      pageSize?: number,
      filterName?: string,
      filterSuppliedId?: string,
      fieldsScene?: string,
      filterMetadata?: { [key: string]: string },
      filterSceneItemsSourcePartRevision?: string,
      filterSceneItemsSourceGeometrySet?: string,
      filterSceneItemsSourceScene?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/scenes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (filterName !== undefined) {
        localVarQueryParameter['filter[name]'] = filterName;
      }

      if (filterSuppliedId !== undefined) {
        localVarQueryParameter['filter[suppliedId]'] = filterSuppliedId;
      }

      if (fieldsScene !== undefined) {
        localVarQueryParameter['fields[scene]'] = fieldsScene;
      }

      if (filterMetadata !== undefined) {
        localVarQueryParameter['filter[metadata]'] = filterMetadata;
      }

      if (filterSceneItemsSourcePartRevision !== undefined) {
        localVarQueryParameter['filter[sceneItems.source.partRevision]'] =
          filterSceneItemsSourcePartRevision;
      }

      if (filterSceneItemsSourceGeometrySet !== undefined) {
        localVarQueryParameter['filter[sceneItems.source.geometrySet]'] =
          filterSceneItemsSourceGeometrySet;
      }

      if (filterSceneItemsSourceScene !== undefined) {
        localVarQueryParameter['filter[sceneItems.source.scene]'] =
          filterSceneItemsSourceScene;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a rendered image of a `scene`. If only a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {number} [height] The height of the image to render.
     * @param {number} [width] The width of the image to render.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    renderScene: async (
      id: string,
      height?: number,
      width?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('renderScene', 'id', id);
      const localVarPath = `/scenes/{id}/image`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (height !== undefined) {
        localVarQueryParameter['height'] = height;
      }

      if (width !== undefined) {
        localVarQueryParameter['width'] = width;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a `scene` camera and/or state. Once updated, view the scene via the renderScene API or with the Viewer SDK. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {UpdateSceneRequest} updateSceneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateScene: async (
      id: string,
      updateSceneRequest: UpdateSceneRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateScene', 'id', id);
      // verify required parameter 'updateSceneRequest' is not null or undefined
      assertParamExists(
        'updateScene',
        'updateSceneRequest',
        updateSceneRequest
      );
      const localVarPath = `/scenes/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateSceneRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ScenesApi - functional programming interface
 * @export
 */
export const ScenesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ScenesApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a `scene`. Once created, add scene items via the createSceneItem API. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
     * @param {CreateSceneRequest} createSceneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createScene(
      createSceneRequest: CreateSceneRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scene>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createScene(
        createSceneRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteScene(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScene(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `queued-scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedScene(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getQueuedScene(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `scene` by ID.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {string} [fieldsScene] Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;sceneItemCount&#x60; and &#x60;metadata&#x60; are only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getScene(
      id: string,
      fieldsScene?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scene>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getScene(
        id,
        fieldsScene,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get `scenes`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterName] Comma-separated list of names to filter on.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {string} [fieldsScene] Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;metadata&#x60; is only returned if explicitly requested.
     * @param {{ [key: string]: string; }} [filterMetadata] Filter scenes that contain all the given metadata key-value pairs. Should be specified in query parameter map notation: &#x60;filter[metadata][key1]&#x3D;value1&amp;filter[metadata][key]&#x3D;value2&#x60;.
     * @param {string} [filterSceneItemsSourcePartRevision] Comma-separated list of scene-item source part revision IDs to filter on.
     * @param {string} [filterSceneItemsSourceGeometrySet] Comma-separated list of scene-item source geometry set IDs to filter on.
     * @param {string} [filterSceneItemsSourceScene] Comma-separated list of scene-item source scene IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getScenes(
      pageCursor?: string,
      pageSize?: number,
      filterName?: string,
      filterSuppliedId?: string,
      fieldsScene?: string,
      filterMetadata?: { [key: string]: string },
      filterSceneItemsSourcePartRevision?: string,
      filterSceneItemsSourceGeometrySet?: string,
      filterSceneItemsSourceScene?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getScenes(
        pageCursor,
        pageSize,
        filterName,
        filterSuppliedId,
        fieldsScene,
        filterMetadata,
        filterSceneItemsSourcePartRevision,
        filterSceneItemsSourceGeometrySet,
        filterSceneItemsSourceScene,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a rendered image of a `scene`. If only a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {number} [height] The height of the image to render.
     * @param {number} [width] The width of the image to render.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async renderScene(
      id: string,
      height?: number,
      width?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.renderScene(
        id,
        height,
        width,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update a `scene` camera and/or state. Once updated, view the scene via the renderScene API or with the Viewer SDK. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {UpdateSceneRequest} updateSceneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateScene(
      id: string,
      updateSceneRequest: UpdateSceneRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scene>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateScene(
        id,
        updateSceneRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ScenesApi - factory interface
 * @export
 */
export const ScenesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ScenesApiFp(configuration);
  return {
    /**
     * Create a `scene`. Once created, add scene items via the createSceneItem API. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
     * @param {CreateSceneRequest} createSceneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createScene(
      createSceneRequest: CreateSceneRequest,
      options?: any
    ): AxiosPromise<Scene> {
      return localVarFp
        .createScene(createSceneRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteScene(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteScene(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `queued-scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedScene(id: string, options?: any): AxiosPromise<QueuedJob> {
      return localVarFp
        .getQueuedScene(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `scene` by ID.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {string} [fieldsScene] Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;sceneItemCount&#x60; and &#x60;metadata&#x60; are only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScene(
      id: string,
      fieldsScene?: string,
      options?: any
    ): AxiosPromise<Scene> {
      return localVarFp
        .getScene(id, fieldsScene, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get `scenes`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterName] Comma-separated list of names to filter on.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {string} [fieldsScene] Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;metadata&#x60; is only returned if explicitly requested.
     * @param {{ [key: string]: string; }} [filterMetadata] Filter scenes that contain all the given metadata key-value pairs. Should be specified in query parameter map notation: &#x60;filter[metadata][key1]&#x3D;value1&amp;filter[metadata][key]&#x3D;value2&#x60;.
     * @param {string} [filterSceneItemsSourcePartRevision] Comma-separated list of scene-item source part revision IDs to filter on.
     * @param {string} [filterSceneItemsSourceGeometrySet] Comma-separated list of scene-item source geometry set IDs to filter on.
     * @param {string} [filterSceneItemsSourceScene] Comma-separated list of scene-item source scene IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScenes(
      pageCursor?: string,
      pageSize?: number,
      filterName?: string,
      filterSuppliedId?: string,
      fieldsScene?: string,
      filterMetadata?: { [key: string]: string },
      filterSceneItemsSourcePartRevision?: string,
      filterSceneItemsSourceGeometrySet?: string,
      filterSceneItemsSourceScene?: string,
      options?: any
    ): AxiosPromise<SceneList> {
      return localVarFp
        .getScenes(
          pageCursor,
          pageSize,
          filterName,
          filterSuppliedId,
          fieldsScene,
          filterMetadata,
          filterSceneItemsSourcePartRevision,
          filterSceneItemsSourceGeometrySet,
          filterSceneItemsSourceScene,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a rendered image of a `scene`. If only a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {number} [height] The height of the image to render.
     * @param {number} [width] The width of the image to render.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    renderScene(
      id: string,
      height?: number,
      width?: number,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .renderScene(id, height, width, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update a `scene` camera and/or state. Once updated, view the scene via the renderScene API or with the Viewer SDK. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {UpdateSceneRequest} updateSceneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateScene(
      id: string,
      updateSceneRequest: UpdateSceneRequest,
      options?: any
    ): AxiosPromise<Scene> {
      return localVarFp
        .updateScene(id, updateSceneRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createScene operation in ScenesApi.
 * @export
 * @interface ScenesApiCreateSceneRequest
 */
export interface ScenesApiCreateSceneRequest {
  /**
   *
   * @type {CreateSceneRequest}
   * @memberof ScenesApiCreateScene
   */
  readonly createSceneRequest: CreateSceneRequest;
}

/**
 * Request parameters for deleteScene operation in ScenesApi.
 * @export
 * @interface ScenesApiDeleteSceneRequest
 */
export interface ScenesApiDeleteSceneRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof ScenesApiDeleteScene
   */
  readonly id: string;
}

/**
 * Request parameters for getQueuedScene operation in ScenesApi.
 * @export
 * @interface ScenesApiGetQueuedSceneRequest
 */
export interface ScenesApiGetQueuedSceneRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof ScenesApiGetQueuedScene
   */
  readonly id: string;
}

/**
 * Request parameters for getScene operation in ScenesApi.
 * @export
 * @interface ScenesApiGetSceneRequest
 */
export interface ScenesApiGetSceneRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof ScenesApiGetScene
   */
  readonly id: string;

  /**
   * Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;sceneItemCount&#x60; and &#x60;metadata&#x60; are only returned if explicitly requested.
   * @type {string}
   * @memberof ScenesApiGetScene
   */
  readonly fieldsScene?: string;
}

/**
 * Request parameters for getScenes operation in ScenesApi.
 * @export
 * @interface ScenesApiGetScenesRequest
 */
export interface ScenesApiGetScenesRequest {
  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof ScenesApiGetScenes
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof ScenesApiGetScenes
   */
  readonly pageSize?: number;

  /**
   * Comma-separated list of names to filter on.
   * @type {string}
   * @memberof ScenesApiGetScenes
   */
  readonly filterName?: string;

  /**
   * Comma-separated list of supplied IDs to filter on.
   * @type {string}
   * @memberof ScenesApiGetScenes
   */
  readonly filterSuppliedId?: string;

  /**
   * Comma-separated list of fields to return in response. An empty value returns no fields. &#x60;metadata&#x60; is only returned if explicitly requested.
   * @type {string}
   * @memberof ScenesApiGetScenes
   */
  readonly fieldsScene?: string;

  /**
   * Filter scenes that contain all the given metadata key-value pairs. Should be specified in query parameter map notation: &#x60;filter[metadata][key1]&#x3D;value1&amp;filter[metadata][key]&#x3D;value2&#x60;.
   * @type {{ [key: string]: string; }}
   * @memberof ScenesApiGetScenes
   */
  readonly filterMetadata?: { [key: string]: string };

  /**
   * Comma-separated list of scene-item source part revision IDs to filter on.
   * @type {string}
   * @memberof ScenesApiGetScenes
   */
  readonly filterSceneItemsSourcePartRevision?: string;

  /**
   * Comma-separated list of scene-item source geometry set IDs to filter on.
   * @type {string}
   * @memberof ScenesApiGetScenes
   */
  readonly filterSceneItemsSourceGeometrySet?: string;

  /**
   * Comma-separated list of scene-item source scene IDs to filter on.
   * @type {string}
   * @memberof ScenesApiGetScenes
   */
  readonly filterSceneItemsSourceScene?: string;
}

/**
 * Request parameters for renderScene operation in ScenesApi.
 * @export
 * @interface ScenesApiRenderSceneRequest
 */
export interface ScenesApiRenderSceneRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof ScenesApiRenderScene
   */
  readonly id: string;

  /**
   * The height of the image to render.
   * @type {number}
   * @memberof ScenesApiRenderScene
   */
  readonly height?: number;

  /**
   * The width of the image to render.
   * @type {number}
   * @memberof ScenesApiRenderScene
   */
  readonly width?: number;
}

/**
 * Request parameters for updateScene operation in ScenesApi.
 * @export
 * @interface ScenesApiUpdateSceneRequest
 */
export interface ScenesApiUpdateSceneRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof ScenesApiUpdateScene
   */
  readonly id: string;

  /**
   *
   * @type {UpdateSceneRequest}
   * @memberof ScenesApiUpdateScene
   */
  readonly updateSceneRequest: UpdateSceneRequest;
}

/**
 * ScenesApi - object-oriented interface
 * @export
 * @class ScenesApi
 * @extends {BaseAPI}
 */
export class ScenesApi extends BaseAPI {
  /**
   * Create a `scene`. Once created, add scene items via the createSceneItem API. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
   * @param {ScenesApiCreateSceneRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public createScene(
    requestParameters: ScenesApiCreateSceneRequest,
    options?: AxiosRequestConfig
  ) {
    return ScenesApiFp(this.configuration)
      .createScene(requestParameters.createSceneRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a `scene`.
   * @param {ScenesApiDeleteSceneRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public deleteScene(
    requestParameters: ScenesApiDeleteSceneRequest,
    options?: AxiosRequestConfig
  ) {
    return ScenesApiFp(this.configuration)
      .deleteScene(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `queued-scene`.
   * @param {ScenesApiGetQueuedSceneRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public getQueuedScene(
    requestParameters: ScenesApiGetQueuedSceneRequest,
    options?: AxiosRequestConfig
  ) {
    return ScenesApiFp(this.configuration)
      .getQueuedScene(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `scene` by ID.
   * @param {ScenesApiGetSceneRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public getScene(
    requestParameters: ScenesApiGetSceneRequest,
    options?: AxiosRequestConfig
  ) {
    return ScenesApiFp(this.configuration)
      .getScene(requestParameters.id, requestParameters.fieldsScene, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get `scenes`.
   * @param {ScenesApiGetScenesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public getScenes(
    requestParameters: ScenesApiGetScenesRequest = {},
    options?: AxiosRequestConfig
  ) {
    return ScenesApiFp(this.configuration)
      .getScenes(
        requestParameters.pageCursor,
        requestParameters.pageSize,
        requestParameters.filterName,
        requestParameters.filterSuppliedId,
        requestParameters.fieldsScene,
        requestParameters.filterMetadata,
        requestParameters.filterSceneItemsSourcePartRevision,
        requestParameters.filterSceneItemsSourceGeometrySet,
        requestParameters.filterSceneItemsSourceScene,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a rendered image of a `scene`. If only a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
   * @param {ScenesApiRenderSceneRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public renderScene(
    requestParameters: ScenesApiRenderSceneRequest,
    options?: AxiosRequestConfig
  ) {
    return ScenesApiFp(this.configuration)
      .renderScene(
        requestParameters.id,
        requestParameters.height,
        requestParameters.width,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update a `scene` camera and/or state. Once updated, view the scene via the renderScene API or with the Viewer SDK. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
   * @param {ScenesApiUpdateSceneRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public updateScene(
    requestParameters: ScenesApiUpdateSceneRequest,
    options?: AxiosRequestConfig
  ) {
    return ScenesApiFp(this.configuration)
      .updateScene(
        requestParameters.id,
        requestParameters.updateSceneRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SearchSessionsApi - axios parameter creator
 * @export
 */
export const SearchSessionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a `search-session`.
     * @param {CreateSearchSessionRequest} createSearchSessionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSearchSession: async (
      createSearchSessionRequest: CreateSearchSessionRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createSearchSessionRequest' is not null or undefined
      assertParamExists(
        'createSearchSession',
        'createSearchSessionRequest',
        createSearchSessionRequest
      );
      const localVarPath = `/search-sessions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createSearchSessionRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `search-session`.
     * @param {string} id The &#x60;search-session&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSearchSession: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getSearchSession', 'id', id);
      const localVarPath = `/search-sessions/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SearchSessionsApi - functional programming interface
 * @export
 */
export const SearchSessionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SearchSessionsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a `search-session`.
     * @param {CreateSearchSessionRequest} createSearchSessionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSearchSession(
      createSearchSessionRequest: CreateSearchSessionRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchSession>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createSearchSession(
          createSearchSessionRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `search-session`.
     * @param {string} id The &#x60;search-session&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSearchSession(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchSession>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSearchSession(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SearchSessionsApi - factory interface
 * @export
 */
export const SearchSessionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SearchSessionsApiFp(configuration);
  return {
    /**
     * Create a `search-session`.
     * @param {CreateSearchSessionRequest} createSearchSessionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSearchSession(
      createSearchSessionRequest: CreateSearchSessionRequest,
      options?: any
    ): AxiosPromise<SearchSession> {
      return localVarFp
        .createSearchSession(createSearchSessionRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `search-session`.
     * @param {string} id The &#x60;search-session&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSearchSession(id: string, options?: any): AxiosPromise<SearchSession> {
      return localVarFp
        .getSearchSession(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createSearchSession operation in SearchSessionsApi.
 * @export
 * @interface SearchSessionsApiCreateSearchSessionRequest
 */
export interface SearchSessionsApiCreateSearchSessionRequest {
  /**
   *
   * @type {CreateSearchSessionRequest}
   * @memberof SearchSessionsApiCreateSearchSession
   */
  readonly createSearchSessionRequest: CreateSearchSessionRequest;
}

/**
 * Request parameters for getSearchSession operation in SearchSessionsApi.
 * @export
 * @interface SearchSessionsApiGetSearchSessionRequest
 */
export interface SearchSessionsApiGetSearchSessionRequest {
  /**
   * The &#x60;search-session&#x60; ID.
   * @type {string}
   * @memberof SearchSessionsApiGetSearchSession
   */
  readonly id: string;
}

/**
 * SearchSessionsApi - object-oriented interface
 * @export
 * @class SearchSessionsApi
 * @extends {BaseAPI}
 */
export class SearchSessionsApi extends BaseAPI {
  /**
   * Create a `search-session`.
   * @param {SearchSessionsApiCreateSearchSessionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SearchSessionsApi
   */
  public createSearchSession(
    requestParameters: SearchSessionsApiCreateSearchSessionRequest,
    options?: AxiosRequestConfig
  ) {
    return SearchSessionsApiFp(this.configuration)
      .createSearchSession(
        requestParameters.createSearchSessionRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `search-session`.
   * @param {SearchSessionsApiGetSearchSessionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SearchSessionsApi
   */
  public getSearchSession(
    requestParameters: SearchSessionsApiGetSearchSessionRequest,
    options?: AxiosRequestConfig
  ) {
    return SearchSessionsApiFp(this.configuration)
      .getSearchSession(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * StreamKeysApi - axios parameter creator
 * @export
 */
export const StreamKeysApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a `stream-key` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateStreamKeyRequest} createStreamKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneStreamKey: async (
      id: string,
      createStreamKeyRequest: CreateStreamKeyRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createSceneStreamKey', 'id', id);
      // verify required parameter 'createStreamKeyRequest' is not null or undefined
      assertParamExists(
        'createSceneStreamKey',
        'createStreamKeyRequest',
        createStreamKeyRequest
      );
      const localVarPath = `/scenes/{id}/stream-keys`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createStreamKeyRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a `stream-key`.
     * @param {string} id The &#x60;stream-key&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteStreamKey: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteStreamKey', 'id', id);
      const localVarPath = `/stream-keys/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get `stream-key`s.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterKey] Stream key to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStreamKeys: async (
      pageCursor?: string,
      pageSize?: number,
      filterKey?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/stream-keys`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (filterKey !== undefined) {
        localVarQueryParameter['filter[key]'] = filterKey;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StreamKeysApi - functional programming interface
 * @export
 */
export const StreamKeysApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    StreamKeysApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a `stream-key` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateStreamKeyRequest} createStreamKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneStreamKey(
      id: string,
      createStreamKeyRequest: CreateStreamKeyRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamKey>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createSceneStreamKey(
          id,
          createStreamKeyRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete a `stream-key`.
     * @param {string} id The &#x60;stream-key&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteStreamKey(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStreamKey(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get `stream-key`s.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterKey] Stream key to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStreamKeys(
      pageCursor?: string,
      pageSize?: number,
      filterKey?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamKeyList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStreamKeys(
        pageCursor,
        pageSize,
        filterKey,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * StreamKeysApi - factory interface
 * @export
 */
export const StreamKeysApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = StreamKeysApiFp(configuration);
  return {
    /**
     * Create a `stream-key` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateStreamKeyRequest} createStreamKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneStreamKey(
      id: string,
      createStreamKeyRequest: CreateStreamKeyRequest,
      options?: any
    ): AxiosPromise<StreamKey> {
      return localVarFp
        .createSceneStreamKey(id, createStreamKeyRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a `stream-key`.
     * @param {string} id The &#x60;stream-key&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteStreamKey(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteStreamKey(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get `stream-key`s.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterKey] Stream key to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStreamKeys(
      pageCursor?: string,
      pageSize?: number,
      filterKey?: string,
      options?: any
    ): AxiosPromise<StreamKeyList> {
      return localVarFp
        .getStreamKeys(pageCursor, pageSize, filterKey, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createSceneStreamKey operation in StreamKeysApi.
 * @export
 * @interface StreamKeysApiCreateSceneStreamKeyRequest
 */
export interface StreamKeysApiCreateSceneStreamKeyRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof StreamKeysApiCreateSceneStreamKey
   */
  readonly id: string;

  /**
   *
   * @type {CreateStreamKeyRequest}
   * @memberof StreamKeysApiCreateSceneStreamKey
   */
  readonly createStreamKeyRequest: CreateStreamKeyRequest;
}

/**
 * Request parameters for deleteStreamKey operation in StreamKeysApi.
 * @export
 * @interface StreamKeysApiDeleteStreamKeyRequest
 */
export interface StreamKeysApiDeleteStreamKeyRequest {
  /**
   * The &#x60;stream-key&#x60; ID.
   * @type {string}
   * @memberof StreamKeysApiDeleteStreamKey
   */
  readonly id: string;
}

/**
 * Request parameters for getStreamKeys operation in StreamKeysApi.
 * @export
 * @interface StreamKeysApiGetStreamKeysRequest
 */
export interface StreamKeysApiGetStreamKeysRequest {
  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof StreamKeysApiGetStreamKeys
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof StreamKeysApiGetStreamKeys
   */
  readonly pageSize?: number;

  /**
   * Stream key to filter on.
   * @type {string}
   * @memberof StreamKeysApiGetStreamKeys
   */
  readonly filterKey?: string;
}

/**
 * StreamKeysApi - object-oriented interface
 * @export
 * @class StreamKeysApi
 * @extends {BaseAPI}
 */
export class StreamKeysApi extends BaseAPI {
  /**
   * Create a `stream-key` for a `scene`.
   * @param {StreamKeysApiCreateSceneStreamKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StreamKeysApi
   */
  public createSceneStreamKey(
    requestParameters: StreamKeysApiCreateSceneStreamKeyRequest,
    options?: AxiosRequestConfig
  ) {
    return StreamKeysApiFp(this.configuration)
      .createSceneStreamKey(
        requestParameters.id,
        requestParameters.createStreamKeyRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a `stream-key`.
   * @param {StreamKeysApiDeleteStreamKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StreamKeysApi
   */
  public deleteStreamKey(
    requestParameters: StreamKeysApiDeleteStreamKeyRequest,
    options?: AxiosRequestConfig
  ) {
    return StreamKeysApiFp(this.configuration)
      .deleteStreamKey(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get `stream-key`s.
   * @param {StreamKeysApiGetStreamKeysRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StreamKeysApi
   */
  public getStreamKeys(
    requestParameters: StreamKeysApiGetStreamKeysRequest = {},
    options?: AxiosRequestConfig
  ) {
    return StreamKeysApiFp(this.configuration)
      .getStreamKeys(
        requestParameters.pageCursor,
        requestParameters.pageSize,
        requestParameters.filterKey,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ThreadsApi - axios parameter creator
 * @export
 */
export const ThreadsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a `thread` belonging to a `collaboration-context`.
     * @param {string} id The &#x60;collaboration-context&#x60; ID.
     * @param {CreateThreadRequest} createThreadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createThread: async (
      id: string,
      createThreadRequest: CreateThreadRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createThread', 'id', id);
      // verify required parameter 'createThreadRequest' is not null or undefined
      assertParamExists(
        'createThread',
        'createThreadRequest',
        createThreadRequest
      );
      const localVarPath = `/collaboration-contexts/{id}/threads`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createThreadRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Remove a thread.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteThread: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteThread', 'id', id);
      const localVarPath = `/threads/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `thread`.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {string} [fieldsThread] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThread: async (
      id: string,
      fieldsThread?: string,
      include?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getThread', 'id', id);
      const localVarPath = `/threads/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (fieldsThread !== undefined) {
        localVarQueryParameter['fields[thread]'] = fieldsThread;
      }

      if (include !== undefined) {
        localVarQueryParameter['include'] = include;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `thread`s `user`s.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreadParticipants: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getThreadParticipants', 'id', id);
      const localVarPath = `/threads/{id}/users`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a page of `thread`s.
     * @param {string} [fieldsThread] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {string} [filterCollaborationContextId] A collaboration context to filter on.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {Array<ThreadStatus>} [filterThreadStatus] The statuses of a thread to filter by. Send as a CSV list, e.g. open,resolved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreads: async (
      fieldsThread?: string,
      filterCollaborationContextId?: string,
      pageCursor?: string,
      pageSize?: number,
      include?: string,
      filterThreadStatus?: Array<ThreadStatus>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/threads`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (fieldsThread !== undefined) {
        localVarQueryParameter['fields[thread]'] = fieldsThread;
      }

      if (filterCollaborationContextId !== undefined) {
        localVarQueryParameter['filter[collaborationContextId]'] =
          filterCollaborationContextId;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (include !== undefined) {
        localVarQueryParameter['include'] = include;
      }

      if (filterThreadStatus) {
        localVarQueryParameter['filter[threadStatus]'] =
          filterThreadStatus.join(COLLECTION_FORMATS.csv);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a `thread`.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {UpdateThreadRequest} updateThreadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateThread: async (
      id: string,
      updateThreadRequest: UpdateThreadRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateThread', 'id', id);
      // verify required parameter 'updateThreadRequest' is not null or undefined
      assertParamExists(
        'updateThread',
        'updateThreadRequest',
        updateThreadRequest
      );
      const localVarPath = `/threads/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateThreadRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ThreadsApi - functional programming interface
 * @export
 */
export const ThreadsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ThreadsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a `thread` belonging to a `collaboration-context`.
     * @param {string} id The &#x60;collaboration-context&#x60; ID.
     * @param {CreateThreadRequest} createThreadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createThread(
      id: string,
      createThreadRequest: CreateThreadRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Thread>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createThread(
        id,
        createThreadRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Remove a thread.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteThread(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteThread(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `thread`.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {string} [fieldsThread] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getThread(
      id: string,
      fieldsThread?: string,
      include?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Thread>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getThread(
        id,
        fieldsThread,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `thread`s `user`s.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getThreadParticipants(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getThreadParticipants(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a page of `thread`s.
     * @param {string} [fieldsThread] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {string} [filterCollaborationContextId] A collaboration context to filter on.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {Array<ThreadStatus>} [filterThreadStatus] The statuses of a thread to filter by. Send as a CSV list, e.g. open,resolved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getThreads(
      fieldsThread?: string,
      filterCollaborationContextId?: string,
      pageCursor?: string,
      pageSize?: number,
      include?: string,
      filterThreadStatus?: Array<ThreadStatus>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getThreads(
        fieldsThread,
        filterCollaborationContextId,
        pageCursor,
        pageSize,
        include,
        filterThreadStatus,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update a `thread`.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {UpdateThreadRequest} updateThreadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateThread(
      id: string,
      updateThreadRequest: UpdateThreadRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Thread>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateThread(
        id,
        updateThreadRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ThreadsApi - factory interface
 * @export
 */
export const ThreadsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ThreadsApiFp(configuration);
  return {
    /**
     * Create a `thread` belonging to a `collaboration-context`.
     * @param {string} id The &#x60;collaboration-context&#x60; ID.
     * @param {CreateThreadRequest} createThreadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createThread(
      id: string,
      createThreadRequest: CreateThreadRequest,
      options?: any
    ): AxiosPromise<Thread> {
      return localVarFp
        .createThread(id, createThreadRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Remove a thread.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteThread(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteThread(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `thread`.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {string} [fieldsThread] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThread(
      id: string,
      fieldsThread?: string,
      include?: string,
      options?: any
    ): AxiosPromise<Thread> {
      return localVarFp
        .getThread(id, fieldsThread, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `thread`s `user`s.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreadParticipants(id: string, options?: any): AxiosPromise<UserList> {
      return localVarFp
        .getThreadParticipants(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a page of `thread`s.
     * @param {string} [fieldsThread] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {string} [filterCollaborationContextId] A collaboration context to filter on.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {Array<ThreadStatus>} [filterThreadStatus] The statuses of a thread to filter by. Send as a CSV list, e.g. open,resolved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreads(
      fieldsThread?: string,
      filterCollaborationContextId?: string,
      pageCursor?: string,
      pageSize?: number,
      include?: string,
      filterThreadStatus?: Array<ThreadStatus>,
      options?: any
    ): AxiosPromise<ThreadList> {
      return localVarFp
        .getThreads(
          fieldsThread,
          filterCollaborationContextId,
          pageCursor,
          pageSize,
          include,
          filterThreadStatus,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Update a `thread`.
     * @param {string} id The &#x60;thread&#x60; ID.
     * @param {UpdateThreadRequest} updateThreadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateThread(
      id: string,
      updateThreadRequest: UpdateThreadRequest,
      options?: any
    ): AxiosPromise<Thread> {
      return localVarFp
        .updateThread(id, updateThreadRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createThread operation in ThreadsApi.
 * @export
 * @interface ThreadsApiCreateThreadRequest
 */
export interface ThreadsApiCreateThreadRequest {
  /**
   * The &#x60;collaboration-context&#x60; ID.
   * @type {string}
   * @memberof ThreadsApiCreateThread
   */
  readonly id: string;

  /**
   *
   * @type {CreateThreadRequest}
   * @memberof ThreadsApiCreateThread
   */
  readonly createThreadRequest: CreateThreadRequest;
}

/**
 * Request parameters for deleteThread operation in ThreadsApi.
 * @export
 * @interface ThreadsApiDeleteThreadRequest
 */
export interface ThreadsApiDeleteThreadRequest {
  /**
   * The &#x60;thread&#x60; ID.
   * @type {string}
   * @memberof ThreadsApiDeleteThread
   */
  readonly id: string;
}

/**
 * Request parameters for getThread operation in ThreadsApi.
 * @export
 * @interface ThreadsApiGetThreadRequest
 */
export interface ThreadsApiGetThreadRequest {
  /**
   * The &#x60;thread&#x60; ID.
   * @type {string}
   * @memberof ThreadsApiGetThread
   */
  readonly id: string;

  /**
   * Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
   * @type {string}
   * @memberof ThreadsApiGetThread
   */
  readonly fieldsThread?: string;

  /**
   * Comma-separated list of relationships to include in response.
   * @type {string}
   * @memberof ThreadsApiGetThread
   */
  readonly include?: string;
}

/**
 * Request parameters for getThreadParticipants operation in ThreadsApi.
 * @export
 * @interface ThreadsApiGetThreadParticipantsRequest
 */
export interface ThreadsApiGetThreadParticipantsRequest {
  /**
   * The &#x60;thread&#x60; ID.
   * @type {string}
   * @memberof ThreadsApiGetThreadParticipants
   */
  readonly id: string;
}

/**
 * Request parameters for getThreads operation in ThreadsApi.
 * @export
 * @interface ThreadsApiGetThreadsRequest
 */
export interface ThreadsApiGetThreadsRequest {
  /**
   * Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
   * @type {string}
   * @memberof ThreadsApiGetThreads
   */
  readonly fieldsThread?: string;

  /**
   * A collaboration context to filter on.
   * @type {string}
   * @memberof ThreadsApiGetThreads
   */
  readonly filterCollaborationContextId?: string;

  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof ThreadsApiGetThreads
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof ThreadsApiGetThreads
   */
  readonly pageSize?: number;

  /**
   * Comma-separated list of relationships to include in response.
   * @type {string}
   * @memberof ThreadsApiGetThreads
   */
  readonly include?: string;

  /**
   * The statuses of a thread to filter by. Send as a CSV list, e.g. open,resolved.
   * @type {Array<ThreadStatus>}
   * @memberof ThreadsApiGetThreads
   */
  readonly filterThreadStatus?: Array<ThreadStatus>;
}

/**
 * Request parameters for updateThread operation in ThreadsApi.
 * @export
 * @interface ThreadsApiUpdateThreadRequest
 */
export interface ThreadsApiUpdateThreadRequest {
  /**
   * The &#x60;thread&#x60; ID.
   * @type {string}
   * @memberof ThreadsApiUpdateThread
   */
  readonly id: string;

  /**
   *
   * @type {UpdateThreadRequest}
   * @memberof ThreadsApiUpdateThread
   */
  readonly updateThreadRequest: UpdateThreadRequest;
}

/**
 * ThreadsApi - object-oriented interface
 * @export
 * @class ThreadsApi
 * @extends {BaseAPI}
 */
export class ThreadsApi extends BaseAPI {
  /**
   * Create a `thread` belonging to a `collaboration-context`.
   * @param {ThreadsApiCreateThreadRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public createThread(
    requestParameters: ThreadsApiCreateThreadRequest,
    options?: AxiosRequestConfig
  ) {
    return ThreadsApiFp(this.configuration)
      .createThread(
        requestParameters.id,
        requestParameters.createThreadRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Remove a thread.
   * @param {ThreadsApiDeleteThreadRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public deleteThread(
    requestParameters: ThreadsApiDeleteThreadRequest,
    options?: AxiosRequestConfig
  ) {
    return ThreadsApiFp(this.configuration)
      .deleteThread(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `thread`.
   * @param {ThreadsApiGetThreadRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public getThread(
    requestParameters: ThreadsApiGetThreadRequest,
    options?: AxiosRequestConfig
  ) {
    return ThreadsApiFp(this.configuration)
      .getThread(
        requestParameters.id,
        requestParameters.fieldsThread,
        requestParameters.include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `thread`s `user`s.
   * @param {ThreadsApiGetThreadParticipantsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public getThreadParticipants(
    requestParameters: ThreadsApiGetThreadParticipantsRequest,
    options?: AxiosRequestConfig
  ) {
    return ThreadsApiFp(this.configuration)
      .getThreadParticipants(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a page of `thread`s.
   * @param {ThreadsApiGetThreadsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public getThreads(
    requestParameters: ThreadsApiGetThreadsRequest = {},
    options?: AxiosRequestConfig
  ) {
    return ThreadsApiFp(this.configuration)
      .getThreads(
        requestParameters.fieldsThread,
        requestParameters.filterCollaborationContextId,
        requestParameters.pageCursor,
        requestParameters.pageSize,
        requestParameters.include,
        requestParameters.filterThreadStatus,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update a `thread`.
   * @param {ThreadsApiUpdateThreadRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThreadsApi
   */
  public updateThread(
    requestParameters: ThreadsApiUpdateThreadRequest,
    options?: AxiosRequestConfig
  ) {
    return ThreadsApiFp(this.configuration)
      .updateThread(
        requestParameters.id,
        requestParameters.updateThreadRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TranslationInspectionsApi - axios parameter creator
 * @export
 */
export const TranslationInspectionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a `translation-inspection`.
     * @param {CreateTranslationInspectionRequest} createTranslationInspectionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTranslationInspection: async (
      createTranslationInspectionRequest: CreateTranslationInspectionRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createTranslationInspectionRequest' is not null or undefined
      assertParamExists(
        'createTranslationInspection',
        'createTranslationInspectionRequest',
        createTranslationInspectionRequest
      );
      const localVarPath = `/translation-inspections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createTranslationInspectionRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `translation-inspection` by ID.
     * @param {string} id The &#x60;translation-inspection&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInspectionJob: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getInspectionJob', 'id', id);
      const localVarPath = `/translation-inspections/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This has been deprecated and replaced by **queued-translation-jobs/{id}** - Get a `queued-translation`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `part-revision`. Once created, create scenes via the createScene API. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
     * @param {string} id The &#x60;queued-translation&#x60; ID.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getQueuedTranslation: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getQueuedTranslation', 'id', id);
      const localVarPath = `/queued-translations/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `queued-translation-job`. The response is either the status if `running` or `error` or, upon completion, the `part-revision` that was created. Once created, create scenes via the createScene API. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
     * @param {string} id The &#x60;queued-translation&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedTranslationJob: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getQueuedTranslationJob', 'id', id);
      const localVarPath = `/queued-translation-jobs/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all current translation jobs in progress.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [sort] A sort to apply to the collection. A \&quot;minus\&quot; prefixed before the field name is used to specify descending sort order.
     * @param {string} [filterStatus] Status to filter on.
     * @param {FilterExpression} [filterCompletedAt] The completion date and time to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedTranslationJobs: async (
      pageCursor?: string,
      pageSize?: number,
      sort?: string,
      filterStatus?: string,
      filterCompletedAt?: FilterExpression,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/queued-translation-jobs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort;
      }

      if (filterStatus !== undefined) {
        localVarQueryParameter['filter[status]'] = filterStatus;
      }

      if (filterCompletedAt !== undefined) {
        localVarQueryParameter['filter[completedAt]'] = filterCompletedAt;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This has been deprecated and replaced by **queued-translation-jobs** - Get `queued-translation`s.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterStatus] Status to filter on.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getQueuedTranslations: async (
      pageCursor?: string,
      pageSize?: number,
      filterStatus?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/queued-translations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (filterStatus !== undefined) {
        localVarQueryParameter['filter[status]'] = filterStatus;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all the specified translation jobs.
     * @param {QueryTranslationJobs} queryTranslationJobs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postQueryTranslationJobs: async (
      queryTranslationJobs: QueryTranslationJobs,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queryTranslationJobs' is not null or undefined
      assertParamExists(
        'postQueryTranslationJobs',
        'queryTranslationJobs',
        queryTranslationJobs
      );
      const localVarPath = `/query-translation-jobs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        queryTranslationJobs,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TranslationInspectionsApi - functional programming interface
 * @export
 */
export const TranslationInspectionsApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    TranslationInspectionsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a `translation-inspection`.
     * @param {CreateTranslationInspectionRequest} createTranslationInspectionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTranslationInspection(
      createTranslationInspectionRequest: CreateTranslationInspectionRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<TranslationInspectionJob>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createTranslationInspection(
          createTranslationInspectionRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `translation-inspection` by ID.
     * @param {string} id The &#x60;translation-inspection&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInspectionJob(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<TranslationInspectionJob>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getInspectionJob(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * This has been deprecated and replaced by **queued-translation-jobs/{id}** - Get a `queued-translation`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `part-revision`. Once created, create scenes via the createScene API. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
     * @param {string} id The &#x60;queued-translation&#x60; ID.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async getQueuedTranslation(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getQueuedTranslation(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `queued-translation-job`. The response is either the status if `running` or `error` or, upon completion, the `part-revision` that was created. Once created, create scenes via the createScene API. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
     * @param {string} id The &#x60;queued-translation&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedTranslationJob(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<QueuedTranslationJob>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getQueuedTranslationJob(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get all current translation jobs in progress.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [sort] A sort to apply to the collection. A \&quot;minus\&quot; prefixed before the field name is used to specify descending sort order.
     * @param {string} [filterStatus] Status to filter on.
     * @param {FilterExpression} [filterCompletedAt] The completion date and time to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedTranslationJobs(
      pageCursor?: string,
      pageSize?: number,
      sort?: string,
      filterStatus?: string,
      filterCompletedAt?: FilterExpression,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJobList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getQueuedTranslationJobs(
          pageCursor,
          pageSize,
          sort,
          filterStatus,
          filterCompletedAt,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * This has been deprecated and replaced by **queued-translation-jobs** - Get `queued-translation`s.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterStatus] Status to filter on.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async getQueuedTranslations(
      pageCursor?: string,
      pageSize?: number,
      filterStatus?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJobList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getQueuedTranslations(
          pageCursor,
          pageSize,
          filterStatus,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get all the specified translation jobs.
     * @param {QueryTranslationJobs} queryTranslationJobs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postQueryTranslationJobs(
      queryTranslationJobs: QueryTranslationJobs,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<QueuedTranslationJobList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postQueryTranslationJobs(
          queryTranslationJobs,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * TranslationInspectionsApi - factory interface
 * @export
 */
export const TranslationInspectionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TranslationInspectionsApiFp(configuration);
  return {
    /**
     * Create a `translation-inspection`.
     * @param {CreateTranslationInspectionRequest} createTranslationInspectionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTranslationInspection(
      createTranslationInspectionRequest: CreateTranslationInspectionRequest,
      options?: any
    ): AxiosPromise<TranslationInspectionJob> {
      return localVarFp
        .createTranslationInspection(
          createTranslationInspectionRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `translation-inspection` by ID.
     * @param {string} id The &#x60;translation-inspection&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInspectionJob(
      id: string,
      options?: any
    ): AxiosPromise<TranslationInspectionJob> {
      return localVarFp
        .getInspectionJob(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This has been deprecated and replaced by **queued-translation-jobs/{id}** - Get a `queued-translation`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `part-revision`. Once created, create scenes via the createScene API. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
     * @param {string} id The &#x60;queued-translation&#x60; ID.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getQueuedTranslation(id: string, options?: any): AxiosPromise<QueuedJob> {
      return localVarFp
        .getQueuedTranslation(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `queued-translation-job`. The response is either the status if `running` or `error` or, upon completion, the `part-revision` that was created. Once created, create scenes via the createScene API. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
     * @param {string} id The &#x60;queued-translation&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedTranslationJob(
      id: string,
      options?: any
    ): AxiosPromise<QueuedTranslationJob> {
      return localVarFp
        .getQueuedTranslationJob(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get all current translation jobs in progress.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [sort] A sort to apply to the collection. A \&quot;minus\&quot; prefixed before the field name is used to specify descending sort order.
     * @param {string} [filterStatus] Status to filter on.
     * @param {FilterExpression} [filterCompletedAt] The completion date and time to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedTranslationJobs(
      pageCursor?: string,
      pageSize?: number,
      sort?: string,
      filterStatus?: string,
      filterCompletedAt?: FilterExpression,
      options?: any
    ): AxiosPromise<QueuedJobList> {
      return localVarFp
        .getQueuedTranslationJobs(
          pageCursor,
          pageSize,
          sort,
          filterStatus,
          filterCompletedAt,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * This has been deprecated and replaced by **queued-translation-jobs** - Get `queued-translation`s.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterStatus] Status to filter on.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getQueuedTranslations(
      pageCursor?: string,
      pageSize?: number,
      filterStatus?: string,
      options?: any
    ): AxiosPromise<QueuedJobList> {
      return localVarFp
        .getQueuedTranslations(pageCursor, pageSize, filterStatus, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get all the specified translation jobs.
     * @param {QueryTranslationJobs} queryTranslationJobs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postQueryTranslationJobs(
      queryTranslationJobs: QueryTranslationJobs,
      options?: any
    ): AxiosPromise<QueuedTranslationJobList> {
      return localVarFp
        .postQueryTranslationJobs(queryTranslationJobs, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createTranslationInspection operation in TranslationInspectionsApi.
 * @export
 * @interface TranslationInspectionsApiCreateTranslationInspectionRequest
 */
export interface TranslationInspectionsApiCreateTranslationInspectionRequest {
  /**
   *
   * @type {CreateTranslationInspectionRequest}
   * @memberof TranslationInspectionsApiCreateTranslationInspection
   */
  readonly createTranslationInspectionRequest: CreateTranslationInspectionRequest;
}

/**
 * Request parameters for getInspectionJob operation in TranslationInspectionsApi.
 * @export
 * @interface TranslationInspectionsApiGetInspectionJobRequest
 */
export interface TranslationInspectionsApiGetInspectionJobRequest {
  /**
   * The &#x60;translation-inspection&#x60; ID.
   * @type {string}
   * @memberof TranslationInspectionsApiGetInspectionJob
   */
  readonly id: string;
}

/**
 * Request parameters for getQueuedTranslation operation in TranslationInspectionsApi.
 * @export
 * @interface TranslationInspectionsApiGetQueuedTranslationRequest
 */
export interface TranslationInspectionsApiGetQueuedTranslationRequest {
  /**
   * The &#x60;queued-translation&#x60; ID.
   * @type {string}
   * @memberof TranslationInspectionsApiGetQueuedTranslation
   */
  readonly id: string;
}

/**
 * Request parameters for getQueuedTranslationJob operation in TranslationInspectionsApi.
 * @export
 * @interface TranslationInspectionsApiGetQueuedTranslationJobRequest
 */
export interface TranslationInspectionsApiGetQueuedTranslationJobRequest {
  /**
   * The &#x60;queued-translation&#x60; ID.
   * @type {string}
   * @memberof TranslationInspectionsApiGetQueuedTranslationJob
   */
  readonly id: string;
}

/**
 * Request parameters for getQueuedTranslationJobs operation in TranslationInspectionsApi.
 * @export
 * @interface TranslationInspectionsApiGetQueuedTranslationJobsRequest
 */
export interface TranslationInspectionsApiGetQueuedTranslationJobsRequest {
  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof TranslationInspectionsApiGetQueuedTranslationJobs
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof TranslationInspectionsApiGetQueuedTranslationJobs
   */
  readonly pageSize?: number;

  /**
   * A sort to apply to the collection. A \&quot;minus\&quot; prefixed before the field name is used to specify descending sort order.
   * @type {string}
   * @memberof TranslationInspectionsApiGetQueuedTranslationJobs
   */
  readonly sort?: string;

  /**
   * Status to filter on.
   * @type {string}
   * @memberof TranslationInspectionsApiGetQueuedTranslationJobs
   */
  readonly filterStatus?: string;

  /**
   * The completion date and time to filter on.
   * @type {FilterExpression}
   * @memberof TranslationInspectionsApiGetQueuedTranslationJobs
   */
  readonly filterCompletedAt?: FilterExpression;
}

/**
 * Request parameters for getQueuedTranslations operation in TranslationInspectionsApi.
 * @export
 * @interface TranslationInspectionsApiGetQueuedTranslationsRequest
 */
export interface TranslationInspectionsApiGetQueuedTranslationsRequest {
  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof TranslationInspectionsApiGetQueuedTranslations
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof TranslationInspectionsApiGetQueuedTranslations
   */
  readonly pageSize?: number;

  /**
   * Status to filter on.
   * @type {string}
   * @memberof TranslationInspectionsApiGetQueuedTranslations
   */
  readonly filterStatus?: string;
}

/**
 * Request parameters for postQueryTranslationJobs operation in TranslationInspectionsApi.
 * @export
 * @interface TranslationInspectionsApiPostQueryTranslationJobsRequest
 */
export interface TranslationInspectionsApiPostQueryTranslationJobsRequest {
  /**
   *
   * @type {QueryTranslationJobs}
   * @memberof TranslationInspectionsApiPostQueryTranslationJobs
   */
  readonly queryTranslationJobs: QueryTranslationJobs;
}

/**
 * TranslationInspectionsApi - object-oriented interface
 * @export
 * @class TranslationInspectionsApi
 * @extends {BaseAPI}
 */
export class TranslationInspectionsApi extends BaseAPI {
  /**
   * Create a `translation-inspection`.
   * @param {TranslationInspectionsApiCreateTranslationInspectionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranslationInspectionsApi
   */
  public createTranslationInspection(
    requestParameters: TranslationInspectionsApiCreateTranslationInspectionRequest,
    options?: AxiosRequestConfig
  ) {
    return TranslationInspectionsApiFp(this.configuration)
      .createTranslationInspection(
        requestParameters.createTranslationInspectionRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `translation-inspection` by ID.
   * @param {TranslationInspectionsApiGetInspectionJobRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranslationInspectionsApi
   */
  public getInspectionJob(
    requestParameters: TranslationInspectionsApiGetInspectionJobRequest,
    options?: AxiosRequestConfig
  ) {
    return TranslationInspectionsApiFp(this.configuration)
      .getInspectionJob(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This has been deprecated and replaced by **queued-translation-jobs/{id}** - Get a `queued-translation`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `part-revision`. Once created, create scenes via the createScene API. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
   * @param {TranslationInspectionsApiGetQueuedTranslationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof TranslationInspectionsApi
   */
  public getQueuedTranslation(
    requestParameters: TranslationInspectionsApiGetQueuedTranslationRequest,
    options?: AxiosRequestConfig
  ) {
    return TranslationInspectionsApiFp(this.configuration)
      .getQueuedTranslation(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `queued-translation-job`. The response is either the status if `running` or `error` or, upon completion, the `part-revision` that was created. Once created, create scenes via the createScene API. For details, see our [Render static scenes](https://developer.vertexvis.com/docs/guides/render-static-scenes) guide.
   * @param {TranslationInspectionsApiGetQueuedTranslationJobRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranslationInspectionsApi
   */
  public getQueuedTranslationJob(
    requestParameters: TranslationInspectionsApiGetQueuedTranslationJobRequest,
    options?: AxiosRequestConfig
  ) {
    return TranslationInspectionsApiFp(this.configuration)
      .getQueuedTranslationJob(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all current translation jobs in progress.
   * @param {TranslationInspectionsApiGetQueuedTranslationJobsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranslationInspectionsApi
   */
  public getQueuedTranslationJobs(
    requestParameters: TranslationInspectionsApiGetQueuedTranslationJobsRequest = {},
    options?: AxiosRequestConfig
  ) {
    return TranslationInspectionsApiFp(this.configuration)
      .getQueuedTranslationJobs(
        requestParameters.pageCursor,
        requestParameters.pageSize,
        requestParameters.sort,
        requestParameters.filterStatus,
        requestParameters.filterCompletedAt,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This has been deprecated and replaced by **queued-translation-jobs** - Get `queued-translation`s.
   * @param {TranslationInspectionsApiGetQueuedTranslationsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof TranslationInspectionsApi
   */
  public getQueuedTranslations(
    requestParameters: TranslationInspectionsApiGetQueuedTranslationsRequest = {},
    options?: AxiosRequestConfig
  ) {
    return TranslationInspectionsApiFp(this.configuration)
      .getQueuedTranslations(
        requestParameters.pageCursor,
        requestParameters.pageSize,
        requestParameters.filterStatus,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all the specified translation jobs.
   * @param {TranslationInspectionsApiPostQueryTranslationJobsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranslationInspectionsApi
   */
  public postQueryTranslationJobs(
    requestParameters: TranslationInspectionsApiPostQueryTranslationJobsRequest,
    options?: AxiosRequestConfig
  ) {
    return TranslationInspectionsApiFp(this.configuration)
      .postQueryTranslationJobs(requestParameters.queryTranslationJobs, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserGroupsApi - axios parameter creator
 * @export
 */
export const UserGroupsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Add a `user` to a `user-group`.
     * @param {string} id A &#x60;user-group&#x60; ID.
     * @param {UserIdList} userIdList
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUsersToUserGroup: async (
      id: string,
      userIdList: UserIdList,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('addUsersToUserGroup', 'id', id);
      // verify required parameter 'userIdList' is not null or undefined
      assertParamExists('addUsersToUserGroup', 'userIdList', userIdList);
      const localVarPath = `/user-groups/{id}/users`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userIdList,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a `user-group`
     * @param {CreateUserGroupRequest} createUserGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserGroup: async (
      createUserGroupRequest: CreateUserGroupRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createUserGroupRequest' is not null or undefined
      assertParamExists(
        'createUserGroup',
        'createUserGroupRequest',
        createUserGroupRequest
      );
      const localVarPath = `/user-groups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createUserGroupRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `user-group`.
     * @param {string} id The &#x60;user-group&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserGroup: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getUserGroup', 'id', id);
      const localVarPath = `/user-groups/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserGroupsApi - functional programming interface
 * @export
 */
export const UserGroupsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    UserGroupsApiAxiosParamCreator(configuration);
  return {
    /**
     * Add a `user` to a `user-group`.
     * @param {string} id A &#x60;user-group&#x60; ID.
     * @param {UserIdList} userIdList
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addUsersToUserGroup(
      id: string,
      userIdList: UserIdList,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addUsersToUserGroup(
          id,
          userIdList,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Create a `user-group`
     * @param {CreateUserGroupRequest} createUserGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUserGroup(
      createUserGroupRequest: CreateUserGroupRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGroup>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUserGroup(
        createUserGroupRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `user-group`.
     * @param {string} id The &#x60;user-group&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserGroup(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserGroup(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UserGroupsApi - factory interface
 * @export
 */
export const UserGroupsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UserGroupsApiFp(configuration);
  return {
    /**
     * Add a `user` to a `user-group`.
     * @param {string} id A &#x60;user-group&#x60; ID.
     * @param {UserIdList} userIdList
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUsersToUserGroup(
      id: string,
      userIdList: UserIdList,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .addUsersToUserGroup(id, userIdList, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a `user-group`
     * @param {CreateUserGroupRequest} createUserGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserGroup(
      createUserGroupRequest: CreateUserGroupRequest,
      options?: any
    ): AxiosPromise<UserGroup> {
      return localVarFp
        .createUserGroup(createUserGroupRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `user-group`.
     * @param {string} id The &#x60;user-group&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserGroup(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .getUserGroup(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for addUsersToUserGroup operation in UserGroupsApi.
 * @export
 * @interface UserGroupsApiAddUsersToUserGroupRequest
 */
export interface UserGroupsApiAddUsersToUserGroupRequest {
  /**
   * A &#x60;user-group&#x60; ID.
   * @type {string}
   * @memberof UserGroupsApiAddUsersToUserGroup
   */
  readonly id: string;

  /**
   *
   * @type {UserIdList}
   * @memberof UserGroupsApiAddUsersToUserGroup
   */
  readonly userIdList: UserIdList;
}

/**
 * Request parameters for createUserGroup operation in UserGroupsApi.
 * @export
 * @interface UserGroupsApiCreateUserGroupRequest
 */
export interface UserGroupsApiCreateUserGroupRequest {
  /**
   *
   * @type {CreateUserGroupRequest}
   * @memberof UserGroupsApiCreateUserGroup
   */
  readonly createUserGroupRequest: CreateUserGroupRequest;
}

/**
 * Request parameters for getUserGroup operation in UserGroupsApi.
 * @export
 * @interface UserGroupsApiGetUserGroupRequest
 */
export interface UserGroupsApiGetUserGroupRequest {
  /**
   * The &#x60;user-group&#x60; ID.
   * @type {string}
   * @memberof UserGroupsApiGetUserGroup
   */
  readonly id: string;
}

/**
 * UserGroupsApi - object-oriented interface
 * @export
 * @class UserGroupsApi
 * @extends {BaseAPI}
 */
export class UserGroupsApi extends BaseAPI {
  /**
   * Add a `user` to a `user-group`.
   * @param {UserGroupsApiAddUsersToUserGroupRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserGroupsApi
   */
  public addUsersToUserGroup(
    requestParameters: UserGroupsApiAddUsersToUserGroupRequest,
    options?: AxiosRequestConfig
  ) {
    return UserGroupsApiFp(this.configuration)
      .addUsersToUserGroup(
        requestParameters.id,
        requestParameters.userIdList,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a `user-group`
   * @param {UserGroupsApiCreateUserGroupRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserGroupsApi
   */
  public createUserGroup(
    requestParameters: UserGroupsApiCreateUserGroupRequest,
    options?: AxiosRequestConfig
  ) {
    return UserGroupsApiFp(this.configuration)
      .createUserGroup(requestParameters.createUserGroupRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `user-group`.
   * @param {UserGroupsApiGetUserGroupRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserGroupsApi
   */
  public getUserGroup(
    requestParameters: UserGroupsApiGetUserGroupRequest,
    options?: AxiosRequestConfig
  ) {
    return UserGroupsApiFp(this.configuration)
      .getUserGroup(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a `user`
     * @param {CreateUserRequest} createUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: async (
      createUserRequest: CreateUserRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createUserRequest' is not null or undefined
      assertParamExists('createUser', 'createUserRequest', createUserRequest);
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createUserRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `user`.
     * @param {string} id The &#x60;user&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getUser', 'id', id);
      const localVarPath = `/users/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get `user-group`s.
     * @param {string} id The &#x60;user&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserGroupsForUser: async (
      id: string,
      pageCursor?: string,
      pageSize?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getUserGroupsForUser', 'id', id);
      const localVarPath = `/users/{id}/user-groups`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List `user`s.
     * @param {string} [filterIdpId] Id from the idpProvider.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers: async (
      filterIdpId?: string,
      pageCursor?: string,
      pageSize?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (filterIdpId !== undefined) {
        localVarQueryParameter['filter[idpId]'] = filterIdpId;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a `user`
     * @param {CreateUserRequest} createUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUser(
      createUserRequest: CreateUserRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(
        createUserRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `user`.
     * @param {string} id The &#x60;user&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get `user-group`s.
     * @param {string} id The &#x60;user&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserGroupsForUser(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGroupList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUserGroupsForUser(
          id,
          pageCursor,
          pageSize,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * List `user`s.
     * @param {string} [filterIdpId] Id from the idpProvider.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listUsers(
      filterIdpId?: string,
      pageCursor?: string,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(
        filterIdpId,
        pageCursor,
        pageSize,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     * Create a `user`
     * @param {CreateUserRequest} createUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(
      createUserRequest: CreateUserRequest,
      options?: any
    ): AxiosPromise<User> {
      return localVarFp
        .createUser(createUserRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `user`.
     * @param {string} id The &#x60;user&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(id: string, options?: any): AxiosPromise<User> {
      return localVarFp
        .getUser(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get `user-group`s.
     * @param {string} id The &#x60;user&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserGroupsForUser(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<UserGroupList> {
      return localVarFp
        .getUserGroupsForUser(id, pageCursor, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List `user`s.
     * @param {string} [filterIdpId] Id from the idpProvider.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers(
      filterIdpId?: string,
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<UserList> {
      return localVarFp
        .listUsers(filterIdpId, pageCursor, pageSize, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createUser operation in UsersApi.
 * @export
 * @interface UsersApiCreateUserRequest
 */
export interface UsersApiCreateUserRequest {
  /**
   *
   * @type {CreateUserRequest}
   * @memberof UsersApiCreateUser
   */
  readonly createUserRequest: CreateUserRequest;
}

/**
 * Request parameters for getUser operation in UsersApi.
 * @export
 * @interface UsersApiGetUserRequest
 */
export interface UsersApiGetUserRequest {
  /**
   * The &#x60;user&#x60; ID.
   * @type {string}
   * @memberof UsersApiGetUser
   */
  readonly id: string;
}

/**
 * Request parameters for getUserGroupsForUser operation in UsersApi.
 * @export
 * @interface UsersApiGetUserGroupsForUserRequest
 */
export interface UsersApiGetUserGroupsForUserRequest {
  /**
   * The &#x60;user&#x60; ID.
   * @type {string}
   * @memberof UsersApiGetUserGroupsForUser
   */
  readonly id: string;

  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof UsersApiGetUserGroupsForUser
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof UsersApiGetUserGroupsForUser
   */
  readonly pageSize?: number;
}

/**
 * Request parameters for listUsers operation in UsersApi.
 * @export
 * @interface UsersApiListUsersRequest
 */
export interface UsersApiListUsersRequest {
  /**
   * Id from the idpProvider.
   * @type {string}
   * @memberof UsersApiListUsers
   */
  readonly filterIdpId?: string;

  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof UsersApiListUsers
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof UsersApiListUsers
   */
  readonly pageSize?: number;
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   * Create a `user`
   * @param {UsersApiCreateUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public createUser(
    requestParameters: UsersApiCreateUserRequest,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .createUser(requestParameters.createUserRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `user`.
   * @param {UsersApiGetUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUser(
    requestParameters: UsersApiGetUserRequest,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .getUser(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get `user-group`s.
   * @param {UsersApiGetUserGroupsForUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUserGroupsForUser(
    requestParameters: UsersApiGetUserGroupsForUserRequest,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .getUserGroupsForUser(
        requestParameters.id,
        requestParameters.pageCursor,
        requestParameters.pageSize,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List `user`s.
   * @param {UsersApiListUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public listUsers(
    requestParameters: UsersApiListUsersRequest = {},
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .listUsers(
        requestParameters.filterIdpId,
        requestParameters.pageCursor,
        requestParameters.pageSize,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * WebhookSubscriptionsApi - axios parameter creator
 * @export
 */
export const WebhookSubscriptionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create a `webhook-subscription`
     * @param {CreateWebhookSubscriptionRequest} createWebhookSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhookSubscription: async (
      createWebhookSubscriptionRequest: CreateWebhookSubscriptionRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createWebhookSubscriptionRequest' is not null or undefined
      assertParamExists(
        'createWebhookSubscription',
        'createWebhookSubscriptionRequest',
        createWebhookSubscriptionRequest
      );
      const localVarPath = `/webhook-subscriptions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createWebhookSubscriptionRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a `webhook-subscription`.
     * @param {string} id The &#x60;webhook-subscription&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhookSubscription: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteWebhookSubscription', 'id', id);
      const localVarPath = `/webhook-subscriptions/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a `webhook-subscription`.
     * @param {string} id The &#x60;webhook-subscription&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhookSubscription: async (
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getWebhookSubscription', 'id', id);
      const localVarPath = `/webhook-subscriptions/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get `webhook-subscription`s.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhookSubscriptions: async (
      pageCursor?: string,
      pageSize?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/webhook-subscriptions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a `webhook-subscription`.
     * @param {string} id The &#x60;webhook-subscription&#x60; ID.
     * @param {UpdateWebhookSubscriptionRequest} updateWebhookSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhookSubscription: async (
      id: string,
      updateWebhookSubscriptionRequest: UpdateWebhookSubscriptionRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateWebhookSubscription', 'id', id);
      // verify required parameter 'updateWebhookSubscriptionRequest' is not null or undefined
      assertParamExists(
        'updateWebhookSubscription',
        'updateWebhookSubscriptionRequest',
        updateWebhookSubscriptionRequest
      );
      const localVarPath = `/webhook-subscriptions/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'OAuth2',
        [],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions?.headers ?? {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateWebhookSubscriptionRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WebhookSubscriptionsApi - functional programming interface
 * @export
 */
export const WebhookSubscriptionsApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    WebhookSubscriptionsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a `webhook-subscription`
     * @param {CreateWebhookSubscriptionRequest} createWebhookSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createWebhookSubscription(
      createWebhookSubscriptionRequest: CreateWebhookSubscriptionRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<WebhookSubscription>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createWebhookSubscription(
          createWebhookSubscriptionRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete a `webhook-subscription`.
     * @param {string} id The &#x60;webhook-subscription&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteWebhookSubscription(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteWebhookSubscription(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a `webhook-subscription`.
     * @param {string} id The &#x60;webhook-subscription&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWebhookSubscription(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<WebhookSubscription>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getWebhookSubscription(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get `webhook-subscription`s.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWebhookSubscriptions(
      pageCursor?: string,
      pageSize?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<WebhookSubscriptionList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getWebhookSubscriptions(
          pageCursor,
          pageSize,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update a `webhook-subscription`.
     * @param {string} id The &#x60;webhook-subscription&#x60; ID.
     * @param {UpdateWebhookSubscriptionRequest} updateWebhookSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateWebhookSubscription(
      id: string,
      updateWebhookSubscriptionRequest: UpdateWebhookSubscriptionRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<WebhookSubscription>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateWebhookSubscription(
          id,
          updateWebhookSubscriptionRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * WebhookSubscriptionsApi - factory interface
 * @export
 */
export const WebhookSubscriptionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = WebhookSubscriptionsApiFp(configuration);
  return {
    /**
     * Create a `webhook-subscription`
     * @param {CreateWebhookSubscriptionRequest} createWebhookSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhookSubscription(
      createWebhookSubscriptionRequest: CreateWebhookSubscriptionRequest,
      options?: any
    ): AxiosPromise<WebhookSubscription> {
      return localVarFp
        .createWebhookSubscription(createWebhookSubscriptionRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a `webhook-subscription`.
     * @param {string} id The &#x60;webhook-subscription&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhookSubscription(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteWebhookSubscription(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a `webhook-subscription`.
     * @param {string} id The &#x60;webhook-subscription&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhookSubscription(
      id: string,
      options?: any
    ): AxiosPromise<WebhookSubscription> {
      return localVarFp
        .getWebhookSubscription(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get `webhook-subscription`s.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhookSubscriptions(
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<WebhookSubscriptionList> {
      return localVarFp
        .getWebhookSubscriptions(pageCursor, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update a `webhook-subscription`.
     * @param {string} id The &#x60;webhook-subscription&#x60; ID.
     * @param {UpdateWebhookSubscriptionRequest} updateWebhookSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhookSubscription(
      id: string,
      updateWebhookSubscriptionRequest: UpdateWebhookSubscriptionRequest,
      options?: any
    ): AxiosPromise<WebhookSubscription> {
      return localVarFp
        .updateWebhookSubscription(
          id,
          updateWebhookSubscriptionRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createWebhookSubscription operation in WebhookSubscriptionsApi.
 * @export
 * @interface WebhookSubscriptionsApiCreateWebhookSubscriptionRequest
 */
export interface WebhookSubscriptionsApiCreateWebhookSubscriptionRequest {
  /**
   *
   * @type {CreateWebhookSubscriptionRequest}
   * @memberof WebhookSubscriptionsApiCreateWebhookSubscription
   */
  readonly createWebhookSubscriptionRequest: CreateWebhookSubscriptionRequest;
}

/**
 * Request parameters for deleteWebhookSubscription operation in WebhookSubscriptionsApi.
 * @export
 * @interface WebhookSubscriptionsApiDeleteWebhookSubscriptionRequest
 */
export interface WebhookSubscriptionsApiDeleteWebhookSubscriptionRequest {
  /**
   * The &#x60;webhook-subscription&#x60; ID.
   * @type {string}
   * @memberof WebhookSubscriptionsApiDeleteWebhookSubscription
   */
  readonly id: string;
}

/**
 * Request parameters for getWebhookSubscription operation in WebhookSubscriptionsApi.
 * @export
 * @interface WebhookSubscriptionsApiGetWebhookSubscriptionRequest
 */
export interface WebhookSubscriptionsApiGetWebhookSubscriptionRequest {
  /**
   * The &#x60;webhook-subscription&#x60; ID.
   * @type {string}
   * @memberof WebhookSubscriptionsApiGetWebhookSubscription
   */
  readonly id: string;
}

/**
 * Request parameters for getWebhookSubscriptions operation in WebhookSubscriptionsApi.
 * @export
 * @interface WebhookSubscriptionsApiGetWebhookSubscriptionsRequest
 */
export interface WebhookSubscriptionsApiGetWebhookSubscriptionsRequest {
  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof WebhookSubscriptionsApiGetWebhookSubscriptions
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof WebhookSubscriptionsApiGetWebhookSubscriptions
   */
  readonly pageSize?: number;
}

/**
 * Request parameters for updateWebhookSubscription operation in WebhookSubscriptionsApi.
 * @export
 * @interface WebhookSubscriptionsApiUpdateWebhookSubscriptionRequest
 */
export interface WebhookSubscriptionsApiUpdateWebhookSubscriptionRequest {
  /**
   * The &#x60;webhook-subscription&#x60; ID.
   * @type {string}
   * @memberof WebhookSubscriptionsApiUpdateWebhookSubscription
   */
  readonly id: string;

  /**
   *
   * @type {UpdateWebhookSubscriptionRequest}
   * @memberof WebhookSubscriptionsApiUpdateWebhookSubscription
   */
  readonly updateWebhookSubscriptionRequest: UpdateWebhookSubscriptionRequest;
}

/**
 * WebhookSubscriptionsApi - object-oriented interface
 * @export
 * @class WebhookSubscriptionsApi
 * @extends {BaseAPI}
 */
export class WebhookSubscriptionsApi extends BaseAPI {
  /**
   * Create a `webhook-subscription`
   * @param {WebhookSubscriptionsApiCreateWebhookSubscriptionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhookSubscriptionsApi
   */
  public createWebhookSubscription(
    requestParameters: WebhookSubscriptionsApiCreateWebhookSubscriptionRequest,
    options?: AxiosRequestConfig
  ) {
    return WebhookSubscriptionsApiFp(this.configuration)
      .createWebhookSubscription(
        requestParameters.createWebhookSubscriptionRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a `webhook-subscription`.
   * @param {WebhookSubscriptionsApiDeleteWebhookSubscriptionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhookSubscriptionsApi
   */
  public deleteWebhookSubscription(
    requestParameters: WebhookSubscriptionsApiDeleteWebhookSubscriptionRequest,
    options?: AxiosRequestConfig
  ) {
    return WebhookSubscriptionsApiFp(this.configuration)
      .deleteWebhookSubscription(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a `webhook-subscription`.
   * @param {WebhookSubscriptionsApiGetWebhookSubscriptionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhookSubscriptionsApi
   */
  public getWebhookSubscription(
    requestParameters: WebhookSubscriptionsApiGetWebhookSubscriptionRequest,
    options?: AxiosRequestConfig
  ) {
    return WebhookSubscriptionsApiFp(this.configuration)
      .getWebhookSubscription(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get `webhook-subscription`s.
   * @param {WebhookSubscriptionsApiGetWebhookSubscriptionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhookSubscriptionsApi
   */
  public getWebhookSubscriptions(
    requestParameters: WebhookSubscriptionsApiGetWebhookSubscriptionsRequest = {},
    options?: AxiosRequestConfig
  ) {
    return WebhookSubscriptionsApiFp(this.configuration)
      .getWebhookSubscriptions(
        requestParameters.pageCursor,
        requestParameters.pageSize,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update a `webhook-subscription`.
   * @param {WebhookSubscriptionsApiUpdateWebhookSubscriptionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhookSubscriptionsApi
   */
  public updateWebhookSubscription(
    requestParameters: WebhookSubscriptionsApiUpdateWebhookSubscriptionRequest,
    options?: AxiosRequestConfig
  ) {
    return WebhookSubscriptionsApiFp(this.configuration)
      .updateWebhookSubscription(
        requestParameters.id,
        requestParameters.updateWebhookSubscriptionRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
