/* tslint:disable */
/* eslint-disable */
/**
 * Vertex Platform API
 * The Vertex platform includes a set of APIs and SDKs, which together provide a powerful toolset for building scalable applications based on 3D data.   See our [Developer Portal Guides](https://developer.vertexvis.com/docs/guides/getting-started/) to get started.
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from './base';

/**
 * Camera placement in 3D space.
 * @export
 * @interface Camera
 */
export interface Camera {
  /**
   *
   * @type {Vector3}
   * @memberof Camera
   */
  lookAt: Vector3;
  /**
   *
   * @type {Vector3}
   * @memberof Camera
   */
  position: Vector3;
  /**
   *
   * @type {Vector3}
   * @memberof Camera
   */
  up: Vector3;
}
/**
 * Fit camera in 3D space based on items in scene.
 * @export
 * @interface CameraFit
 */
export interface CameraFit {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CameraFit
   */
  type: CameraFitTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum CameraFitTypeEnum {
  FitVisibleSceneItems = 'fit-visible-scene-items',
}

/**
 *
 * @export
 * @interface ChangeMaterialOperation
 */
export interface ChangeMaterialOperation {
  /**
   *
   * @type {ColorMaterial}
   * @memberof ChangeMaterialOperation
   */
  material: ColorMaterial;
  /**
   * Resource object type.
   * @type {string}
   * @memberof ChangeMaterialOperation
   */
  type: ChangeMaterialOperationTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum ChangeMaterialOperationTypeEnum {
  ChangeMaterial = 'change-material',
}

/**
 *
 * @export
 * @interface ChangeTransformOperation
 */
export interface ChangeTransformOperation {
  /**
   *
   * @type {Matrix4}
   * @memberof ChangeTransformOperation
   */
  transform: Matrix4;
  /**
   * Resource object type.
   * @type {string}
   * @memberof ChangeTransformOperation
   */
  type: ChangeTransformOperationTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum ChangeTransformOperationTypeEnum {
  ChangeTransform = 'change-transform',
}

/**
 *
 * @export
 * @interface ChangeVisibilityOperation
 */
export interface ChangeVisibilityOperation {
  /**
   * Resource object type.
   * @type {string}
   * @memberof ChangeVisibilityOperation
   */
  type: ChangeVisibilityOperationTypeEnum;
  /**
   * Item visibility.
   * @type {boolean}
   * @memberof ChangeVisibilityOperation
   */
  visible: boolean;
}

/**
 * @export
 * @enum {string}
 */
export enum ChangeVisibilityOperationTypeEnum {
  ChangeVisibility = 'change-visibility',
}

/**
 *
 * @export
 * @interface ClearMaterialOperation
 */
export interface ClearMaterialOperation {
  /**
   * Resource object type.
   * @type {string}
   * @memberof ClearMaterialOperation
   */
  type: ClearMaterialOperationTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum ClearMaterialOperationTypeEnum {
  ClearMaterial = 'clear-material',
}

/**
 *
 * @export
 * @interface ClearTransformOperation
 */
export interface ClearTransformOperation {
  /**
   * Resource object type.
   * @type {string}
   * @memberof ClearTransformOperation
   */
  type: ClearTransformOperationTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum ClearTransformOperationTypeEnum {
  ClearTransform = 'clear-transform',
}

/**
 * RGB color.
 * @export
 * @interface Color3
 */
export interface Color3 {
  /**
   * Color value from 0 to 255.
   * @type {number}
   * @memberof Color3
   */
  b: number;
  /**
   * Color value from 0 to 255.
   * @type {number}
   * @memberof Color3
   */
  g: number;
  /**
   * Color value from 0 to 255.
   * @type {number}
   * @memberof Color3
   */
  r: number;
}
/**
 * Color properties describing how a material looks.
 * @export
 * @interface ColorMaterial
 */
export interface ColorMaterial {
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterial
   */
  ambient: Color3;
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterial
   */
  diffuse: Color3;
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterial
   */
  emissive: Color3;
  /**
   * Glossiness from 0 to 128.
   * @type {number}
   * @memberof ColorMaterial
   */
  glossiness: number;
  /**
   * Opacity from 0 to 100.
   * @type {number}
   * @memberof ColorMaterial
   */
  opacity: number;
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterial
   */
  specular: Color3;
}
/**
 * Color properties describing how a material looks.
 * @export
 * @interface ColorMaterialNullable
 */
export interface ColorMaterialNullable {
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterialNullable
   */
  ambient: Color3;
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterialNullable
   */
  diffuse: Color3;
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterialNullable
   */
  emissive: Color3;
  /**
   * Glossiness from 0 to 128.
   * @type {number}
   * @memberof ColorMaterialNullable
   */
  glossiness: number;
  /**
   * Opacity from 0 to 100.
   * @type {number}
   * @memberof ColorMaterialNullable
   */
  opacity: number;
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterialNullable
   */
  specular: Color3;
}
/**
 *
 * @export
 * @interface CreateFileRequest
 */
export interface CreateFileRequest {
  /**
   *
   * @type {CreateFileRequestData}
   * @memberof CreateFileRequest
   */
  data: CreateFileRequestData;
}
/**
 *
 * @export
 * @interface CreateFileRequestData
 */
export interface CreateFileRequestData {
  /**
   *
   * @type {CreateFileRequestDataAttributes}
   * @memberof CreateFileRequestData
   */
  attributes: CreateFileRequestDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateFileRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreateFileRequestDataAttributes
 */
export interface CreateFileRequestDataAttributes {
  /**
   * Name matching that of the file you are uploading, including file extension.
   * @type {string}
   * @memberof CreateFileRequestDataAttributes
   */
  name: string;
  /**
   * File name of the root part or assembly, including file extension. Required if `name` references an archive file extension, ignored otherwise.
   * @type {string}
   * @memberof CreateFileRequestDataAttributes
   */
  rootFileName?: string;
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof CreateFileRequestDataAttributes
   */
  suppliedId?: string;
}
/**
 *
 * @export
 * @interface CreateGeometrySetRequest
 */
export interface CreateGeometrySetRequest {
  /**
   *
   * @type {CreateGeometrySetRequestData}
   * @memberof CreateGeometrySetRequest
   */
  data: CreateGeometrySetRequestData;
}
/**
 *
 * @export
 * @interface CreateGeometrySetRequestData
 */
export interface CreateGeometrySetRequestData {
  /**
   *
   * @type {CreateGeometrySetRequestDataRelationships}
   * @memberof CreateGeometrySetRequestData
   */
  relationships: CreateGeometrySetRequestDataRelationships;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateGeometrySetRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreateGeometrySetRequestDataRelationships
 */
export interface CreateGeometrySetRequestDataRelationships {
  /**
   *
   * @type {FileRelationship}
   * @memberof CreateGeometrySetRequestDataRelationships
   */
  source: FileRelationship;
}
/**
 *
 * @export
 * @interface CreateHitRequest
 */
export interface CreateHitRequest {
  /**
   *
   * @type {CreateHitRequestData}
   * @memberof CreateHitRequest
   */
  data: CreateHitRequestData;
}
/**
 *
 * @export
 * @interface CreateHitRequestData
 */
export interface CreateHitRequestData {
  /**
   *
   * @type {CreateHitRequestDataAttributes}
   * @memberof CreateHitRequestData
   */
  attributes: CreateHitRequestDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateHitRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreateHitRequestDataAttributes
 */
export interface CreateHitRequestDataAttributes {
  /**
   *
   * @type {Point}
   * @memberof CreateHitRequestDataAttributes
   */
  point: Point;
  /**
   *
   * @type {Dimensions}
   * @memberof CreateHitRequestDataAttributes
   */
  viewport: Dimensions;
}
/**
 *
 * @export
 * @interface CreatePartRequest
 */
export interface CreatePartRequest {
  /**
   *
   * @type {CreatePartRequestData}
   * @memberof CreatePartRequest
   */
  data: CreatePartRequestData;
}
/**
 *
 * @export
 * @interface CreatePartRequestData
 */
export interface CreatePartRequestData {
  /**
   *
   * @type {CreatePartRequestDataAttributes}
   * @memberof CreatePartRequestData
   */
  attributes: CreatePartRequestDataAttributes;
  /**
   *
   * @type {CreateGeometrySetRequestDataRelationships}
   * @memberof CreatePartRequestData
   */
  relationships: CreateGeometrySetRequestDataRelationships;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreatePartRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreatePartRequestDataAttributes
 */
export interface CreatePartRequestDataAttributes {
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof CreatePartRequestDataAttributes
   */
  suppliedId: string;
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof CreatePartRequestDataAttributes
   */
  suppliedRevisionId: string;
}
/**
 *
 * @export
 * @interface CreateSceneAlterationRequest
 */
export interface CreateSceneAlterationRequest {
  /**
   *
   * @type {CreateSceneAlterationRequestData}
   * @memberof CreateSceneAlterationRequest
   */
  data: CreateSceneAlterationRequestData;
}
/**
 *
 * @export
 * @interface CreateSceneAlterationRequestData
 */
export interface CreateSceneAlterationRequestData {
  /**
   *
   * @type {CreateSceneAlterationRequestDataAttributes}
   * @memberof CreateSceneAlterationRequestData
   */
  attributes: CreateSceneAlterationRequestDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSceneAlterationRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreateSceneAlterationRequestDataAttributes
 */
export interface CreateSceneAlterationRequestDataAttributes {
  /**
   * List of alterations to apply.
   * @type {Array<SceneOperation>}
   * @memberof CreateSceneAlterationRequestDataAttributes
   */
  alterations: Array<SceneOperation>;
}
/**
 *
 * @export
 * @interface CreateSceneItemOverrideRequest
 */
export interface CreateSceneItemOverrideRequest {
  /**
   *
   * @type {CreateSceneItemOverrideRequestData}
   * @memberof CreateSceneItemOverrideRequest
   */
  data: CreateSceneItemOverrideRequestData;
}
/**
 *
 * @export
 * @interface CreateSceneItemOverrideRequestData
 */
export interface CreateSceneItemOverrideRequestData {
  /**
   *
   * @type {CreateSceneItemOverrideRequestDataAttributes}
   * @memberof CreateSceneItemOverrideRequestData
   */
  attributes: CreateSceneItemOverrideRequestDataAttributes;
  /**
   *
   * @type {CreateSceneItemOverrideRequestDataRelationships}
   * @memberof CreateSceneItemOverrideRequestData
   */
  relationships: CreateSceneItemOverrideRequestDataRelationships;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSceneItemOverrideRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreateSceneItemOverrideRequestDataAttributes
 */
export interface CreateSceneItemOverrideRequestDataAttributes {
  /**
   *
   * @type {ColorMaterial}
   * @memberof CreateSceneItemOverrideRequestDataAttributes
   */
  material?: ColorMaterial;
  /**
   *
   * @type {Matrix4}
   * @memberof CreateSceneItemOverrideRequestDataAttributes
   */
  transform?: Matrix4;
  /**
   * Item visibility.
   * @type {boolean}
   * @memberof CreateSceneItemOverrideRequestDataAttributes
   */
  visible?: boolean;
}
/**
 *
 * @export
 * @interface CreateSceneItemOverrideRequestDataRelationships
 */
export interface CreateSceneItemOverrideRequestDataRelationships {
  /**
   *
   * @type {SceneItemRelationship}
   * @memberof CreateSceneItemOverrideRequestDataRelationships
   */
  sceneItem: SceneItemRelationship;
}
/**
 *
 * @export
 * @interface CreateSceneItemRequest
 */
export interface CreateSceneItemRequest {
  /**
   *
   * @type {CreateSceneItemRequestData}
   * @memberof CreateSceneItemRequest
   */
  data: CreateSceneItemRequestData;
}
/**
 *
 * @export
 * @interface CreateSceneItemRequestData
 */
export interface CreateSceneItemRequestData {
  /**
   *
   * @type {CreateSceneItemRequestDataAttributes}
   * @memberof CreateSceneItemRequestData
   */
  attributes: CreateSceneItemRequestDataAttributes;
  /**
   *
   * @type {CreateSceneItemRequestDataRelationships}
   * @memberof CreateSceneItemRequestData
   */
  relationships: CreateSceneItemRequestDataRelationships;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSceneItemRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreateSceneItemRequestDataAttributes
 */
export interface CreateSceneItemRequestDataAttributes {
  /**
   *
   * @type {ColorMaterial}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  materialOverride?: ColorMaterial;
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  suppliedId?: string;
  /**
   *
   * @type {Matrix4}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  transform?: Matrix4;
  /**
   * Item visibility.
   * @type {boolean}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  visible?: boolean;
}
/**
 *
 * @export
 * @interface CreateSceneItemRequestDataRelationships
 */
export interface CreateSceneItemRequestDataRelationships {
  /**
   * Relationship to a `geometry-set` or `part-revision`.
   * @type {GeometrySetRelationship | PartRevisionRelationship}
   * @memberof CreateSceneItemRequestDataRelationships
   */
  source: GeometrySetRelationship | PartRevisionRelationship;
}
/**
 *
 * @export
 * @interface CreateSceneRequest
 */
export interface CreateSceneRequest {
  /**
   *
   * @type {CreateSceneRequestData}
   * @memberof CreateSceneRequest
   */
  data: CreateSceneRequestData;
}
/**
 *
 * @export
 * @interface CreateSceneRequestData
 */
export interface CreateSceneRequestData {
  /**
   *
   * @type {CreateSceneViewRequestDataAttributes}
   * @memberof CreateSceneRequestData
   */
  attributes: CreateSceneViewRequestDataAttributes;
  /**
   *
   * @type {CreateSceneRequestDataRelationships}
   * @memberof CreateSceneRequestData
   */
  relationships?: CreateSceneRequestDataRelationships;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSceneRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreateSceneRequestDataRelationships
 */
export interface CreateSceneRequestDataRelationships {
  /**
   *
   * @type {SceneTemplateRelationship}
   * @memberof CreateSceneRequestDataRelationships
   */
  source: SceneTemplateRelationship;
}
/**
 *
 * @export
 * @interface CreateSceneTemplateRequest
 */
export interface CreateSceneTemplateRequest {
  /**
   *
   * @type {CreateSceneTemplateRequestData}
   * @memberof CreateSceneTemplateRequest
   */
  data: CreateSceneTemplateRequestData;
}
/**
 *
 * @export
 * @interface CreateSceneTemplateRequestData
 */
export interface CreateSceneTemplateRequestData {
  /**
   *
   * @type {CreateSceneTemplateRequestDataAttributes}
   * @memberof CreateSceneTemplateRequestData
   */
  attributes: CreateSceneTemplateRequestDataAttributes;
  /**
   *
   * @type {CreateGeometrySetRequestDataRelationships}
   * @memberof CreateSceneTemplateRequestData
   */
  relationships: CreateGeometrySetRequestDataRelationships;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSceneTemplateRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreateSceneTemplateRequestDataAttributes
 */
export interface CreateSceneTemplateRequestDataAttributes {
  /**
   * Name of the scene template.
   * @type {string}
   * @memberof CreateSceneTemplateRequestDataAttributes
   */
  name?: string;
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof CreateSceneTemplateRequestDataAttributes
   */
  suppliedId: string;
}
/**
 *
 * @export
 * @interface CreateSceneViewRequest
 */
export interface CreateSceneViewRequest {
  /**
   *
   * @type {CreateSceneViewRequestData}
   * @memberof CreateSceneViewRequest
   */
  data: CreateSceneViewRequestData;
}
/**
 *
 * @export
 * @interface CreateSceneViewRequestData
 */
export interface CreateSceneViewRequestData {
  /**
   *
   * @type {CreateSceneViewRequestDataAttributes}
   * @memberof CreateSceneViewRequestData
   */
  attributes: CreateSceneViewRequestDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSceneViewRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreateSceneViewRequestDataAttributes
 */
export interface CreateSceneViewRequestDataAttributes {
  /**
   *
   * @type {Camera}
   * @memberof CreateSceneViewRequestDataAttributes
   */
  camera?: Camera;
}
/**
 *
 * @export
 * @interface CreateStreamKeyRequest
 */
export interface CreateStreamKeyRequest {
  /**
   *
   * @type {CreateStreamKeyRequestData}
   * @memberof CreateStreamKeyRequest
   */
  data: CreateStreamKeyRequestData;
}
/**
 *
 * @export
 * @interface CreateStreamKeyRequestData
 */
export interface CreateStreamKeyRequestData {
  /**
   *
   * @type {CreateStreamKeyRequestDataAttributes}
   * @memberof CreateStreamKeyRequestData
   */
  attributes: CreateStreamKeyRequestDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateStreamKeyRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreateStreamKeyRequestDataAttributes
 */
export interface CreateStreamKeyRequestDataAttributes {
  /**
   * Number of seconds before the `stream-key` expires.
   * @type {number}
   * @memberof CreateStreamKeyRequestDataAttributes
   */
  expiry?: number;
}
/**
 *
 * @export
 * @interface CreateTokenRequest
 */
export interface CreateTokenRequest {
  /**
   *
   * @type {string}
   * @memberof CreateTokenRequest
   */
  grant_type: string;
  /**
   *
   * @type {string}
   * @memberof CreateTokenRequest
   */
  scope?: string;
}
/**
 *
 * @export
 * @interface CreateTranslationInspectionRequest
 */
export interface CreateTranslationInspectionRequest {
  /**
   *
   * @type {CreateTranslationInspectionRequestData}
   * @memberof CreateTranslationInspectionRequest
   */
  data: CreateTranslationInspectionRequestData;
}
/**
 *
 * @export
 * @interface CreateTranslationInspectionRequestData
 */
export interface CreateTranslationInspectionRequestData {
  /**
   *
   * @type {CreateGeometrySetRequestDataRelationships}
   * @memberof CreateTranslationInspectionRequestData
   */
  relationships: CreateGeometrySetRequestDataRelationships;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateTranslationInspectionRequestData
   */
  type: string;
}
/**
 * An item\'s height and width.
 * @export
 * @interface Dimensions
 */
export interface Dimensions {
  /**
   * Item\'s height.
   * @type {number}
   * @memberof Dimensions
   */
  height: number;
  /**
   * Item\'s width.
   * @type {number}
   * @memberof Dimensions
   */
  width: number;
}
/**
 *
 * @export
 * @interface ErrorSource
 */
export interface ErrorSource {
  /**
   *
   * @type {string}
   * @memberof ErrorSource
   */
  parameter?: string;
  /**
   *
   * @type {string}
   * @memberof ErrorSource
   */
  pointer?: string;
}
/**
 *
 * @export
 * @interface Failure
 */
export interface Failure {
  /**
   *
   * @type {Set<Error>}
   * @memberof Failure
   */
  errors: Set<Error>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof Failure
   */
  links?: { [key: string]: Link };
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof Failure
   */
  meta?: { [key: string]: string };
}
/**
 *
 * @export
 * @interface FileList
 */
export interface FileList {
  /**
   *
   * @type {Array<FileMetadata>}
   * @memberof FileList
   */
  data: Array<FileMetadata>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof FileList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface FileMetadata
 */
export interface FileMetadata {
  /**
   *
   * @type {FileMetadataData}
   * @memberof FileMetadata
   */
  data: FileMetadataData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof FileMetadata
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface FileMetadataData
 */
export interface FileMetadataData {
  /**
   *
   * @type {FileMetadataDataAttributes}
   * @memberof FileMetadataData
   */
  attributes: FileMetadataDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof FileMetadataData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof FileMetadataData
   */
  type: string;
}
/**
 *
 * @export
 * @interface FileMetadataDataAttributes
 */
export interface FileMetadataDataAttributes {
  /**
   *
   * @type {string}
   * @memberof FileMetadataDataAttributes
   */
  created: string;
  /**
   *
   * @type {string}
   * @memberof FileMetadataDataAttributes
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof FileMetadataDataAttributes
   */
  rootFileName?: string;
  /**
   *
   * @type {string}
   * @memberof FileMetadataDataAttributes
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof FileMetadataDataAttributes
   */
  suppliedId?: string;
  /**
   *
   * @type {string}
   * @memberof FileMetadataDataAttributes
   */
  uploaded?: string;
}
/**
 * Relationship to a `file`.
 * @export
 * @interface FileRelationship
 */
export interface FileRelationship {
  /**
   *
   * @type {FileRelationshipData}
   * @memberof FileRelationship
   */
  data: FileRelationshipData;
}
/**
 *
 * @export
 * @interface FileRelationshipData
 */
export interface FileRelationshipData {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof FileRelationshipData
   */
  id: string;
  /**
   * Resource object type.
   * @type {string}
   * @memberof FileRelationshipData
   */
  type: FileRelationshipDataTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum FileRelationshipDataTypeEnum {
  File = 'file',
}

/**
 *
 * @export
 * @interface GeometrySet
 */
export interface GeometrySet {
  /**
   *
   * @type {GeometrySetData}
   * @memberof GeometrySet
   */
  data: GeometrySetData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof GeometrySet
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface GeometrySetData
 */
export interface GeometrySetData {
  /**
   *
   * @type {GeometrySetDataAttributes}
   * @memberof GeometrySetData
   */
  attributes: GeometrySetDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof GeometrySetData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof GeometrySetData
   */
  type: string;
}
/**
 *
 * @export
 * @interface GeometrySetDataAttributes
 */
export interface GeometrySetDataAttributes {
  /**
   *
   * @type {string}
   * @memberof GeometrySetDataAttributes
   */
  created: string;
}
/**
 *
 * @export
 * @interface GeometrySetList
 */
export interface GeometrySetList {
  /**
   *
   * @type {Array<GeometrySet>}
   * @memberof GeometrySetList
   */
  data: Array<GeometrySet>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof GeometrySetList
   */
  links: { [key: string]: Link };
}
/**
 * Relationship to a `geometry-set`.
 * @export
 * @interface GeometrySetRelationship
 */
export interface GeometrySetRelationship {
  /**
   *
   * @type {GeometrySetRelationshipData}
   * @memberof GeometrySetRelationship
   */
  data: GeometrySetRelationshipData;
}
/**
 *
 * @export
 * @interface GeometrySetRelationshipData
 */
export interface GeometrySetRelationshipData {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof GeometrySetRelationshipData
   */
  id: string;
  /**
   * Resource object type.
   * @type {string}
   * @memberof GeometrySetRelationshipData
   */
  type: GeometrySetRelationshipDataTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum GeometrySetRelationshipDataTypeEnum {
  GeometrySet = 'geometry-set',
}

/**
 *
 * @export
 * @interface Hit
 */
export interface Hit {
  /**
   *
   * @type {HitData}
   * @memberof Hit
   */
  data: HitData;
  /**
   *
   * @type {Array<HitResult | SceneItem>}
   * @memberof Hit
   */
  included: Array<HitResult | SceneItem>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof Hit
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface HitData
 */
export interface HitData {
  /**
   *
   * @type {GeometrySetDataAttributes}
   * @memberof HitData
   */
  attributes: GeometrySetDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof HitData
   */
  id: string;
  /**
   *
   * @type {HitDataRelationships}
   * @memberof HitData
   */
  relationships: HitDataRelationships;
  /**
   *
   * @type {string}
   * @memberof HitData
   */
  type: string;
}
/**
 *
 * @export
 * @interface HitDataRelationships
 */
export interface HitDataRelationships {
  /**
   *
   * @type {Array<RelationshipData>}
   * @memberof HitDataRelationships
   */
  results: Array<RelationshipData>;
}
/**
 *
 * @export
 * @interface HitResult
 */
export interface HitResult {
  /**
   *
   * @type {HitResultData}
   * @memberof HitResult
   */
  data: HitResultData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof HitResult
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface HitResultData
 */
export interface HitResultData {
  /**
   *
   * @type {HitResultDataAttributes}
   * @memberof HitResultData
   */
  attributes: HitResultDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof HitResultData
   */
  id: string;
  /**
   *
   * @type {HitResultDataRelationships}
   * @memberof HitResultData
   */
  relationships: HitResultDataRelationships;
  /**
   *
   * @type {string}
   * @memberof HitResultData
   */
  type: string;
}
/**
 *
 * @export
 * @interface HitResultDataAttributes
 */
export interface HitResultDataAttributes {
  /**
   *
   * @type {Vector3}
   * @memberof HitResultDataAttributes
   */
  normal: Vector3;
  /**
   *
   * @type {Vector3}
   * @memberof HitResultDataAttributes
   */
  point: Vector3;
}
/**
 *
 * @export
 * @interface HitResultDataRelationships
 */
export interface HitResultDataRelationships {
  /**
   *
   * @type {RelationshipData}
   * @memberof HitResultDataRelationships
   */
  sceneItem: RelationshipData;
}
/**
 *
 * @export
 * @interface Link
 */
export interface Link {
  /**
   *
   * @type {string}
   * @memberof Link
   */
  href: string;
}
/**
 * Color material override.
 * @export
 * @interface MaterialOverride
 */
export interface MaterialOverride {
  /**
   *
   * @type {ColorMaterial}
   * @memberof MaterialOverride
   */
  value?: ColorMaterial;
}
/**
 * 4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.
 * @export
 * @interface Matrix4
 */
export interface Matrix4 {
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4
   */
  r0: Vector4;
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4
   */
  r1: Vector4;
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4
   */
  r2: Vector4;
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4
   */
  r3: Vector4;
}
/**
 * 4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.
 * @export
 * @interface Matrix4Nullable
 */
export interface Matrix4Nullable {
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4Nullable
   */
  r0: Vector4;
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4Nullable
   */
  r1: Vector4;
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4Nullable
   */
  r2: Vector4;
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4Nullable
   */
  r3: Vector4;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  detail?: string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  id?: string;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof ModelError
   */
  links?: { [key: string]: Link };
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof ModelError
   */
  meta?: { [key: string]: string };
  /**
   *
   * @type {ErrorSource}
   * @memberof ModelError
   */
  source?: ErrorSource;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  title?: string;
}
/**
 *
 * @export
 * @interface OAuth2BadRequest
 */
export interface OAuth2BadRequest {
  /**
   *
   * @type {string}
   * @memberof OAuth2BadRequest
   */
  error: string;
}
/**
 *
 * @export
 * @interface OAuth2Token
 */
export interface OAuth2Token {
  /**
   *
   * @type {string}
   * @memberof OAuth2Token
   */
  access_token: string;
  /**
   *
   * @type {string}
   * @memberof OAuth2Token
   */
  account_id: string;
  /**
   *
   * @type {number}
   * @memberof OAuth2Token
   */
  expires_in: number;
  /**
   *
   * @type {Array<string>}
   * @memberof OAuth2Token
   */
  scopes: Array<string>;
  /**
   *
   * @type {string}
   * @memberof OAuth2Token
   */
  token_type: string;
}
/**
 *
 * @export
 * @interface Part
 */
export interface Part {
  /**
   *
   * @type {PartData}
   * @memberof Part
   */
  data: PartData;
  /**
   *
   * @type {Array<PartRevision>}
   * @memberof Part
   */
  included?: Array<PartRevision>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof Part
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface PartData
 */
export interface PartData {
  /**
   *
   * @type {PartDataAttributes}
   * @memberof PartData
   */
  attributes: PartDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PartData
   */
  id: string;
  /**
   *
   * @type {PartDataRelationships}
   * @memberof PartData
   */
  relationships: PartDataRelationships;
  /**
   *
   * @type {string}
   * @memberof PartData
   */
  type: string;
}
/**
 *
 * @export
 * @interface PartDataAttributes
 */
export interface PartDataAttributes {
  /**
   *
   * @type {string}
   * @memberof PartDataAttributes
   */
  created: string;
  /**
   *
   * @type {string}
   * @memberof PartDataAttributes
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof PartDataAttributes
   */
  suppliedId: string;
}
/**
 *
 * @export
 * @interface PartDataRelationships
 */
export interface PartDataRelationships {
  /**
   *
   * @type {Array<PartDataRelationshipsPartRevisions>}
   * @memberof PartDataRelationships
   */
  partRevisions: Array<PartDataRelationshipsPartRevisions>;
}
/**
 *
 * @export
 * @interface PartDataRelationshipsPartRevisions
 */
export interface PartDataRelationshipsPartRevisions {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PartDataRelationshipsPartRevisions
   */
  id: string;
  /**
   * Resource object type.
   * @type {string}
   * @memberof PartDataRelationshipsPartRevisions
   */
  type: PartDataRelationshipsPartRevisionsTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum PartDataRelationshipsPartRevisionsTypeEnum {
  PartRevision = 'part-revision',
}

/**
 *
 * @export
 * @interface PartList
 */
export interface PartList {
  /**
   *
   * @type {Array<Part>}
   * @memberof PartList
   */
  data: Array<Part>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PartList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface PartRelationshipData
 */
export interface PartRelationshipData {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PartRelationshipData
   */
  id: string;
  /**
   * Resource object type.
   * @type {string}
   * @memberof PartRelationshipData
   */
  type: PartRelationshipDataTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum PartRelationshipDataTypeEnum {
  Part = 'part',
}

/**
 *
 * @export
 * @interface PartRevision
 */
export interface PartRevision {
  /**
   *
   * @type {PartRevisionData}
   * @memberof PartRevision
   */
  data: PartRevisionData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PartRevision
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface PartRevisionData
 */
export interface PartRevisionData {
  /**
   *
   * @type {PartRevisionDataAttributes}
   * @memberof PartRevisionData
   */
  attributes: PartRevisionDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PartRevisionData
   */
  id: string;
  /**
   *
   * @type {PartRevisionDataRelationships}
   * @memberof PartRevisionData
   */
  relationships: PartRevisionDataRelationships;
  /**
   *
   * @type {string}
   * @memberof PartRevisionData
   */
  type: string;
}
/**
 *
 * @export
 * @interface PartRevisionDataAttributes
 */
export interface PartRevisionDataAttributes {
  /**
   *
   * @type {string}
   * @memberof PartRevisionDataAttributes
   */
  created: string;
  /**
   *
   * @type {string}
   * @memberof PartRevisionDataAttributes
   */
  suppliedId: string;
}
/**
 *
 * @export
 * @interface PartRevisionDataRelationships
 */
export interface PartRevisionDataRelationships {
  /**
   *
   * @type {GeometrySetRelationshipData}
   * @memberof PartRevisionDataRelationships
   */
  geometrySet?: GeometrySetRelationshipData;
  /**
   *
   * @type {PartRelationshipData}
   * @memberof PartRevisionDataRelationships
   */
  part?: PartRelationshipData;
}
/**
 *
 * @export
 * @interface PartRevisionList
 */
export interface PartRevisionList {
  /**
   *
   * @type {Array<PartRevision>}
   * @memberof PartRevisionList
   */
  data: Array<PartRevision>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PartRevisionList
   */
  links: { [key: string]: Link };
}
/**
 * Relationship to a `part-revision`.
 * @export
 * @interface PartRevisionRelationship
 */
export interface PartRevisionRelationship {
  /**
   *
   * @type {PartRevisionRelationshipData}
   * @memberof PartRevisionRelationship
   */
  data: PartRevisionRelationshipData;
}
/**
 *
 * @export
 * @interface PartRevisionRelationshipData
 */
export interface PartRevisionRelationshipData {
  /**
   * ID of the resource.
   * @type {string | PartRevisionSuppliedId}
   * @memberof PartRevisionRelationshipData
   */
  id: string | PartRevisionSuppliedId;
  /**
   * Resource object type.
   * @type {string}
   * @memberof PartRevisionRelationshipData
   */
  type: PartRevisionRelationshipDataTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum PartRevisionRelationshipDataTypeEnum {
  PartRevision = 'part-revision',
}

/**
 *
 * @export
 * @interface PartRevisionSuppliedId
 */
export interface PartRevisionSuppliedId {
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof PartRevisionSuppliedId
   */
  suppliedPartId: string;
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof PartRevisionSuppliedId
   */
  suppliedRevisionId: string;
}
/**
 * 2D point.
 * @export
 * @interface Point
 */
export interface Point {
  /**
   * x-axis coordinate.
   * @type {number}
   * @memberof Point
   */
  dx: number;
  /**
   * y-axis coordinate.
   * @type {number}
   * @memberof Point
   */
  dy: number;
}
/**
 * Resource object type.
 * @export
 * @enum {string}
 */
export enum QueryAll {
  All = 'all',
}

/**
 *
 * @export
 * @interface QueryByCollection
 */
export interface QueryByCollection {
  /**
   *
   * @type {QueryByCollectionData}
   * @memberof QueryByCollection
   */
  data: QueryByCollectionData;
}
/**
 *
 * @export
 * @interface QueryByCollectionData
 */
export interface QueryByCollectionData {
  /**
   *
   * @type {QueryByCollectionDataAttributes}
   * @memberof QueryByCollectionData
   */
  attributes: QueryByCollectionDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof QueryByCollectionData
   */
  type: QueryByCollectionDataTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum QueryByCollectionDataTypeEnum {
  QueryByCollection = 'query-by-collection',
}

/**
 *
 * @export
 * @interface QueryByCollectionDataAttributes
 */
export interface QueryByCollectionDataAttributes {
  /**
   * Resource object type.
   * @type {string}
   * @memberof QueryByCollectionDataAttributes
   */
  type: QueryByCollectionDataAttributesTypeEnum;
  /**
   * Query `scene-items`.
   * @type {Array<QueryById>}
   * @memberof QueryByCollectionDataAttributes
   */
  values: Array<QueryById>;
}

/**
 * @export
 * @enum {string}
 */
export enum QueryByCollectionDataAttributesTypeEnum {
  And = 'and',
  Or = 'or',
}

/**
 *
 * @export
 * @interface QueryById
 */
export interface QueryById {
  /**
   *
   * @type {QueryByIdData}
   * @memberof QueryById
   */
  data: QueryByIdData;
}
/**
 *
 * @export
 * @interface QueryByIdData
 */
export interface QueryByIdData {
  /**
   *
   * @type {QueryByIdDataAttributes}
   * @memberof QueryByIdData
   */
  attributes: QueryByIdDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof QueryByIdData
   */
  type: QueryByIdDataTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum QueryByIdDataTypeEnum {
  QueryById = 'query-by-id',
}

/**
 *
 * @export
 * @interface QueryByIdDataAttributes
 */
export interface QueryByIdDataAttributes {
  /**
   * Resource object type.
   * @type {string}
   * @memberof QueryByIdDataAttributes
   */
  type: QueryByIdDataAttributesTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof QueryByIdDataAttributes
   */
  value: string;
}

/**
 * @export
 * @enum {string}
 */
export enum QueryByIdDataAttributesTypeEnum {
  Id = 'id',
  SuppliedId = 'suppliedId',
}

/**
 *
 * @export
 * @interface QueuedJob
 */
export interface QueuedJob {
  /**
   *
   * @type {QueuedJobData}
   * @memberof QueuedJob
   */
  data: QueuedJobData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof QueuedJob
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface QueuedJobData
 */
export interface QueuedJobData {
  /**
   *
   * @type {QueuedJobDataAttributes}
   * @memberof QueuedJobData
   */
  attributes: QueuedJobDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof QueuedJobData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof QueuedJobData
   */
  type: string;
}
/**
 *
 * @export
 * @interface QueuedJobDataAttributes
 */
export interface QueuedJobDataAttributes {
  /**
   *
   * @type {Set<Error>}
   * @memberof QueuedJobDataAttributes
   */
  errors?: Set<Error>;
  /**
   *
   * @type {string}
   * @memberof QueuedJobDataAttributes
   */
  status: string;
}
/**
 *
 * @export
 * @interface RelationshipData
 */
export interface RelationshipData {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof RelationshipData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof RelationshipData
   */
  type: string;
}
/**
 *
 * @export
 * @interface RevokeOAuth2TokenRequest
 */
export interface RevokeOAuth2TokenRequest {
  /**
   *
   * @type {RevokeOAuth2TokenRequestData}
   * @memberof RevokeOAuth2TokenRequest
   */
  data: RevokeOAuth2TokenRequestData;
}
/**
 *
 * @export
 * @interface RevokeOAuth2TokenRequestData
 */
export interface RevokeOAuth2TokenRequestData {
  /**
   *
   * @type {RevokeOAuth2TokenRequestDataAttributes}
   * @memberof RevokeOAuth2TokenRequestData
   */
  attributes: RevokeOAuth2TokenRequestDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof RevokeOAuth2TokenRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface RevokeOAuth2TokenRequestDataAttributes
 */
export interface RevokeOAuth2TokenRequestDataAttributes {
  /**
   * Token to revoke.
   * @type {string}
   * @memberof RevokeOAuth2TokenRequestDataAttributes
   */
  token: string;
}
/**
 *
 * @export
 * @interface Scene
 */
export interface Scene {
  /**
   *
   * @type {SceneData}
   * @memberof Scene
   */
  data: SceneData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof Scene
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneAlteration
 */
export interface SceneAlteration {
  /**
   *
   * @type {SceneAlterationData}
   * @memberof SceneAlteration
   */
  data: SceneAlterationData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneAlteration
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneAlterationData
 */
export interface SceneAlterationData {
  /**
   *
   * @type {GeometrySetDataAttributes}
   * @memberof SceneAlterationData
   */
  attributes: GeometrySetDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneAlterationData
   */
  id: string;
  /**
   *
   * @type {SceneAlterationDataRelationships}
   * @memberof SceneAlterationData
   */
  relationships: SceneAlterationDataRelationships;
  /**
   *
   * @type {string}
   * @memberof SceneAlterationData
   */
  type: string;
}
/**
 *
 * @export
 * @interface SceneAlterationDataRelationships
 */
export interface SceneAlterationDataRelationships {
  /**
   *
   * @type {SceneViewRelationship}
   * @memberof SceneAlterationDataRelationships
   */
  sceneView: SceneViewRelationship;
}
/**
 *
 * @export
 * @interface SceneAlterationList
 */
export interface SceneAlterationList {
  /**
   *
   * @type {Array<SceneAlteration>}
   * @memberof SceneAlterationList
   */
  data: Array<SceneAlteration>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneAlterationList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneData
 */
export interface SceneData {
  /**
   *
   * @type {SceneDataAttributes}
   * @memberof SceneData
   */
  attributes: SceneDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof SceneData
   */
  type: string;
}
/**
 *
 * @export
 * @interface SceneDataAttributes
 */
export interface SceneDataAttributes {
  /**
   *
   * @type {Camera}
   * @memberof SceneDataAttributes
   */
  camera?: Camera;
  /**
   *
   * @type {string}
   * @memberof SceneDataAttributes
   */
  state: string;
}
/**
 *
 * @export
 * @interface SceneItem
 */
export interface SceneItem {
  /**
   *
   * @type {SceneItemData}
   * @memberof SceneItem
   */
  data: SceneItemData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneItem
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneItemData
 */
export interface SceneItemData {
  /**
   *
   * @type {SceneItemDataAttributes}
   * @memberof SceneItemData
   */
  attributes: SceneItemDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneItemData
   */
  id: string;
  /**
   *
   * @type {SceneItemDataRelationships}
   * @memberof SceneItemData
   */
  relationships: SceneItemDataRelationships;
  /**
   *
   * @type {string}
   * @memberof SceneItemData
   */
  type: string;
}
/**
 *
 * @export
 * @interface SceneItemDataAttributes
 */
export interface SceneItemDataAttributes {
  /**
   *
   * @type {ColorMaterial}
   * @memberof SceneItemDataAttributes
   */
  materialOverride?: ColorMaterial;
  /**
   *
   * @type {string}
   * @memberof SceneItemDataAttributes
   */
  suppliedId: string;
  /**
   *
   * @type {Matrix4}
   * @memberof SceneItemDataAttributes
   */
  transform: Matrix4;
  /**
   *
   * @type {boolean}
   * @memberof SceneItemDataAttributes
   */
  visible: boolean;
}
/**
 *
 * @export
 * @interface SceneItemDataRelationships
 */
export interface SceneItemDataRelationships {
  /**
   *
   * @type {SceneItemRelationship}
   * @memberof SceneItemDataRelationships
   */
  parent?: SceneItemRelationship;
  /**
   *
   * @type {GeometrySetRelationship | PartRevisionRelationship}
   * @memberof SceneItemDataRelationships
   */
  source?: GeometrySetRelationship | PartRevisionRelationship;
}
/**
 *
 * @export
 * @interface SceneItemList
 */
export interface SceneItemList {
  /**
   *
   * @type {Array<SceneItem>}
   * @memberof SceneItemList
   */
  data: Array<SceneItem>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneItemList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneItemOverride
 */
export interface SceneItemOverride {
  /**
   *
   * @type {SceneItemOverrideData}
   * @memberof SceneItemOverride
   */
  data: SceneItemOverrideData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneItemOverride
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneItemOverrideData
 */
export interface SceneItemOverrideData {
  /**
   *
   * @type {SceneItemOverrideDataAttributes}
   * @memberof SceneItemOverrideData
   */
  attributes: SceneItemOverrideDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneItemOverrideData
   */
  id: string;
  /**
   *
   * @type {SceneItemOverrideDataRelationships}
   * @memberof SceneItemOverrideData
   */
  relationships: SceneItemOverrideDataRelationships;
  /**
   *
   * @type {string}
   * @memberof SceneItemOverrideData
   */
  type: string;
}
/**
 *
 * @export
 * @interface SceneItemOverrideDataAttributes
 */
export interface SceneItemOverrideDataAttributes {
  /**
   *
   * @type {string}
   * @memberof SceneItemOverrideDataAttributes
   */
  created: string;
  /**
   *
   * @type {ColorMaterial}
   * @memberof SceneItemOverrideDataAttributes
   */
  material?: ColorMaterial;
  /**
   *
   * @type {Matrix4}
   * @memberof SceneItemOverrideDataAttributes
   */
  transform?: Matrix4;
  /**
   *
   * @type {boolean}
   * @memberof SceneItemOverrideDataAttributes
   */
  visible?: boolean;
}
/**
 *
 * @export
 * @interface SceneItemOverrideDataRelationships
 */
export interface SceneItemOverrideDataRelationships {
  /**
   *
   * @type {SceneItemRelationship}
   * @memberof SceneItemOverrideDataRelationships
   */
  sceneItem: SceneItemRelationship;
  /**
   *
   * @type {SceneViewRelationship}
   * @memberof SceneItemOverrideDataRelationships
   */
  sceneView: SceneViewRelationship;
}
/**
 *
 * @export
 * @interface SceneItemOverrideList
 */
export interface SceneItemOverrideList {
  /**
   *
   * @type {Array<SceneItemOverride>}
   * @memberof SceneItemOverrideList
   */
  data: Array<SceneItemOverride>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneItemOverrideList
   */
  links: { [key: string]: Link };
}
/**
 * Relationship to a `scene-item`.
 * @export
 * @interface SceneItemRelationship
 */
export interface SceneItemRelationship {
  /**
   *
   * @type {SceneItemRelationshipData}
   * @memberof SceneItemRelationship
   */
  data: SceneItemRelationshipData;
}
/**
 *
 * @export
 * @interface SceneItemRelationshipData
 */
export interface SceneItemRelationshipData {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneItemRelationshipData
   */
  id: string;
  /**
   * Resource object type.
   * @type {string}
   * @memberof SceneItemRelationshipData
   */
  type: SceneItemRelationshipDataTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum SceneItemRelationshipDataTypeEnum {
  SceneItem = 'scene-item',
}

/**
 *
 * @export
 * @interface SceneList
 */
export interface SceneList {
  /**
   *
   * @type {Array<Scene>}
   * @memberof SceneList
   */
  data: Array<Scene>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneOperation
 */
export interface SceneOperation {
  /**
   * List of operations to perform on `scene-items` matching the query.
   * @type {Array<ChangeVisibilityOperation | ChangeMaterialOperation | ClearMaterialOperation | ChangeTransformOperation | ClearTransformOperation>}
   * @memberof SceneOperation
   */
  operations: Array<
    | ChangeVisibilityOperation
    | ChangeMaterialOperation
    | ClearMaterialOperation
    | ChangeTransformOperation
    | ClearTransformOperation
  >;
  /**
   * Query `scene-items`. Use `query-by-collection` to combine multiple queries.
   * @type {QueryById | QueryByCollection | QueryAll}
   * @memberof SceneOperation
   */
  query: QueryById | QueryByCollection | QueryAll;
}
/**
 * Relationship to a `scene`.
 * @export
 * @interface SceneRelationship
 */
export interface SceneRelationship {
  /**
   *
   * @type {SceneRelationshipData}
   * @memberof SceneRelationship
   */
  data: SceneRelationshipData;
}
/**
 *
 * @export
 * @interface SceneRelationshipData
 */
export interface SceneRelationshipData {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneRelationshipData
   */
  id: string;
  /**
   * Resource object type.
   * @type {string}
   * @memberof SceneRelationshipData
   */
  type: SceneRelationshipDataTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum SceneRelationshipDataTypeEnum {
  Scene = 'scene',
}

/**
 *
 * @export
 * @interface SceneTemplate
 */
export interface SceneTemplate {
  /**
   *
   * @type {SceneTemplateData}
   * @memberof SceneTemplate
   */
  data: SceneTemplateData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneTemplate
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneTemplateData
 */
export interface SceneTemplateData {
  /**
   *
   * @type {SceneTemplateDataAttributes}
   * @memberof SceneTemplateData
   */
  attributes: SceneTemplateDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneTemplateData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof SceneTemplateData
   */
  type: string;
}
/**
 *
 * @export
 * @interface SceneTemplateDataAttributes
 */
export interface SceneTemplateDataAttributes {
  /**
   *
   * @type {string}
   * @memberof SceneTemplateDataAttributes
   */
  created: string;
  /**
   *
   * @type {string}
   * @memberof SceneTemplateDataAttributes
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof SceneTemplateDataAttributes
   */
  suppliedId: string;
}
/**
 *
 * @export
 * @interface SceneTemplateList
 */
export interface SceneTemplateList {
  /**
   *
   * @type {Array<SceneTemplate>}
   * @memberof SceneTemplateList
   */
  data: Array<SceneTemplate>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneTemplateList
   */
  links: { [key: string]: Link };
}
/**
 * Relationship to a `scene-template`.
 * @export
 * @interface SceneTemplateRelationship
 */
export interface SceneTemplateRelationship {
  /**
   *
   * @type {SceneTemplateRelationshipData}
   * @memberof SceneTemplateRelationship
   */
  data: SceneTemplateRelationshipData;
}
/**
 *
 * @export
 * @interface SceneTemplateRelationshipData
 */
export interface SceneTemplateRelationshipData {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneTemplateRelationshipData
   */
  id: string;
  /**
   * Resource object type.
   * @type {string}
   * @memberof SceneTemplateRelationshipData
   */
  type: SceneTemplateRelationshipDataTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum SceneTemplateRelationshipDataTypeEnum {
  SceneTemplate = 'scene-template',
}

/**
 *
 * @export
 * @interface SceneView
 */
export interface SceneView {
  /**
   *
   * @type {SceneViewData}
   * @memberof SceneView
   */
  data: SceneViewData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneView
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneViewData
 */
export interface SceneViewData {
  /**
   *
   * @type {SceneViewDataAttributes}
   * @memberof SceneViewData
   */
  attributes: SceneViewDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneViewData
   */
  id: string;
  /**
   *
   * @type {SceneViewDataRelationships}
   * @memberof SceneViewData
   */
  relationships: SceneViewDataRelationships;
  /**
   *
   * @type {string}
   * @memberof SceneViewData
   */
  type: string;
}
/**
 *
 * @export
 * @interface SceneViewDataAttributes
 */
export interface SceneViewDataAttributes {
  /**
   *
   * @type {Camera}
   * @memberof SceneViewDataAttributes
   */
  camera: Camera;
  /**
   *
   * @type {string}
   * @memberof SceneViewDataAttributes
   */
  created: string;
}
/**
 *
 * @export
 * @interface SceneViewDataRelationships
 */
export interface SceneViewDataRelationships {
  /**
   *
   * @type {SceneRelationship}
   * @memberof SceneViewDataRelationships
   */
  scene: SceneRelationship;
}
/**
 * Relationship to a `scene-view`.
 * @export
 * @interface SceneViewRelationship
 */
export interface SceneViewRelationship {
  /**
   *
   * @type {SceneViewRelationshipData}
   * @memberof SceneViewRelationship
   */
  data: SceneViewRelationshipData;
}
/**
 *
 * @export
 * @interface SceneViewRelationshipData
 */
export interface SceneViewRelationshipData {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneViewRelationshipData
   */
  id: string;
  /**
   * Resource object type.
   * @type {string}
   * @memberof SceneViewRelationshipData
   */
  type: SceneViewRelationshipDataTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum SceneViewRelationshipDataTypeEnum {
  SceneView = 'scene-view',
}

/**
 *
 * @export
 * @interface StreamKey
 */
export interface StreamKey {
  /**
   *
   * @type {StreamKeyData}
   * @memberof StreamKey
   */
  data: StreamKeyData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof StreamKey
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface StreamKeyData
 */
export interface StreamKeyData {
  /**
   *
   * @type {StreamKeyDataAttributes}
   * @memberof StreamKeyData
   */
  attributes: StreamKeyDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof StreamKeyData
   */
  id: string;
  /**
   *
   * @type {SceneViewDataRelationships}
   * @memberof StreamKeyData
   */
  relationships: SceneViewDataRelationships;
  /**
   *
   * @type {string}
   * @memberof StreamKeyData
   */
  type: string;
}
/**
 *
 * @export
 * @interface StreamKeyDataAttributes
 */
export interface StreamKeyDataAttributes {
  /**
   *
   * @type {string}
   * @memberof StreamKeyDataAttributes
   */
  created: string;
  /**
   *
   * @type {number}
   * @memberof StreamKeyDataAttributes
   */
  expiry: number;
  /**
   *
   * @type {string}
   * @memberof StreamKeyDataAttributes
   */
  key?: string;
}
/**
 *
 * @export
 * @interface StreamKeyList
 */
export interface StreamKeyList {
  /**
   *
   * @type {Array<StreamKey>}
   * @memberof StreamKeyList
   */
  data: Array<StreamKey>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof StreamKeyList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface TranslationInspectionJob
 */
export interface TranslationInspectionJob {
  /**
   *
   * @type {TranslationInspectionJobData}
   * @memberof TranslationInspectionJob
   */
  data: TranslationInspectionJobData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof TranslationInspectionJob
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface TranslationInspectionJobData
 */
export interface TranslationInspectionJobData {
  /**
   *
   * @type {TranslationInspectionJobDataAttributes}
   * @memberof TranslationInspectionJobData
   */
  attributes: TranslationInspectionJobDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof TranslationInspectionJobData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof TranslationInspectionJobData
   */
  type: string;
}
/**
 *
 * @export
 * @interface TranslationInspectionJobDataAttributes
 */
export interface TranslationInspectionJobDataAttributes {
  /**
   *
   * @type {Array<string>}
   * @memberof TranslationInspectionJobDataAttributes
   */
  missing: Array<string>;
  /**
   *
   * @type {string}
   * @memberof TranslationInspectionJobDataAttributes
   */
  status: string;
}
/**
 *
 * @export
 * @interface UpdatePartRevisionRequest
 */
export interface UpdatePartRevisionRequest {
  /**
   *
   * @type {UpdatePartRevisionRequestData}
   * @memberof UpdatePartRevisionRequest
   */
  data: UpdatePartRevisionRequestData;
}
/**
 *
 * @export
 * @interface UpdatePartRevisionRequestData
 */
export interface UpdatePartRevisionRequestData {
  /**
   *
   * @type {UpdatePartRevisionRequestDataAttributes}
   * @memberof UpdatePartRevisionRequestData
   */
  attributes: UpdatePartRevisionRequestDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof UpdatePartRevisionRequestData
   */
  id: string;
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdatePartRevisionRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface UpdatePartRevisionRequestDataAttributes
 */
export interface UpdatePartRevisionRequestDataAttributes {
  /**
   * Metadata about the `part-revision`.
   * @type {{ [key: string]: UpdatePartRevisionRequestDataAttributesMetadata; }}
   * @memberof UpdatePartRevisionRequestDataAttributes
   */
  metadata?: { [key: string]: UpdatePartRevisionRequestDataAttributesMetadata };
}
/**
 *
 * @export
 * @interface UpdatePartRevisionRequestDataAttributesMetadata
 */
export interface UpdatePartRevisionRequestDataAttributesMetadata {
  /**
   * Type of metadata value.
   * @type {string}
   * @memberof UpdatePartRevisionRequestDataAttributesMetadata
   */
  type: UpdatePartRevisionRequestDataAttributesMetadataTypeEnum;
  /**
   * Metadata value.
   * @type {string}
   * @memberof UpdatePartRevisionRequestDataAttributesMetadata
   */
  value?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum UpdatePartRevisionRequestDataAttributesMetadataTypeEnum {
  String = 'string',
  Long = 'long',
  Float = 'float',
  Date = 'date',
  Null = 'null',
}

/**
 *
 * @export
 * @interface UpdateSceneItemOverrideRequest
 */
export interface UpdateSceneItemOverrideRequest {
  /**
   *
   * @type {UpdateSceneItemOverrideRequestData}
   * @memberof UpdateSceneItemOverrideRequest
   */
  data: UpdateSceneItemOverrideRequestData;
}
/**
 *
 * @export
 * @interface UpdateSceneItemOverrideRequestData
 */
export interface UpdateSceneItemOverrideRequestData {
  /**
   *
   * @type {UpdateSceneItemOverrideRequestDataAttributes}
   * @memberof UpdateSceneItemOverrideRequestData
   */
  attributes: UpdateSceneItemOverrideRequestDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof UpdateSceneItemOverrideRequestData
   */
  id: string;
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdateSceneItemOverrideRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface UpdateSceneItemOverrideRequestDataAttributes
 */
export interface UpdateSceneItemOverrideRequestDataAttributes {
  /**
   *
   * @type {ColorMaterialNullable}
   * @memberof UpdateSceneItemOverrideRequestDataAttributes
   */
  material?: ColorMaterialNullable | null;
  /**
   *
   * @type {Matrix4Nullable}
   * @memberof UpdateSceneItemOverrideRequestDataAttributes
   */
  transform?: Matrix4Nullable | null;
  /**
   * Item visibility.
   * @type {boolean}
   * @memberof UpdateSceneItemOverrideRequestDataAttributes
   */
  visible?: boolean | null;
}
/**
 *
 * @export
 * @interface UpdateSceneItemRequest
 */
export interface UpdateSceneItemRequest {
  /**
   *
   * @type {UpdateSceneItemRequestData}
   * @memberof UpdateSceneItemRequest
   */
  data: UpdateSceneItemRequestData;
}
/**
 *
 * @export
 * @interface UpdateSceneItemRequestData
 */
export interface UpdateSceneItemRequestData {
  /**
   *
   * @type {UpdateSceneItemRequestDataAttributes}
   * @memberof UpdateSceneItemRequestData
   */
  attributes: UpdateSceneItemRequestDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdateSceneItemRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface UpdateSceneItemRequestDataAttributes
 */
export interface UpdateSceneItemRequestDataAttributes {
  /**
   *
   * @type {MaterialOverride}
   * @memberof UpdateSceneItemRequestDataAttributes
   */
  materialOverride?: MaterialOverride;
  /**
   *
   * @type {Matrix4}
   * @memberof UpdateSceneItemRequestDataAttributes
   */
  transform?: Matrix4;
  /**
   * Item visibility.
   * @type {boolean}
   * @memberof UpdateSceneItemRequestDataAttributes
   */
  visible?: boolean;
}
/**
 *
 * @export
 * @interface UpdateSceneRequest
 */
export interface UpdateSceneRequest {
  /**
   *
   * @type {UpdateSceneRequestData}
   * @memberof UpdateSceneRequest
   */
  data: UpdateSceneRequestData;
}
/**
 *
 * @export
 * @interface UpdateSceneRequestData
 */
export interface UpdateSceneRequestData {
  /**
   *
   * @type {UpdateSceneRequestDataAttributes}
   * @memberof UpdateSceneRequestData
   */
  attributes: UpdateSceneRequestDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdateSceneRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface UpdateSceneRequestDataAttributes
 */
export interface UpdateSceneRequestDataAttributes {
  /**
   *
   * @type {Camera | CameraFit}
   * @memberof UpdateSceneRequestDataAttributes
   */
  camera?: Camera | CameraFit;
  /**
   * State of the scene.
   * @type {string}
   * @memberof UpdateSceneRequestDataAttributes
   */
  state?: UpdateSceneRequestDataAttributesStateEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum UpdateSceneRequestDataAttributesStateEnum {
  Draft = 'draft',
  Commit = 'commit',
}

/**
 *
 * @export
 * @interface UpdateSceneViewRequest
 */
export interface UpdateSceneViewRequest {
  /**
   *
   * @type {UpdateSceneViewRequestData}
   * @memberof UpdateSceneViewRequest
   */
  data: UpdateSceneViewRequestData;
}
/**
 *
 * @export
 * @interface UpdateSceneViewRequestData
 */
export interface UpdateSceneViewRequestData {
  /**
   *
   * @type {UpdateSceneViewRequestDataAttributes}
   * @memberof UpdateSceneViewRequestData
   */
  attributes: UpdateSceneViewRequestDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdateSceneViewRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface UpdateSceneViewRequestDataAttributes
 */
export interface UpdateSceneViewRequestDataAttributes {
  /**
   *
   * @type {Camera | CameraFit}
   * @memberof UpdateSceneViewRequestDataAttributes
   */
  camera?: Camera | CameraFit;
}
/**
 * 3D vector.
 * @export
 * @interface Vector3
 */
export interface Vector3 {
  /**
   * x-axis coordinate.
   * @type {number}
   * @memberof Vector3
   */
  x: number;
  /**
   * y-axis coordinate.
   * @type {number}
   * @memberof Vector3
   */
  y: number;
  /**
   * z-axis coordinate.
   * @type {number}
   * @memberof Vector3
   */
  z: number;
}
/**
 * 4D vector.
 * @export
 * @interface Vector4
 */
export interface Vector4 {
  /**
   * w value.
   * @type {number}
   * @memberof Vector4
   */
  w: number;
  /**
   * x-axis coordinate.
   * @type {number}
   * @memberof Vector4
   */
  x: number;
  /**
   * y-axis coordinate.
   * @type {number}
   * @memberof Vector4
   */
  y: number;
  /**
   * z-axis coordinate.
   * @type {number}
   * @memberof Vector4
   */
  z: number;
}

/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `file`. Once created, upload file content via the uploadFile API. For details including supported file formats, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateFileRequest_data|true|| |▹ attributes|CreateFileRequest_data_attributes|true|| |▹▹ name|string|true|Name matching that of the file you are uploading, including file extension.| |▹▹ rootFileName|string|false|File name of the root part or assembly, including file extension. Required if `name` references an archive file extension, ignored otherwise.| |▹▹ suppliedId|string|false|ID provided for correlation. For example, an existing ID from a PLM system.| |▹ type|string|true|Resource object type.|
     * @param {CreateFileRequest} createFileRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFile: async (
      createFileRequest: CreateFileRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createFileRequest' is not null or undefined
      if (createFileRequest === null || createFileRequest === undefined) {
        throw new RequiredError(
          'createFileRequest',
          'Required parameter createFileRequest was null or undefined when calling createFile.'
        );
      }
      const localVarPath = `/files`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof createFileRequest !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createFileRequest !== undefined ? createFileRequest : {}
          )
        : createFileRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Delete a `file`.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteFile.'
        );
      }
      const localVarPath = `/files/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `file` by ID.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getFile.'
        );
      }
      const localVarPath = `/files/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get `files`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {Array<string>} [filterSuppliedId] Filter with the given suppliedId(s).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFiles: async (
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/files`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (filterSuppliedId) {
        localVarQueryParameter['filter[suppliedId]'] = filterSuppliedId;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Upload a `file`. Once uploaded, create either parts or geometry sets via the createPart or createGeometrySet APIs.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile: async (
      id: string,
      body: any,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling uploadFile.'
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling uploadFile.'
        );
      }
      const localVarPath = `/files/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization = false;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create a `file`. Once created, upload file content via the uploadFile API. For details including supported file formats, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateFileRequest_data|true|| |▹ attributes|CreateFileRequest_data_attributes|true|| |▹▹ name|string|true|Name matching that of the file you are uploading, including file extension.| |▹▹ rootFileName|string|false|File name of the root part or assembly, including file extension. Required if `name` references an archive file extension, ignored otherwise.| |▹▹ suppliedId|string|false|ID provided for correlation. For example, an existing ID from a PLM system.| |▹ type|string|true|Resource object type.|
     * @param {CreateFileRequest} createFileRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFile(
      createFileRequest: CreateFileRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileMetadata>
    > {
      const localVarAxiosArgs = await FilesApiAxiosParamCreator(
        configuration
      ).createFile(createFileRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Delete a `file`.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFile(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileMetadata>
    > {
      const localVarAxiosArgs = await FilesApiAxiosParamCreator(
        configuration
      ).deleteFile(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `file` by ID.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFile(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileMetadata>
    > {
      const localVarAxiosArgs = await FilesApiAxiosParamCreator(
        configuration
      ).getFile(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get `files`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {Array<string>} [filterSuppliedId] Filter with the given suppliedId(s).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFiles(
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: Array<string>,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileList>
    > {
      const localVarAxiosArgs = await FilesApiAxiosParamCreator(
        configuration
      ).getFiles(pageCursor, pageSize, filterSuppliedId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Upload a `file`. Once uploaded, create either parts or geometry sets via the createPart or createGeometrySet APIs.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadFile(
      id: string,
      body: any,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await FilesApiAxiosParamCreator(
        configuration
      ).uploadFile(id, body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `file`. Once created, upload file content via the uploadFile API. For details including supported file formats, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateFileRequest_data|true|| |▹ attributes|CreateFileRequest_data_attributes|true|| |▹▹ name|string|true|Name matching that of the file you are uploading, including file extension.| |▹▹ rootFileName|string|false|File name of the root part or assembly, including file extension. Required if `name` references an archive file extension, ignored otherwise.| |▹▹ suppliedId|string|false|ID provided for correlation. For example, an existing ID from a PLM system.| |▹ type|string|true|Resource object type.|
     * @param {CreateFileRequest} createFileRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFile(
      createFileRequest: CreateFileRequest,
      options?: any
    ): AxiosPromise<FileMetadata> {
      return FilesApiFp(configuration)
        .createFile(createFileRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Delete a `file`.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(id: string, options?: any): AxiosPromise<FileMetadata> {
      return FilesApiFp(configuration)
        .deleteFile(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `file` by ID.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile(id: string, options?: any): AxiosPromise<FileMetadata> {
      return FilesApiFp(configuration)
        .getFile(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get `files`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {Array<string>} [filterSuppliedId] Filter with the given suppliedId(s).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFiles(
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: Array<string>,
      options?: any
    ): AxiosPromise<FileList> {
      return FilesApiFp(configuration)
        .getFiles(pageCursor, pageSize, filterSuppliedId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Upload a `file`. Once uploaded, create either parts or geometry sets via the createPart or createGeometrySet APIs.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile(id: string, body: any, options?: any): AxiosPromise<void> {
      return FilesApiFp(configuration)
        .uploadFile(id, body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
  /**
   *  Create a `file`. Once created, upload file content via the uploadFile API. For details including supported file formats, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateFileRequest_data|true|| |▹ attributes|CreateFileRequest_data_attributes|true|| |▹▹ name|string|true|Name matching that of the file you are uploading, including file extension.| |▹▹ rootFileName|string|false|File name of the root part or assembly, including file extension. Required if `name` references an archive file extension, ignored otherwise.| |▹▹ suppliedId|string|false|ID provided for correlation. For example, an existing ID from a PLM system.| |▹ type|string|true|Resource object type.|
   * @param {CreateFileRequest} createFileRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public createFile(createFileRequest: CreateFileRequest, options?: any) {
    return FilesApiFp(this.configuration)
      .createFile(createFileRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Delete a `file`.
   * @param {string} id The &#x60;file&#x60; ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public deleteFile(id: string, options?: any) {
    return FilesApiFp(this.configuration)
      .deleteFile(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `file` by ID.
   * @param {string} id The &#x60;file&#x60; ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public getFile(id: string, options?: any) {
    return FilesApiFp(this.configuration)
      .getFile(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get `files`.
   * @param {string} [pageCursor] The cursor for the next page of items.
   * @param {number} [pageSize] The number of items to return.
   * @param {Array<string>} [filterSuppliedId] Filter with the given suppliedId(s).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public getFiles(
    pageCursor?: string,
    pageSize?: number,
    filterSuppliedId?: Array<string>,
    options?: any
  ) {
    return FilesApiFp(this.configuration)
      .getFiles(pageCursor, pageSize, filterSuppliedId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Upload a `file`. Once uploaded, create either parts or geometry sets via the createPart or createGeometrySet APIs.
   * @param {string} id The &#x60;file&#x60; ID.
   * @param {any} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public uploadFile(id: string, body: any, options?: any) {
    return FilesApiFp(this.configuration)
      .uploadFile(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * GeometrySetsApi - axios parameter creator
 * @export
 */
export const GeometrySetsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `geometry-set`. Once created, create scenes via the createScene API. For details, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateGeometrySetRequest_data|true|| |▹ relationships|CreateGeometrySetRequest_data_relationships|true|| |▹▹ source|FileRelationship|true|Relationship to a `file`.| |▹▹▹ data|FileRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(file)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {CreateGeometrySetRequest} createGeometrySetRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGeometrySet: async (
      createGeometrySetRequest: CreateGeometrySetRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createGeometrySetRequest' is not null or undefined
      if (
        createGeometrySetRequest === null ||
        createGeometrySetRequest === undefined
      ) {
        throw new RequiredError(
          'createGeometrySetRequest',
          'Required parameter createGeometrySetRequest was null or undefined when calling createGeometrySet.'
        );
      }
      const localVarPath = `/geometry-sets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof createGeometrySetRequest !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createGeometrySetRequest !== undefined
              ? createGeometrySetRequest
              : {}
          )
        : createGeometrySetRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `geometry-set` by ID.
     * @param {string} id The &#x60;geometry-set&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGeometrySet: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getGeometrySet.'
        );
      }
      const localVarPath = `/geometry-sets/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get `geometry-sets`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGeometrySets: async (
      pageCursor?: string,
      pageSize?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/geometry-sets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GeometrySetsApi - functional programming interface
 * @export
 */
export const GeometrySetsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create a `geometry-set`. Once created, create scenes via the createScene API. For details, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateGeometrySetRequest_data|true|| |▹ relationships|CreateGeometrySetRequest_data_relationships|true|| |▹▹ source|FileRelationship|true|Relationship to a `file`.| |▹▹▹ data|FileRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(file)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {CreateGeometrySetRequest} createGeometrySetRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createGeometrySet(
      createGeometrySetRequest: CreateGeometrySetRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await GeometrySetsApiAxiosParamCreator(
        configuration
      ).createGeometrySet(createGeometrySetRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `geometry-set` by ID.
     * @param {string} id The &#x60;geometry-set&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGeometrySet(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeometrySet>
    > {
      const localVarAxiosArgs = await GeometrySetsApiAxiosParamCreator(
        configuration
      ).getGeometrySet(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get `geometry-sets`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGeometrySets(
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GeometrySetList>
    > {
      const localVarAxiosArgs = await GeometrySetsApiAxiosParamCreator(
        configuration
      ).getGeometrySets(pageCursor, pageSize, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * GeometrySetsApi - factory interface
 * @export
 */
export const GeometrySetsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `geometry-set`. Once created, create scenes via the createScene API. For details, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateGeometrySetRequest_data|true|| |▹ relationships|CreateGeometrySetRequest_data_relationships|true|| |▹▹ source|FileRelationship|true|Relationship to a `file`.| |▹▹▹ data|FileRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(file)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {CreateGeometrySetRequest} createGeometrySetRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGeometrySet(
      createGeometrySetRequest: CreateGeometrySetRequest,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return GeometrySetsApiFp(configuration)
        .createGeometrySet(createGeometrySetRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `geometry-set` by ID.
     * @param {string} id The &#x60;geometry-set&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGeometrySet(id: string, options?: any): AxiosPromise<GeometrySet> {
      return GeometrySetsApiFp(configuration)
        .getGeometrySet(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get `geometry-sets`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGeometrySets(
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<GeometrySetList> {
      return GeometrySetsApiFp(configuration)
        .getGeometrySets(pageCursor, pageSize, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * GeometrySetsApi - object-oriented interface
 * @export
 * @class GeometrySetsApi
 * @extends {BaseAPI}
 */
export class GeometrySetsApi extends BaseAPI {
  /**
   *  Create a `geometry-set`. Once created, create scenes via the createScene API. For details, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateGeometrySetRequest_data|true|| |▹ relationships|CreateGeometrySetRequest_data_relationships|true|| |▹▹ source|FileRelationship|true|Relationship to a `file`.| |▹▹▹ data|FileRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(file)|true|Resource object type.| |▹ type|string|true|Resource object type.|
   * @param {CreateGeometrySetRequest} createGeometrySetRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeometrySetsApi
   */
  public createGeometrySet(
    createGeometrySetRequest: CreateGeometrySetRequest,
    options?: any
  ) {
    return GeometrySetsApiFp(this.configuration)
      .createGeometrySet(createGeometrySetRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `geometry-set` by ID.
   * @param {string} id The &#x60;geometry-set&#x60; ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeometrySetsApi
   */
  public getGeometrySet(id: string, options?: any) {
    return GeometrySetsApiFp(this.configuration)
      .getGeometrySet(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get `geometry-sets`.
   * @param {string} [pageCursor] The cursor for the next page of items.
   * @param {number} [pageSize] The number of items to return.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeometrySetsApi
   */
  public getGeometrySets(
    pageCursor?: string,
    pageSize?: number,
    options?: any
  ) {
    return GeometrySetsApiFp(this.configuration)
      .getGeometrySets(pageCursor, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HitsApi - axios parameter creator
 * @export
 */
export const HitsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `hit` for a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateHitRequest_data|true|| |▹ attributes|CreateHitRequest_data_attributes|true|| |▹▹ point|Point|true|2D point.| |▹▹▹ dx|integer(int32)|true|x-axis coordinate.| |▹▹▹ dy|integer(int32)|true|y-axis coordinate.| |▹▹ viewport|Dimensions|true|An item\'s height and width.| |▹▹▹ height|integer(int32)|true|Item\'s height.| |▹▹▹ width|integer(int32)|true|Item\'s width.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateHitRequest} createHitRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneHit: async (
      id: string,
      createHitRequest: CreateHitRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling createSceneHit.'
        );
      }
      // verify required parameter 'createHitRequest' is not null or undefined
      if (createHitRequest === null || createHitRequest === undefined) {
        throw new RequiredError(
          'createHitRequest',
          'Required parameter createHitRequest was null or undefined when calling createSceneHit.'
        );
      }
      const localVarPath = `/scenes/{id}/hits`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof createHitRequest !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(createHitRequest !== undefined ? createHitRequest : {})
        : createHitRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Create a `hit` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateHitRequest_data|true|| |▹ attributes|CreateHitRequest_data_attributes|true|| |▹▹ point|Point|true|2D point.| |▹▹▹ dx|integer(int32)|true|x-axis coordinate.| |▹▹▹ dy|integer(int32)|true|y-axis coordinate.| |▹▹ viewport|Dimensions|true|An item\'s height and width.| |▹▹▹ height|integer(int32)|true|Item\'s height.| |▹▹▹ width|integer(int32)|true|Item\'s width.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateHitRequest} createHitRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneViewHit: async (
      id: string,
      createHitRequest: CreateHitRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling createSceneViewHit.'
        );
      }
      // verify required parameter 'createHitRequest' is not null or undefined
      if (createHitRequest === null || createHitRequest === undefined) {
        throw new RequiredError(
          'createHitRequest',
          'Required parameter createHitRequest was null or undefined when calling createSceneViewHit.'
        );
      }
      const localVarPath = `/scene-views/{id}/hits`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof createHitRequest !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(createHitRequest !== undefined ? createHitRequest : {})
        : createHitRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HitsApi - functional programming interface
 * @export
 */
export const HitsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create a `hit` for a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateHitRequest_data|true|| |▹ attributes|CreateHitRequest_data_attributes|true|| |▹▹ point|Point|true|2D point.| |▹▹▹ dx|integer(int32)|true|x-axis coordinate.| |▹▹▹ dy|integer(int32)|true|y-axis coordinate.| |▹▹ viewport|Dimensions|true|An item\'s height and width.| |▹▹▹ height|integer(int32)|true|Item\'s height.| |▹▹▹ width|integer(int32)|true|Item\'s width.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateHitRequest} createHitRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneHit(
      id: string,
      createHitRequest: CreateHitRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hit>
    > {
      const localVarAxiosArgs = await HitsApiAxiosParamCreator(
        configuration
      ).createSceneHit(id, createHitRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Create a `hit` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateHitRequest_data|true|| |▹ attributes|CreateHitRequest_data_attributes|true|| |▹▹ point|Point|true|2D point.| |▹▹▹ dx|integer(int32)|true|x-axis coordinate.| |▹▹▹ dy|integer(int32)|true|y-axis coordinate.| |▹▹ viewport|Dimensions|true|An item\'s height and width.| |▹▹▹ height|integer(int32)|true|Item\'s height.| |▹▹▹ width|integer(int32)|true|Item\'s width.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateHitRequest} createHitRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneViewHit(
      id: string,
      createHitRequest: CreateHitRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hit>
    > {
      const localVarAxiosArgs = await HitsApiAxiosParamCreator(
        configuration
      ).createSceneViewHit(id, createHitRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * HitsApi - factory interface
 * @export
 */
export const HitsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `hit` for a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateHitRequest_data|true|| |▹ attributes|CreateHitRequest_data_attributes|true|| |▹▹ point|Point|true|2D point.| |▹▹▹ dx|integer(int32)|true|x-axis coordinate.| |▹▹▹ dy|integer(int32)|true|y-axis coordinate.| |▹▹ viewport|Dimensions|true|An item\'s height and width.| |▹▹▹ height|integer(int32)|true|Item\'s height.| |▹▹▹ width|integer(int32)|true|Item\'s width.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateHitRequest} createHitRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneHit(
      id: string,
      createHitRequest: CreateHitRequest,
      options?: any
    ): AxiosPromise<Hit> {
      return HitsApiFp(configuration)
        .createSceneHit(id, createHitRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Create a `hit` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateHitRequest_data|true|| |▹ attributes|CreateHitRequest_data_attributes|true|| |▹▹ point|Point|true|2D point.| |▹▹▹ dx|integer(int32)|true|x-axis coordinate.| |▹▹▹ dy|integer(int32)|true|y-axis coordinate.| |▹▹ viewport|Dimensions|true|An item\'s height and width.| |▹▹▹ height|integer(int32)|true|Item\'s height.| |▹▹▹ width|integer(int32)|true|Item\'s width.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateHitRequest} createHitRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneViewHit(
      id: string,
      createHitRequest: CreateHitRequest,
      options?: any
    ): AxiosPromise<Hit> {
      return HitsApiFp(configuration)
        .createSceneViewHit(id, createHitRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * HitsApi - object-oriented interface
 * @export
 * @class HitsApi
 * @extends {BaseAPI}
 */
export class HitsApi extends BaseAPI {
  /**
   *  Create a `hit` for a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateHitRequest_data|true|| |▹ attributes|CreateHitRequest_data_attributes|true|| |▹▹ point|Point|true|2D point.| |▹▹▹ dx|integer(int32)|true|x-axis coordinate.| |▹▹▹ dy|integer(int32)|true|y-axis coordinate.| |▹▹ viewport|Dimensions|true|An item\'s height and width.| |▹▹▹ height|integer(int32)|true|Item\'s height.| |▹▹▹ width|integer(int32)|true|Item\'s width.| |▹ type|string|true|Resource object type.|
   * @param {string} id The &#x60;scene&#x60; ID.
   * @param {CreateHitRequest} createHitRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HitsApi
   */
  public createSceneHit(
    id: string,
    createHitRequest: CreateHitRequest,
    options?: any
  ) {
    return HitsApiFp(this.configuration)
      .createSceneHit(id, createHitRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Create a `hit` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateHitRequest_data|true|| |▹ attributes|CreateHitRequest_data_attributes|true|| |▹▹ point|Point|true|2D point.| |▹▹▹ dx|integer(int32)|true|x-axis coordinate.| |▹▹▹ dy|integer(int32)|true|y-axis coordinate.| |▹▹ viewport|Dimensions|true|An item\'s height and width.| |▹▹▹ height|integer(int32)|true|Item\'s height.| |▹▹▹ width|integer(int32)|true|Item\'s width.| |▹ type|string|true|Resource object type.|
   * @param {string} id The &#x60;scene-view&#x60; ID.
   * @param {CreateHitRequest} createHitRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HitsApi
   */
  public createSceneViewHit(
    id: string,
    createHitRequest: CreateHitRequest,
    options?: any
  ) {
    return HitsApiFp(this.configuration)
      .createSceneViewHit(id, createHitRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * Oauth2Api - axios parameter creator
 * @export
 */
export const Oauth2ApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create an OAuth2 access token. For details, see our [Authentication](https://developer.vertexvis.com/docs/guides/authentication) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |grant_type|string|true|| |scope|string|false||
     * @param {string} grantType
     * @param {string} [scope]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken: async (
      grantType: string,
      scope?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'grantType' is not null or undefined
      if (grantType === null || grantType === undefined) {
        throw new RequiredError(
          'grantType',
          'Required parameter grantType was null or undefined when calling createToken.'
        );
      }
      const localVarPath = `/oauth2/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      // authentication basicAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarRequestOptions['auth'] = {
          username: configuration.username,
          password: configuration.password,
        };
      }

      if (grantType !== undefined) {
        localVarFormParams.set('grant_type', grantType as any);
      }

      if (scope !== undefined) {
        localVarFormParams.set('scope', scope as any);
      }

      localVarHeaderParameter['Content-Type'] =
        'application/x-www-form-urlencoded';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Revoke an OAuth2 access token.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|RevokeOAuth2TokenRequest_data|true|| |▹ attributes|RevokeOAuth2TokenRequest_data_attributes|true|| |▹▹ token|string|true|Token to revoke.| |▹ type|string|true|Resource object type.|
     * @param {RevokeOAuth2TokenRequest} revokeOAuth2TokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeToken: async (
      revokeOAuth2TokenRequest: RevokeOAuth2TokenRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'revokeOAuth2TokenRequest' is not null or undefined
      if (
        revokeOAuth2TokenRequest === null ||
        revokeOAuth2TokenRequest === undefined
      ) {
        throw new RequiredError(
          'revokeOAuth2TokenRequest',
          'Required parameter revokeOAuth2TokenRequest was null or undefined when calling revokeToken.'
        );
      }
      const localVarPath = `/oauth2/revoke`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarRequestOptions['auth'] = {
          username: configuration.username,
          password: configuration.password,
        };
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof revokeOAuth2TokenRequest !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            revokeOAuth2TokenRequest !== undefined
              ? revokeOAuth2TokenRequest
              : {}
          )
        : revokeOAuth2TokenRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * Oauth2Api - functional programming interface
 * @export
 */
export const Oauth2ApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create an OAuth2 access token. For details, see our [Authentication](https://developer.vertexvis.com/docs/guides/authentication) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |grant_type|string|true|| |scope|string|false||
     * @param {string} grantType
     * @param {string} [scope]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createToken(
      grantType: string,
      scope?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2Token>
    > {
      const localVarAxiosArgs = await Oauth2ApiAxiosParamCreator(
        configuration
      ).createToken(grantType, scope, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Revoke an OAuth2 access token.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|RevokeOAuth2TokenRequest_data|true|| |▹ attributes|RevokeOAuth2TokenRequest_data_attributes|true|| |▹▹ token|string|true|Token to revoke.| |▹ type|string|true|Resource object type.|
     * @param {RevokeOAuth2TokenRequest} revokeOAuth2TokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async revokeToken(
      revokeOAuth2TokenRequest: RevokeOAuth2TokenRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await Oauth2ApiAxiosParamCreator(
        configuration
      ).revokeToken(revokeOAuth2TokenRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * Oauth2Api - factory interface
 * @export
 */
export const Oauth2ApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create an OAuth2 access token. For details, see our [Authentication](https://developer.vertexvis.com/docs/guides/authentication) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |grant_type|string|true|| |scope|string|false||
     * @param {string} grantType
     * @param {string} [scope]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken(
      grantType: string,
      scope?: string,
      options?: any
    ): AxiosPromise<OAuth2Token> {
      return Oauth2ApiFp(configuration)
        .createToken(grantType, scope, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Revoke an OAuth2 access token.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|RevokeOAuth2TokenRequest_data|true|| |▹ attributes|RevokeOAuth2TokenRequest_data_attributes|true|| |▹▹ token|string|true|Token to revoke.| |▹ type|string|true|Resource object type.|
     * @param {RevokeOAuth2TokenRequest} revokeOAuth2TokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeToken(
      revokeOAuth2TokenRequest: RevokeOAuth2TokenRequest,
      options?: any
    ): AxiosPromise<void> {
      return Oauth2ApiFp(configuration)
        .revokeToken(revokeOAuth2TokenRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Oauth2Api - object-oriented interface
 * @export
 * @class Oauth2Api
 * @extends {BaseAPI}
 */
export class Oauth2Api extends BaseAPI {
  /**
   *  Create an OAuth2 access token. For details, see our [Authentication](https://developer.vertexvis.com/docs/guides/authentication) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |grant_type|string|true|| |scope|string|false||
   * @param {string} grantType
   * @param {string} [scope]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Oauth2Api
   */
  public createToken(grantType: string, scope?: string, options?: any) {
    return Oauth2ApiFp(this.configuration)
      .createToken(grantType, scope, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Revoke an OAuth2 access token.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|RevokeOAuth2TokenRequest_data|true|| |▹ attributes|RevokeOAuth2TokenRequest_data_attributes|true|| |▹▹ token|string|true|Token to revoke.| |▹ type|string|true|Resource object type.|
   * @param {RevokeOAuth2TokenRequest} revokeOAuth2TokenRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Oauth2Api
   */
  public revokeToken(
    revokeOAuth2TokenRequest: RevokeOAuth2TokenRequest,
    options?: any
  ) {
    return Oauth2ApiFp(this.configuration)
      .revokeToken(revokeOAuth2TokenRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PartRevisionsApi - axios parameter creator
 * @export
 */
export const PartRevisionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Get a `part-revision` by ID.
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartRevision: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getPartRevision.'
        );
      }
      const localVarPath = `/part-revisions/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get `part-revisions`.
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {Array<string>} [filterSuppliedId] Filter with the given suppliedId(s).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartRevisions: async (
      id: string,
      filterSuppliedId?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getPartRevisions.'
        );
      }
      const localVarPath = `/parts/{id}/part-revisions`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (filterSuppliedId) {
        localVarQueryParameter['filter[suppliedId]'] = filterSuppliedId;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Update a `part-revision`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdatePartRevisionRequest_data|true|| |▹ attributes|UpdatePartRevisionRequest_data_attributes|true|| |▹▹ metadata|object|false|Metadata about the `part-revision`.| |▹▹▹ **additionalProperties**|UpdatePartRevisionRequest_data_attributes_metadata|false|| |▹▹▹▹ type|enum(string, long, float, date, null)|true|Type of metadata value.| |▹▹▹▹ value|string|false|Metadata value.| |▹ id|string(uuid)|true|ID of the resource.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {UpdatePartRevisionRequest} updatePartRevisionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePartRevision: async (
      id: string,
      updatePartRevisionRequest: UpdatePartRevisionRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updatePartRevision.'
        );
      }
      // verify required parameter 'updatePartRevisionRequest' is not null or undefined
      if (
        updatePartRevisionRequest === null ||
        updatePartRevisionRequest === undefined
      ) {
        throw new RequiredError(
          'updatePartRevisionRequest',
          'Required parameter updatePartRevisionRequest was null or undefined when calling updatePartRevision.'
        );
      }
      const localVarPath = `/part-revisions/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof updatePartRevisionRequest !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            updatePartRevisionRequest !== undefined
              ? updatePartRevisionRequest
              : {}
          )
        : updatePartRevisionRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PartRevisionsApi - functional programming interface
 * @export
 */
export const PartRevisionsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Get a `part-revision` by ID.
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPartRevision(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartRevision>
    > {
      const localVarAxiosArgs = await PartRevisionsApiAxiosParamCreator(
        configuration
      ).getPartRevision(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get `part-revisions`.
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {Array<string>} [filterSuppliedId] Filter with the given suppliedId(s).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPartRevisions(
      id: string,
      filterSuppliedId?: Array<string>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PartRevisionList>
    > {
      const localVarAxiosArgs = await PartRevisionsApiAxiosParamCreator(
        configuration
      ).getPartRevisions(id, filterSuppliedId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Update a `part-revision`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdatePartRevisionRequest_data|true|| |▹ attributes|UpdatePartRevisionRequest_data_attributes|true|| |▹▹ metadata|object|false|Metadata about the `part-revision`.| |▹▹▹ **additionalProperties**|UpdatePartRevisionRequest_data_attributes_metadata|false|| |▹▹▹▹ type|enum(string, long, float, date, null)|true|Type of metadata value.| |▹▹▹▹ value|string|false|Metadata value.| |▹ id|string(uuid)|true|ID of the resource.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {UpdatePartRevisionRequest} updatePartRevisionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePartRevision(
      id: string,
      updatePartRevisionRequest: UpdatePartRevisionRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartRevision>
    > {
      const localVarAxiosArgs = await PartRevisionsApiAxiosParamCreator(
        configuration
      ).updatePartRevision(id, updatePartRevisionRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * PartRevisionsApi - factory interface
 * @export
 */
export const PartRevisionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Get a `part-revision` by ID.
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartRevision(id: string, options?: any): AxiosPromise<PartRevision> {
      return PartRevisionsApiFp(configuration)
        .getPartRevision(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get `part-revisions`.
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {Array<string>} [filterSuppliedId] Filter with the given suppliedId(s).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartRevisions(
      id: string,
      filterSuppliedId?: Array<string>,
      options?: any
    ): AxiosPromise<PartRevisionList> {
      return PartRevisionsApiFp(configuration)
        .getPartRevisions(id, filterSuppliedId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Update a `part-revision`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdatePartRevisionRequest_data|true|| |▹ attributes|UpdatePartRevisionRequest_data_attributes|true|| |▹▹ metadata|object|false|Metadata about the `part-revision`.| |▹▹▹ **additionalProperties**|UpdatePartRevisionRequest_data_attributes_metadata|false|| |▹▹▹▹ type|enum(string, long, float, date, null)|true|Type of metadata value.| |▹▹▹▹ value|string|false|Metadata value.| |▹ id|string(uuid)|true|ID of the resource.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {UpdatePartRevisionRequest} updatePartRevisionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePartRevision(
      id: string,
      updatePartRevisionRequest: UpdatePartRevisionRequest,
      options?: any
    ): AxiosPromise<PartRevision> {
      return PartRevisionsApiFp(configuration)
        .updatePartRevision(id, updatePartRevisionRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PartRevisionsApi - object-oriented interface
 * @export
 * @class PartRevisionsApi
 * @extends {BaseAPI}
 */
export class PartRevisionsApi extends BaseAPI {
  /**
   *  Get a `part-revision` by ID.
   * @param {string} id The &#x60;part-revision&#x60; ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartRevisionsApi
   */
  public getPartRevision(id: string, options?: any) {
    return PartRevisionsApiFp(this.configuration)
      .getPartRevision(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get `part-revisions`.
   * @param {string} id The &#x60;part&#x60; ID.
   * @param {Array<string>} [filterSuppliedId] Filter with the given suppliedId(s).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartRevisionsApi
   */
  public getPartRevisions(
    id: string,
    filterSuppliedId?: Array<string>,
    options?: any
  ) {
    return PartRevisionsApiFp(this.configuration)
      .getPartRevisions(id, filterSuppliedId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Update a `part-revision`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdatePartRevisionRequest_data|true|| |▹ attributes|UpdatePartRevisionRequest_data_attributes|true|| |▹▹ metadata|object|false|Metadata about the `part-revision`.| |▹▹▹ **additionalProperties**|UpdatePartRevisionRequest_data_attributes_metadata|false|| |▹▹▹▹ type|enum(string, long, float, date, null)|true|Type of metadata value.| |▹▹▹▹ value|string|false|Metadata value.| |▹ id|string(uuid)|true|ID of the resource.| |▹ type|string|true|Resource object type.|
   * @param {string} id The &#x60;part-revision&#x60; ID.
   * @param {UpdatePartRevisionRequest} updatePartRevisionRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartRevisionsApi
   */
  public updatePartRevision(
    id: string,
    updatePartRevisionRequest: UpdatePartRevisionRequest,
    options?: any
  ) {
    return PartRevisionsApiFp(this.configuration)
      .updatePartRevision(id, updatePartRevisionRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PartsApi - axios parameter creator
 * @export
 */
export const PartsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `part`. This API is asynchronous, returning the location of a `queued-translation`. Check the status via the getQueuedTranslation API. For details, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreatePartRequest_data|true|| |▹ attributes|CreatePartRequest_data_attributes|true|| |▹▹ suppliedId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| |▹▹ suppliedRevisionId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| |▹ relationships|CreateGeometrySetRequest_data_relationships|true|| |▹▹ source|FileRelationship|true|Relationship to a `file`.| |▹▹▹ data|FileRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(file)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {CreatePartRequest} createPartRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPart: async (
      createPartRequest: CreatePartRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPartRequest' is not null or undefined
      if (createPartRequest === null || createPartRequest === undefined) {
        throw new RequiredError(
          'createPartRequest',
          'Required parameter createPartRequest was null or undefined when calling createPart.'
        );
      }
      const localVarPath = `/parts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof createPartRequest !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createPartRequest !== undefined ? createPartRequest : {}
          )
        : createPartRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `part` by ID.
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPart: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getPart.'
        );
      }
      const localVarPath = `/parts/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get `parts`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {Array<string>} [filterSuppliedId] Filter with the given suppliedId(s).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getParts: async (
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/parts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (filterSuppliedId) {
        localVarQueryParameter['filter[suppliedId]'] = filterSuppliedId;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PartsApi - functional programming interface
 * @export
 */
export const PartsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create a `part`. This API is asynchronous, returning the location of a `queued-translation`. Check the status via the getQueuedTranslation API. For details, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreatePartRequest_data|true|| |▹ attributes|CreatePartRequest_data_attributes|true|| |▹▹ suppliedId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| |▹▹ suppliedRevisionId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| |▹ relationships|CreateGeometrySetRequest_data_relationships|true|| |▹▹ source|FileRelationship|true|Relationship to a `file`.| |▹▹▹ data|FileRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(file)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {CreatePartRequest} createPartRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPart(
      createPartRequest: CreatePartRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await PartsApiAxiosParamCreator(
        configuration
      ).createPart(createPartRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `part` by ID.
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPart(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Part>
    > {
      const localVarAxiosArgs = await PartsApiAxiosParamCreator(
        configuration
      ).getPart(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get `parts`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {Array<string>} [filterSuppliedId] Filter with the given suppliedId(s).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getParts(
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: Array<string>,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartList>
    > {
      const localVarAxiosArgs = await PartsApiAxiosParamCreator(
        configuration
      ).getParts(pageCursor, pageSize, filterSuppliedId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * PartsApi - factory interface
 * @export
 */
export const PartsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `part`. This API is asynchronous, returning the location of a `queued-translation`. Check the status via the getQueuedTranslation API. For details, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreatePartRequest_data|true|| |▹ attributes|CreatePartRequest_data_attributes|true|| |▹▹ suppliedId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| |▹▹ suppliedRevisionId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| |▹ relationships|CreateGeometrySetRequest_data_relationships|true|| |▹▹ source|FileRelationship|true|Relationship to a `file`.| |▹▹▹ data|FileRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(file)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {CreatePartRequest} createPartRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPart(
      createPartRequest: CreatePartRequest,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return PartsApiFp(configuration)
        .createPart(createPartRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `part` by ID.
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPart(id: string, options?: any): AxiosPromise<Part> {
      return PartsApiFp(configuration)
        .getPart(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get `parts`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {Array<string>} [filterSuppliedId] Filter with the given suppliedId(s).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getParts(
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: Array<string>,
      options?: any
    ): AxiosPromise<PartList> {
      return PartsApiFp(configuration)
        .getParts(pageCursor, pageSize, filterSuppliedId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PartsApi - object-oriented interface
 * @export
 * @class PartsApi
 * @extends {BaseAPI}
 */
export class PartsApi extends BaseAPI {
  /**
   *  Create a `part`. This API is asynchronous, returning the location of a `queued-translation`. Check the status via the getQueuedTranslation API. For details, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreatePartRequest_data|true|| |▹ attributes|CreatePartRequest_data_attributes|true|| |▹▹ suppliedId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| |▹▹ suppliedRevisionId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| |▹ relationships|CreateGeometrySetRequest_data_relationships|true|| |▹▹ source|FileRelationship|true|Relationship to a `file`.| |▹▹▹ data|FileRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(file)|true|Resource object type.| |▹ type|string|true|Resource object type.|
   * @param {CreatePartRequest} createPartRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartsApi
   */
  public createPart(createPartRequest: CreatePartRequest, options?: any) {
    return PartsApiFp(this.configuration)
      .createPart(createPartRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `part` by ID.
   * @param {string} id The &#x60;part&#x60; ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartsApi
   */
  public getPart(id: string, options?: any) {
    return PartsApiFp(this.configuration)
      .getPart(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get `parts`.
   * @param {string} [pageCursor] The cursor for the next page of items.
   * @param {number} [pageSize] The number of items to return.
   * @param {Array<string>} [filterSuppliedId] Filter with the given suppliedId(s).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartsApi
   */
  public getParts(
    pageCursor?: string,
    pageSize?: number,
    filterSuppliedId?: Array<string>,
    options?: any
  ) {
    return PartsApiFp(this.configuration)
      .getParts(pageCursor, pageSize, filterSuppliedId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SceneAlterationsApi - axios parameter creator
 * @export
 */
export const SceneAlterationsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `scene-alteration` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneAlterationRequest_data|true|| |▹ attributes|CreateSceneAlterationRequest_data_attributes|true|| |▹▹ alterations|[SceneOperation]|true|List of alterations to apply.| |▹▹▹ operations|[anyOf]|true|List of operations to perform on `scene-items` matching the query.| |▹▹▹▹ *anonymous*|ChangeVisibilityOperation|false|| |▹▹▹▹▹ type|enum(change-visibility)|true|Resource object type.| |▹▹▹▹▹ visible|boolean|true|Item visibility.| |▹▹▹▹ *anonymous*|ChangeMaterialOperation|false|| |▹▹▹▹▹ material|ColorMaterial|true|Color properties describing how a material looks.| |▹▹▹▹▹▹ ambient|Color3|true|RGB color.| |▹▹▹▹▹▹▹ b|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹▹▹▹ g|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹▹▹▹ r|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹▹▹ diffuse|Color3|true|RGB color.| |▹▹▹▹▹▹ emissive|Color3|true|RGB color.| |▹▹▹▹▹▹ glossiness|integer(int32)|true|Glossiness from 0 to 128.| |▹▹▹▹▹▹ opacity|integer(int32)|true|Opacity from 0 to 100.| |▹▹▹▹▹▹ specular|Color3|true|RGB color.| |▹▹▹▹▹ type|enum(change-material)|true|Resource object type.| |▹▹▹▹ *anonymous*|ClearMaterialOperation|false|| |▹▹▹▹▹ type|enum(clear-material)|true|Resource object type.| |▹▹▹▹ *anonymous*|ChangeTransformOperation|false|| |▹▹▹▹▹ transform|Matrix4|true|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| |▹▹▹▹▹▹ r0|Vector4|true|4D vector.| |▹▹▹▹▹▹▹ w|number|true|w value.| |▹▹▹▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹▹▹▹ r1|Vector4|true|4D vector.| |▹▹▹▹▹▹ r2|Vector4|true|4D vector.| |▹▹▹▹▹▹ r3|Vector4|true|4D vector.| |▹▹▹▹▹ type|enum(change-transform)|true|Resource object type.| |▹▹▹▹ *anonymous*|ClearTransformOperation|false|| |▹▹▹▹▹ type|enum(clear-transform)|true|Resource object type.| |▹▹▹ query|any|true|Query `scene-items`. Use `query-by-collection` to combine multiple queries.| |▹▹▹▹ *anonymous*|QueryById|false|| |▹▹▹▹▹ data|QueryById_data|true|| |▹▹▹▹▹▹ attributes|QueryById_data_attributes|true|| |▹▹▹▹▹▹▹ type|enum(id, suppliedId)|true|Resource object type.| |▹▹▹▹▹▹▹ value|string|true|ID of the resource.| |▹▹▹▹▹▹ type|enum(query-by-id)|true|Resource object type.| |▹▹▹▹ *anonymous*|QueryByCollection|false|| |▹▹▹▹▹ data|QueryByCollection_data|true|| |▹▹▹▹▹▹ attributes|QueryByCollection_data_attributes|true|| |▹▹▹▹▹▹▹ type|enum(and, or)|true|Resource object type.| |▹▹▹▹▹▹▹ values|[QueryById]|true|Query `scene-items`.| |▹▹▹▹▹▹ type|enum(query-by-collection)|true|Resource object type.| |▹▹▹▹ *anonymous*|QueryAll|false|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateSceneAlterationRequest} createSceneAlterationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneAlteration: async (
      id: string,
      createSceneAlterationRequest: CreateSceneAlterationRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling createSceneAlteration.'
        );
      }
      // verify required parameter 'createSceneAlterationRequest' is not null or undefined
      if (
        createSceneAlterationRequest === null ||
        createSceneAlterationRequest === undefined
      ) {
        throw new RequiredError(
          'createSceneAlterationRequest',
          'Required parameter createSceneAlterationRequest was null or undefined when calling createSceneAlteration.'
        );
      }
      const localVarPath = `/scene-views/{id}/scene-alterations`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof createSceneAlterationRequest !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createSceneAlterationRequest !== undefined
              ? createSceneAlterationRequest
              : {}
          )
        : createSceneAlterationRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `queued-scene-alteration` by ID.
     * @param {string} id The &#x60;queued-scene-alteration&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedSceneAlteration: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getQueuedSceneAlteration.'
        );
      }
      const localVarPath = `/queued-scene-alterations/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `scene-alteration` by ID.
     * @param {string} id The &#x60;scene-alteration&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneAlteration: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getSceneAlteration.'
        );
      }
      const localVarPath = `/scene-alterations/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get `scene-alterations`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneAlterations: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getSceneAlterations.'
        );
      }
      const localVarPath = `/scene-views/{id}/scene-alterations`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SceneAlterationsApi - functional programming interface
 * @export
 */
export const SceneAlterationsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create a `scene-alteration` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneAlterationRequest_data|true|| |▹ attributes|CreateSceneAlterationRequest_data_attributes|true|| |▹▹ alterations|[SceneOperation]|true|List of alterations to apply.| |▹▹▹ operations|[anyOf]|true|List of operations to perform on `scene-items` matching the query.| |▹▹▹▹ *anonymous*|ChangeVisibilityOperation|false|| |▹▹▹▹▹ type|enum(change-visibility)|true|Resource object type.| |▹▹▹▹▹ visible|boolean|true|Item visibility.| |▹▹▹▹ *anonymous*|ChangeMaterialOperation|false|| |▹▹▹▹▹ material|ColorMaterial|true|Color properties describing how a material looks.| |▹▹▹▹▹▹ ambient|Color3|true|RGB color.| |▹▹▹▹▹▹▹ b|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹▹▹▹ g|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹▹▹▹ r|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹▹▹ diffuse|Color3|true|RGB color.| |▹▹▹▹▹▹ emissive|Color3|true|RGB color.| |▹▹▹▹▹▹ glossiness|integer(int32)|true|Glossiness from 0 to 128.| |▹▹▹▹▹▹ opacity|integer(int32)|true|Opacity from 0 to 100.| |▹▹▹▹▹▹ specular|Color3|true|RGB color.| |▹▹▹▹▹ type|enum(change-material)|true|Resource object type.| |▹▹▹▹ *anonymous*|ClearMaterialOperation|false|| |▹▹▹▹▹ type|enum(clear-material)|true|Resource object type.| |▹▹▹▹ *anonymous*|ChangeTransformOperation|false|| |▹▹▹▹▹ transform|Matrix4|true|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| |▹▹▹▹▹▹ r0|Vector4|true|4D vector.| |▹▹▹▹▹▹▹ w|number|true|w value.| |▹▹▹▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹▹▹▹ r1|Vector4|true|4D vector.| |▹▹▹▹▹▹ r2|Vector4|true|4D vector.| |▹▹▹▹▹▹ r3|Vector4|true|4D vector.| |▹▹▹▹▹ type|enum(change-transform)|true|Resource object type.| |▹▹▹▹ *anonymous*|ClearTransformOperation|false|| |▹▹▹▹▹ type|enum(clear-transform)|true|Resource object type.| |▹▹▹ query|any|true|Query `scene-items`. Use `query-by-collection` to combine multiple queries.| |▹▹▹▹ *anonymous*|QueryById|false|| |▹▹▹▹▹ data|QueryById_data|true|| |▹▹▹▹▹▹ attributes|QueryById_data_attributes|true|| |▹▹▹▹▹▹▹ type|enum(id, suppliedId)|true|Resource object type.| |▹▹▹▹▹▹▹ value|string|true|ID of the resource.| |▹▹▹▹▹▹ type|enum(query-by-id)|true|Resource object type.| |▹▹▹▹ *anonymous*|QueryByCollection|false|| |▹▹▹▹▹ data|QueryByCollection_data|true|| |▹▹▹▹▹▹ attributes|QueryByCollection_data_attributes|true|| |▹▹▹▹▹▹▹ type|enum(and, or)|true|Resource object type.| |▹▹▹▹▹▹▹ values|[QueryById]|true|Query `scene-items`.| |▹▹▹▹▹▹ type|enum(query-by-collection)|true|Resource object type.| |▹▹▹▹ *anonymous*|QueryAll|false|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateSceneAlterationRequest} createSceneAlterationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneAlteration(
      id: string,
      createSceneAlterationRequest: CreateSceneAlterationRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await SceneAlterationsApiAxiosParamCreator(
        configuration
      ).createSceneAlteration(id, createSceneAlterationRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `queued-scene-alteration` by ID.
     * @param {string} id The &#x60;queued-scene-alteration&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedSceneAlteration(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await SceneAlterationsApiAxiosParamCreator(
        configuration
      ).getQueuedSceneAlteration(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `scene-alteration` by ID.
     * @param {string} id The &#x60;scene-alteration&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneAlteration(
      id: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneAlteration>
    > {
      const localVarAxiosArgs = await SceneAlterationsApiAxiosParamCreator(
        configuration
      ).getSceneAlteration(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get `scene-alterations`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneAlterations(
      id: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneAlterationList>
    > {
      const localVarAxiosArgs = await SceneAlterationsApiAxiosParamCreator(
        configuration
      ).getSceneAlterations(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * SceneAlterationsApi - factory interface
 * @export
 */
export const SceneAlterationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `scene-alteration` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneAlterationRequest_data|true|| |▹ attributes|CreateSceneAlterationRequest_data_attributes|true|| |▹▹ alterations|[SceneOperation]|true|List of alterations to apply.| |▹▹▹ operations|[anyOf]|true|List of operations to perform on `scene-items` matching the query.| |▹▹▹▹ *anonymous*|ChangeVisibilityOperation|false|| |▹▹▹▹▹ type|enum(change-visibility)|true|Resource object type.| |▹▹▹▹▹ visible|boolean|true|Item visibility.| |▹▹▹▹ *anonymous*|ChangeMaterialOperation|false|| |▹▹▹▹▹ material|ColorMaterial|true|Color properties describing how a material looks.| |▹▹▹▹▹▹ ambient|Color3|true|RGB color.| |▹▹▹▹▹▹▹ b|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹▹▹▹ g|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹▹▹▹ r|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹▹▹ diffuse|Color3|true|RGB color.| |▹▹▹▹▹▹ emissive|Color3|true|RGB color.| |▹▹▹▹▹▹ glossiness|integer(int32)|true|Glossiness from 0 to 128.| |▹▹▹▹▹▹ opacity|integer(int32)|true|Opacity from 0 to 100.| |▹▹▹▹▹▹ specular|Color3|true|RGB color.| |▹▹▹▹▹ type|enum(change-material)|true|Resource object type.| |▹▹▹▹ *anonymous*|ClearMaterialOperation|false|| |▹▹▹▹▹ type|enum(clear-material)|true|Resource object type.| |▹▹▹▹ *anonymous*|ChangeTransformOperation|false|| |▹▹▹▹▹ transform|Matrix4|true|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| |▹▹▹▹▹▹ r0|Vector4|true|4D vector.| |▹▹▹▹▹▹▹ w|number|true|w value.| |▹▹▹▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹▹▹▹ r1|Vector4|true|4D vector.| |▹▹▹▹▹▹ r2|Vector4|true|4D vector.| |▹▹▹▹▹▹ r3|Vector4|true|4D vector.| |▹▹▹▹▹ type|enum(change-transform)|true|Resource object type.| |▹▹▹▹ *anonymous*|ClearTransformOperation|false|| |▹▹▹▹▹ type|enum(clear-transform)|true|Resource object type.| |▹▹▹ query|any|true|Query `scene-items`. Use `query-by-collection` to combine multiple queries.| |▹▹▹▹ *anonymous*|QueryById|false|| |▹▹▹▹▹ data|QueryById_data|true|| |▹▹▹▹▹▹ attributes|QueryById_data_attributes|true|| |▹▹▹▹▹▹▹ type|enum(id, suppliedId)|true|Resource object type.| |▹▹▹▹▹▹▹ value|string|true|ID of the resource.| |▹▹▹▹▹▹ type|enum(query-by-id)|true|Resource object type.| |▹▹▹▹ *anonymous*|QueryByCollection|false|| |▹▹▹▹▹ data|QueryByCollection_data|true|| |▹▹▹▹▹▹ attributes|QueryByCollection_data_attributes|true|| |▹▹▹▹▹▹▹ type|enum(and, or)|true|Resource object type.| |▹▹▹▹▹▹▹ values|[QueryById]|true|Query `scene-items`.| |▹▹▹▹▹▹ type|enum(query-by-collection)|true|Resource object type.| |▹▹▹▹ *anonymous*|QueryAll|false|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateSceneAlterationRequest} createSceneAlterationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneAlteration(
      id: string,
      createSceneAlterationRequest: CreateSceneAlterationRequest,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return SceneAlterationsApiFp(configuration)
        .createSceneAlteration(id, createSceneAlterationRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `queued-scene-alteration` by ID.
     * @param {string} id The &#x60;queued-scene-alteration&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedSceneAlteration(
      id: string,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return SceneAlterationsApiFp(configuration)
        .getQueuedSceneAlteration(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `scene-alteration` by ID.
     * @param {string} id The &#x60;scene-alteration&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneAlteration(
      id: string,
      options?: any
    ): AxiosPromise<SceneAlteration> {
      return SceneAlterationsApiFp(configuration)
        .getSceneAlteration(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get `scene-alterations`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneAlterations(
      id: string,
      options?: any
    ): AxiosPromise<SceneAlterationList> {
      return SceneAlterationsApiFp(configuration)
        .getSceneAlterations(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SceneAlterationsApi - object-oriented interface
 * @export
 * @class SceneAlterationsApi
 * @extends {BaseAPI}
 */
export class SceneAlterationsApi extends BaseAPI {
  /**
   *  Create a `scene-alteration` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneAlterationRequest_data|true|| |▹ attributes|CreateSceneAlterationRequest_data_attributes|true|| |▹▹ alterations|[SceneOperation]|true|List of alterations to apply.| |▹▹▹ operations|[anyOf]|true|List of operations to perform on `scene-items` matching the query.| |▹▹▹▹ *anonymous*|ChangeVisibilityOperation|false|| |▹▹▹▹▹ type|enum(change-visibility)|true|Resource object type.| |▹▹▹▹▹ visible|boolean|true|Item visibility.| |▹▹▹▹ *anonymous*|ChangeMaterialOperation|false|| |▹▹▹▹▹ material|ColorMaterial|true|Color properties describing how a material looks.| |▹▹▹▹▹▹ ambient|Color3|true|RGB color.| |▹▹▹▹▹▹▹ b|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹▹▹▹ g|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹▹▹▹ r|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹▹▹ diffuse|Color3|true|RGB color.| |▹▹▹▹▹▹ emissive|Color3|true|RGB color.| |▹▹▹▹▹▹ glossiness|integer(int32)|true|Glossiness from 0 to 128.| |▹▹▹▹▹▹ opacity|integer(int32)|true|Opacity from 0 to 100.| |▹▹▹▹▹▹ specular|Color3|true|RGB color.| |▹▹▹▹▹ type|enum(change-material)|true|Resource object type.| |▹▹▹▹ *anonymous*|ClearMaterialOperation|false|| |▹▹▹▹▹ type|enum(clear-material)|true|Resource object type.| |▹▹▹▹ *anonymous*|ChangeTransformOperation|false|| |▹▹▹▹▹ transform|Matrix4|true|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| |▹▹▹▹▹▹ r0|Vector4|true|4D vector.| |▹▹▹▹▹▹▹ w|number|true|w value.| |▹▹▹▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹▹▹▹ r1|Vector4|true|4D vector.| |▹▹▹▹▹▹ r2|Vector4|true|4D vector.| |▹▹▹▹▹▹ r3|Vector4|true|4D vector.| |▹▹▹▹▹ type|enum(change-transform)|true|Resource object type.| |▹▹▹▹ *anonymous*|ClearTransformOperation|false|| |▹▹▹▹▹ type|enum(clear-transform)|true|Resource object type.| |▹▹▹ query|any|true|Query `scene-items`. Use `query-by-collection` to combine multiple queries.| |▹▹▹▹ *anonymous*|QueryById|false|| |▹▹▹▹▹ data|QueryById_data|true|| |▹▹▹▹▹▹ attributes|QueryById_data_attributes|true|| |▹▹▹▹▹▹▹ type|enum(id, suppliedId)|true|Resource object type.| |▹▹▹▹▹▹▹ value|string|true|ID of the resource.| |▹▹▹▹▹▹ type|enum(query-by-id)|true|Resource object type.| |▹▹▹▹ *anonymous*|QueryByCollection|false|| |▹▹▹▹▹ data|QueryByCollection_data|true|| |▹▹▹▹▹▹ attributes|QueryByCollection_data_attributes|true|| |▹▹▹▹▹▹▹ type|enum(and, or)|true|Resource object type.| |▹▹▹▹▹▹▹ values|[QueryById]|true|Query `scene-items`.| |▹▹▹▹▹▹ type|enum(query-by-collection)|true|Resource object type.| |▹▹▹▹ *anonymous*|QueryAll|false|Resource object type.| |▹ type|string|true|Resource object type.|
   * @param {string} id The &#x60;scene-view&#x60; ID.
   * @param {CreateSceneAlterationRequest} createSceneAlterationRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneAlterationsApi
   */
  public createSceneAlteration(
    id: string,
    createSceneAlterationRequest: CreateSceneAlterationRequest,
    options?: any
  ) {
    return SceneAlterationsApiFp(this.configuration)
      .createSceneAlteration(id, createSceneAlterationRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `queued-scene-alteration` by ID.
   * @param {string} id The &#x60;queued-scene-alteration&#x60; ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneAlterationsApi
   */
  public getQueuedSceneAlteration(id: string, options?: any) {
    return SceneAlterationsApiFp(this.configuration)
      .getQueuedSceneAlteration(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `scene-alteration` by ID.
   * @param {string} id The &#x60;scene-alteration&#x60; ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneAlterationsApi
   */
  public getSceneAlteration(id: string, options?: any) {
    return SceneAlterationsApiFp(this.configuration)
      .getSceneAlteration(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get `scene-alterations`.
   * @param {string} id The &#x60;scene-view&#x60; ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneAlterationsApi
   */
  public getSceneAlterations(id: string, options?: any) {
    return SceneAlterationsApiFp(this.configuration)
      .getSceneAlterations(id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SceneItemOverridesApi - axios parameter creator
 * @export
 */
export const SceneItemOverridesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `scene-item-override` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneItemOverrideRequest_data|true|| |▹ attributes|CreateSceneItemOverrideRequest_data_attributes|true|| |▹▹ material|ColorMaterial|false|Color properties describing how a material looks.| |▹▹▹ ambient|Color3|true|RGB color.| |▹▹▹▹ b|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ g|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ r|integer(int32)|true|Color value from 0 to 255.| |▹▹▹ diffuse|Color3|true|RGB color.| |▹▹▹ emissive|Color3|true|RGB color.| |▹▹▹ glossiness|integer(int32)|true|Glossiness from 0 to 128.| |▹▹▹ opacity|integer(int32)|true|Opacity from 0 to 100.| |▹▹▹ specular|Color3|true|RGB color.| |▹▹ transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| |▹▹▹ r0|Vector4|true|4D vector.| |▹▹▹▹ w|number|true|w value.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ r1|Vector4|true|4D vector.| |▹▹▹ r2|Vector4|true|4D vector.| |▹▹▹ r3|Vector4|true|4D vector.| |▹▹ visible|boolean|false|Item visibility.| |▹ relationships|CreateSceneItemOverrideRequest_data_relationships|true|| |▹▹ sceneItem|SceneItemRelationship|true|Relationship to a `scene-item`.| |▹▹▹ data|SceneItemRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(scene-item)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateSceneItemOverrideRequest} createSceneItemOverrideRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneItemOverride: async (
      id: string,
      createSceneItemOverrideRequest: CreateSceneItemOverrideRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling createSceneItemOverride.'
        );
      }
      // verify required parameter 'createSceneItemOverrideRequest' is not null or undefined
      if (
        createSceneItemOverrideRequest === null ||
        createSceneItemOverrideRequest === undefined
      ) {
        throw new RequiredError(
          'createSceneItemOverrideRequest',
          'Required parameter createSceneItemOverrideRequest was null or undefined when calling createSceneItemOverride.'
        );
      }
      const localVarPath = `/scene-views/{id}/scene-item-overrides`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof createSceneItemOverrideRequest !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createSceneItemOverrideRequest !== undefined
              ? createSceneItemOverrideRequest
              : {}
          )
        : createSceneItemOverrideRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Delete a `scene-item-override`.
     * @param {string} id The &#x60;scene-item-override&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSceneItemOverride: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteSceneItemOverride.'
        );
      }
      const localVarPath = `/scene-item-overrides/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get `scene-item-overrides` for a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneItemOverrides: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getSceneItemOverrides.'
        );
      }
      const localVarPath = `/scene-views/{id}/scene-item-overrides`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Update a `scene-item-override`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneItemOverrideRequest_data|true|| |▹ attributes|UpdateSceneItemOverrideRequest_data_attributes|true|| |▹▹ material|ColorMaterialNullable¦null|false|Color properties describing how a material looks.| |▹▹▹ ambient|Color3|true|RGB color.| |▹▹▹▹ b|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ g|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ r|integer(int32)|true|Color value from 0 to 255.| |▹▹▹ diffuse|Color3|true|RGB color.| |▹▹▹ emissive|Color3|true|RGB color.| |▹▹▹ glossiness|integer(int32)|true|Glossiness from 0 to 128.| |▹▹▹ opacity|integer(int32)|true|Opacity from 0 to 100.| |▹▹▹ specular|Color3|true|RGB color.| |▹▹ transform|Matrix4Nullable¦null|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| |▹▹▹ r0|Vector4|true|4D vector.| |▹▹▹▹ w|number|true|w value.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ r1|Vector4|true|4D vector.| |▹▹▹ r2|Vector4|true|4D vector.| |▹▹▹ r3|Vector4|true|4D vector.| |▹▹ visible|boolean¦null|false|Item visibility.| |▹ id|string(uuid)|true|ID of the resource.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-item-override&#x60; ID.
     * @param {UpdateSceneItemOverrideRequest} updateSceneItemOverrideRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneItemOverride: async (
      id: string,
      updateSceneItemOverrideRequest: UpdateSceneItemOverrideRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateSceneItemOverride.'
        );
      }
      // verify required parameter 'updateSceneItemOverrideRequest' is not null or undefined
      if (
        updateSceneItemOverrideRequest === null ||
        updateSceneItemOverrideRequest === undefined
      ) {
        throw new RequiredError(
          'updateSceneItemOverrideRequest',
          'Required parameter updateSceneItemOverrideRequest was null or undefined when calling updateSceneItemOverride.'
        );
      }
      const localVarPath = `/scene-item-overrides/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof updateSceneItemOverrideRequest !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            updateSceneItemOverrideRequest !== undefined
              ? updateSceneItemOverrideRequest
              : {}
          )
        : updateSceneItemOverrideRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SceneItemOverridesApi - functional programming interface
 * @export
 */
export const SceneItemOverridesApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `scene-item-override` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneItemOverrideRequest_data|true|| |▹ attributes|CreateSceneItemOverrideRequest_data_attributes|true|| |▹▹ material|ColorMaterial|false|Color properties describing how a material looks.| |▹▹▹ ambient|Color3|true|RGB color.| |▹▹▹▹ b|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ g|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ r|integer(int32)|true|Color value from 0 to 255.| |▹▹▹ diffuse|Color3|true|RGB color.| |▹▹▹ emissive|Color3|true|RGB color.| |▹▹▹ glossiness|integer(int32)|true|Glossiness from 0 to 128.| |▹▹▹ opacity|integer(int32)|true|Opacity from 0 to 100.| |▹▹▹ specular|Color3|true|RGB color.| |▹▹ transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| |▹▹▹ r0|Vector4|true|4D vector.| |▹▹▹▹ w|number|true|w value.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ r1|Vector4|true|4D vector.| |▹▹▹ r2|Vector4|true|4D vector.| |▹▹▹ r3|Vector4|true|4D vector.| |▹▹ visible|boolean|false|Item visibility.| |▹ relationships|CreateSceneItemOverrideRequest_data_relationships|true|| |▹▹ sceneItem|SceneItemRelationship|true|Relationship to a `scene-item`.| |▹▹▹ data|SceneItemRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(scene-item)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateSceneItemOverrideRequest} createSceneItemOverrideRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneItemOverride(
      id: string,
      createSceneItemOverrideRequest: CreateSceneItemOverrideRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneItemOverride>
    > {
      const localVarAxiosArgs = await SceneItemOverridesApiAxiosParamCreator(
        configuration
      ).createSceneItemOverride(id, createSceneItemOverrideRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Delete a `scene-item-override`.
     * @param {string} id The &#x60;scene-item-override&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSceneItemOverride(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SceneItemOverridesApiAxiosParamCreator(
        configuration
      ).deleteSceneItemOverride(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get `scene-item-overrides` for a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneItemOverrides(
      id: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneItemOverrideList>
    > {
      const localVarAxiosArgs = await SceneItemOverridesApiAxiosParamCreator(
        configuration
      ).getSceneItemOverrides(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Update a `scene-item-override`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneItemOverrideRequest_data|true|| |▹ attributes|UpdateSceneItemOverrideRequest_data_attributes|true|| |▹▹ material|ColorMaterialNullable¦null|false|Color properties describing how a material looks.| |▹▹▹ ambient|Color3|true|RGB color.| |▹▹▹▹ b|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ g|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ r|integer(int32)|true|Color value from 0 to 255.| |▹▹▹ diffuse|Color3|true|RGB color.| |▹▹▹ emissive|Color3|true|RGB color.| |▹▹▹ glossiness|integer(int32)|true|Glossiness from 0 to 128.| |▹▹▹ opacity|integer(int32)|true|Opacity from 0 to 100.| |▹▹▹ specular|Color3|true|RGB color.| |▹▹ transform|Matrix4Nullable¦null|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| |▹▹▹ r0|Vector4|true|4D vector.| |▹▹▹▹ w|number|true|w value.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ r1|Vector4|true|4D vector.| |▹▹▹ r2|Vector4|true|4D vector.| |▹▹▹ r3|Vector4|true|4D vector.| |▹▹ visible|boolean¦null|false|Item visibility.| |▹ id|string(uuid)|true|ID of the resource.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-item-override&#x60; ID.
     * @param {UpdateSceneItemOverrideRequest} updateSceneItemOverrideRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSceneItemOverride(
      id: string,
      updateSceneItemOverrideRequest: UpdateSceneItemOverrideRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneItemOverride>
    > {
      const localVarAxiosArgs = await SceneItemOverridesApiAxiosParamCreator(
        configuration
      ).updateSceneItemOverride(id, updateSceneItemOverrideRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * SceneItemOverridesApi - factory interface
 * @export
 */
export const SceneItemOverridesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `scene-item-override` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneItemOverrideRequest_data|true|| |▹ attributes|CreateSceneItemOverrideRequest_data_attributes|true|| |▹▹ material|ColorMaterial|false|Color properties describing how a material looks.| |▹▹▹ ambient|Color3|true|RGB color.| |▹▹▹▹ b|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ g|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ r|integer(int32)|true|Color value from 0 to 255.| |▹▹▹ diffuse|Color3|true|RGB color.| |▹▹▹ emissive|Color3|true|RGB color.| |▹▹▹ glossiness|integer(int32)|true|Glossiness from 0 to 128.| |▹▹▹ opacity|integer(int32)|true|Opacity from 0 to 100.| |▹▹▹ specular|Color3|true|RGB color.| |▹▹ transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| |▹▹▹ r0|Vector4|true|4D vector.| |▹▹▹▹ w|number|true|w value.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ r1|Vector4|true|4D vector.| |▹▹▹ r2|Vector4|true|4D vector.| |▹▹▹ r3|Vector4|true|4D vector.| |▹▹ visible|boolean|false|Item visibility.| |▹ relationships|CreateSceneItemOverrideRequest_data_relationships|true|| |▹▹ sceneItem|SceneItemRelationship|true|Relationship to a `scene-item`.| |▹▹▹ data|SceneItemRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(scene-item)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateSceneItemOverrideRequest} createSceneItemOverrideRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneItemOverride(
      id: string,
      createSceneItemOverrideRequest: CreateSceneItemOverrideRequest,
      options?: any
    ): AxiosPromise<SceneItemOverride> {
      return SceneItemOverridesApiFp(configuration)
        .createSceneItemOverride(id, createSceneItemOverrideRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Delete a `scene-item-override`.
     * @param {string} id The &#x60;scene-item-override&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSceneItemOverride(id: string, options?: any): AxiosPromise<void> {
      return SceneItemOverridesApiFp(configuration)
        .deleteSceneItemOverride(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get `scene-item-overrides` for a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneItemOverrides(
      id: string,
      options?: any
    ): AxiosPromise<SceneItemOverrideList> {
      return SceneItemOverridesApiFp(configuration)
        .getSceneItemOverrides(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Update a `scene-item-override`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneItemOverrideRequest_data|true|| |▹ attributes|UpdateSceneItemOverrideRequest_data_attributes|true|| |▹▹ material|ColorMaterialNullable¦null|false|Color properties describing how a material looks.| |▹▹▹ ambient|Color3|true|RGB color.| |▹▹▹▹ b|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ g|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ r|integer(int32)|true|Color value from 0 to 255.| |▹▹▹ diffuse|Color3|true|RGB color.| |▹▹▹ emissive|Color3|true|RGB color.| |▹▹▹ glossiness|integer(int32)|true|Glossiness from 0 to 128.| |▹▹▹ opacity|integer(int32)|true|Opacity from 0 to 100.| |▹▹▹ specular|Color3|true|RGB color.| |▹▹ transform|Matrix4Nullable¦null|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| |▹▹▹ r0|Vector4|true|4D vector.| |▹▹▹▹ w|number|true|w value.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ r1|Vector4|true|4D vector.| |▹▹▹ r2|Vector4|true|4D vector.| |▹▹▹ r3|Vector4|true|4D vector.| |▹▹ visible|boolean¦null|false|Item visibility.| |▹ id|string(uuid)|true|ID of the resource.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-item-override&#x60; ID.
     * @param {UpdateSceneItemOverrideRequest} updateSceneItemOverrideRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneItemOverride(
      id: string,
      updateSceneItemOverrideRequest: UpdateSceneItemOverrideRequest,
      options?: any
    ): AxiosPromise<SceneItemOverride> {
      return SceneItemOverridesApiFp(configuration)
        .updateSceneItemOverride(id, updateSceneItemOverrideRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SceneItemOverridesApi - object-oriented interface
 * @export
 * @class SceneItemOverridesApi
 * @extends {BaseAPI}
 */
export class SceneItemOverridesApi extends BaseAPI {
  /**
   *  Create a `scene-item-override` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneItemOverrideRequest_data|true|| |▹ attributes|CreateSceneItemOverrideRequest_data_attributes|true|| |▹▹ material|ColorMaterial|false|Color properties describing how a material looks.| |▹▹▹ ambient|Color3|true|RGB color.| |▹▹▹▹ b|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ g|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ r|integer(int32)|true|Color value from 0 to 255.| |▹▹▹ diffuse|Color3|true|RGB color.| |▹▹▹ emissive|Color3|true|RGB color.| |▹▹▹ glossiness|integer(int32)|true|Glossiness from 0 to 128.| |▹▹▹ opacity|integer(int32)|true|Opacity from 0 to 100.| |▹▹▹ specular|Color3|true|RGB color.| |▹▹ transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| |▹▹▹ r0|Vector4|true|4D vector.| |▹▹▹▹ w|number|true|w value.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ r1|Vector4|true|4D vector.| |▹▹▹ r2|Vector4|true|4D vector.| |▹▹▹ r3|Vector4|true|4D vector.| |▹▹ visible|boolean|false|Item visibility.| |▹ relationships|CreateSceneItemOverrideRequest_data_relationships|true|| |▹▹ sceneItem|SceneItemRelationship|true|Relationship to a `scene-item`.| |▹▹▹ data|SceneItemRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(scene-item)|true|Resource object type.| |▹ type|string|true|Resource object type.|
   * @param {string} id The &#x60;scene-view&#x60; ID.
   * @param {CreateSceneItemOverrideRequest} createSceneItemOverrideRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemOverridesApi
   */
  public createSceneItemOverride(
    id: string,
    createSceneItemOverrideRequest: CreateSceneItemOverrideRequest,
    options?: any
  ) {
    return SceneItemOverridesApiFp(this.configuration)
      .createSceneItemOverride(id, createSceneItemOverrideRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Delete a `scene-item-override`.
   * @param {string} id The &#x60;scene-item-override&#x60; ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemOverridesApi
   */
  public deleteSceneItemOverride(id: string, options?: any) {
    return SceneItemOverridesApiFp(this.configuration)
      .deleteSceneItemOverride(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get `scene-item-overrides` for a `scene-view`.
   * @param {string} id The &#x60;scene-view&#x60; ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemOverridesApi
   */
  public getSceneItemOverrides(id: string, options?: any) {
    return SceneItemOverridesApiFp(this.configuration)
      .getSceneItemOverrides(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Update a `scene-item-override`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneItemOverrideRequest_data|true|| |▹ attributes|UpdateSceneItemOverrideRequest_data_attributes|true|| |▹▹ material|ColorMaterialNullable¦null|false|Color properties describing how a material looks.| |▹▹▹ ambient|Color3|true|RGB color.| |▹▹▹▹ b|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ g|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ r|integer(int32)|true|Color value from 0 to 255.| |▹▹▹ diffuse|Color3|true|RGB color.| |▹▹▹ emissive|Color3|true|RGB color.| |▹▹▹ glossiness|integer(int32)|true|Glossiness from 0 to 128.| |▹▹▹ opacity|integer(int32)|true|Opacity from 0 to 100.| |▹▹▹ specular|Color3|true|RGB color.| |▹▹ transform|Matrix4Nullable¦null|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| |▹▹▹ r0|Vector4|true|4D vector.| |▹▹▹▹ w|number|true|w value.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ r1|Vector4|true|4D vector.| |▹▹▹ r2|Vector4|true|4D vector.| |▹▹▹ r3|Vector4|true|4D vector.| |▹▹ visible|boolean¦null|false|Item visibility.| |▹ id|string(uuid)|true|ID of the resource.| |▹ type|string|true|Resource object type.|
   * @param {string} id The &#x60;scene-item-override&#x60; ID.
   * @param {UpdateSceneItemOverrideRequest} updateSceneItemOverrideRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemOverridesApi
   */
  public updateSceneItemOverride(
    id: string,
    updateSceneItemOverrideRequest: UpdateSceneItemOverrideRequest,
    options?: any
  ) {
    return SceneItemOverridesApiFp(this.configuration)
      .updateSceneItemOverride(id, updateSceneItemOverrideRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SceneItemsApi - axios parameter creator
 * @export
 */
export const SceneItemsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `scene-item` for a `scene`. This API is asynchronous, returning the location of a `queued-scene-item`. Check the status via the getQueuedSceneItem API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneItemRequest_data|true|| |▹ attributes|CreateSceneItemRequest_data_attributes|true|| |▹▹ materialOverride|ColorMaterial|false|Color properties describing how a material looks.| |▹▹▹ ambient|Color3|true|RGB color.| |▹▹▹▹ b|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ g|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ r|integer(int32)|true|Color value from 0 to 255.| |▹▹▹ diffuse|Color3|true|RGB color.| |▹▹▹ emissive|Color3|true|RGB color.| |▹▹▹ glossiness|integer(int32)|true|Glossiness from 0 to 128.| |▹▹▹ opacity|integer(int32)|true|Opacity from 0 to 100.| |▹▹▹ specular|Color3|true|RGB color.| |▹▹ suppliedId|string|false|ID provided for correlation. For example, an existing ID from a PLM system.| |▹▹ transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| |▹▹▹ r0|Vector4|true|4D vector.| |▹▹▹▹ w|number|true|w value.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ r1|Vector4|true|4D vector.| |▹▹▹ r2|Vector4|true|4D vector.| |▹▹▹ r3|Vector4|true|4D vector.| |▹▹ visible|boolean|false|Item visibility.| |▹ relationships|CreateSceneItemRequest_data_relationships|true|| |▹▹ source|any|true|Relationship to a `geometry-set` or `part-revision`.| |▹▹▹ *anonymous*|GeometrySetRelationship|false|Relationship to a `geometry-set`.| |▹▹▹▹ data|GeometrySetRelationshipData|true|| |▹▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹▹ type|enum(geometry-set)|true|Resource object type.| |▹▹▹ *anonymous*|PartRevisionRelationship|false|Relationship to a `part-revision`.| |▹▹▹▹ data|PartRevisionRelationship_data|true|| |▹▹▹▹▹ id|any|true|ID of the resource.| |▹▹▹▹▹▹ *anonymous*|Uuid(uuid)|false|ID of the resource.| |▹▹▹▹▹▹ *anonymous*|PartRevisionSuppliedId|false|| |▹▹▹▹▹▹▹ suppliedPartId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| |▹▹▹▹▹▹▹ suppliedRevisionId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| |▹▹▹▹▹ type|enum(part-revision)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneItemRequest} createSceneItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneItem: async (
      id: string,
      createSceneItemRequest: CreateSceneItemRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling createSceneItem.'
        );
      }
      // verify required parameter 'createSceneItemRequest' is not null or undefined
      if (
        createSceneItemRequest === null ||
        createSceneItemRequest === undefined
      ) {
        throw new RequiredError(
          'createSceneItemRequest',
          'Required parameter createSceneItemRequest was null or undefined when calling createSceneItem.'
        );
      }
      const localVarPath = `/scenes/{id}/scene-items`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof createSceneItemRequest !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createSceneItemRequest !== undefined ? createSceneItemRequest : {}
          )
        : createSceneItemRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `queued-scene-item`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `scene-item`. Once created, commit the scene via the updateScene API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.
     * @param {string} id The &#x60;queued-scene-item&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedSceneItem: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getQueuedSceneItem.'
        );
      }
      const localVarPath = `/queued-scene-items/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `scene-item` by ID.
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneItem: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getSceneItem.'
        );
      }
      const localVarPath = `/scene-items/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get `scenes-items` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {Array<string>} [filterSuppliedId] Filter with the given suppliedId(s).
     * @param {Array<string>} [filterParent] Filter with the given parent ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneItems: async (
      id: string,
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: Array<string>,
      filterParent?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getSceneItems.'
        );
      }
      const localVarPath = `/scenes/{id}/scene-items`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (filterSuppliedId) {
        localVarQueryParameter['filter[suppliedId]'] = filterSuppliedId;
      }

      if (filterParent) {
        localVarQueryParameter['filter[parent]'] = filterParent;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Update a `scene-item`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneItemRequest_data|true|| |▹ attributes|UpdateSceneItemRequest_data_attributes|true|| |▹▹ materialOverride|MaterialOverride|false|Color material override.| |▹▹▹ value|ColorMaterial|false|Color properties describing how a material looks.| |▹▹▹▹ ambient|Color3|true|RGB color.| |▹▹▹▹▹ b|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹▹ g|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹▹ r|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ diffuse|Color3|true|RGB color.| |▹▹▹▹ emissive|Color3|true|RGB color.| |▹▹▹▹ glossiness|integer(int32)|true|Glossiness from 0 to 128.| |▹▹▹▹ opacity|integer(int32)|true|Opacity from 0 to 100.| |▹▹▹▹ specular|Color3|true|RGB color.| |▹▹ transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| |▹▹▹ r0|Vector4|true|4D vector.| |▹▹▹▹ w|number|true|w value.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ r1|Vector4|true|4D vector.| |▹▹▹ r2|Vector4|true|4D vector.| |▹▹▹ r3|Vector4|true|4D vector.| |▹▹ visible|boolean|false|Item visibility.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {UpdateSceneItemRequest} updateSceneItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneItem: async (
      id: string,
      updateSceneItemRequest: UpdateSceneItemRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateSceneItem.'
        );
      }
      // verify required parameter 'updateSceneItemRequest' is not null or undefined
      if (
        updateSceneItemRequest === null ||
        updateSceneItemRequest === undefined
      ) {
        throw new RequiredError(
          'updateSceneItemRequest',
          'Required parameter updateSceneItemRequest was null or undefined when calling updateSceneItem.'
        );
      }
      const localVarPath = `/scene-items/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof updateSceneItemRequest !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            updateSceneItemRequest !== undefined ? updateSceneItemRequest : {}
          )
        : updateSceneItemRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SceneItemsApi - functional programming interface
 * @export
 */
export const SceneItemsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create a `scene-item` for a `scene`. This API is asynchronous, returning the location of a `queued-scene-item`. Check the status via the getQueuedSceneItem API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneItemRequest_data|true|| |▹ attributes|CreateSceneItemRequest_data_attributes|true|| |▹▹ materialOverride|ColorMaterial|false|Color properties describing how a material looks.| |▹▹▹ ambient|Color3|true|RGB color.| |▹▹▹▹ b|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ g|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ r|integer(int32)|true|Color value from 0 to 255.| |▹▹▹ diffuse|Color3|true|RGB color.| |▹▹▹ emissive|Color3|true|RGB color.| |▹▹▹ glossiness|integer(int32)|true|Glossiness from 0 to 128.| |▹▹▹ opacity|integer(int32)|true|Opacity from 0 to 100.| |▹▹▹ specular|Color3|true|RGB color.| |▹▹ suppliedId|string|false|ID provided for correlation. For example, an existing ID from a PLM system.| |▹▹ transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| |▹▹▹ r0|Vector4|true|4D vector.| |▹▹▹▹ w|number|true|w value.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ r1|Vector4|true|4D vector.| |▹▹▹ r2|Vector4|true|4D vector.| |▹▹▹ r3|Vector4|true|4D vector.| |▹▹ visible|boolean|false|Item visibility.| |▹ relationships|CreateSceneItemRequest_data_relationships|true|| |▹▹ source|any|true|Relationship to a `geometry-set` or `part-revision`.| |▹▹▹ *anonymous*|GeometrySetRelationship|false|Relationship to a `geometry-set`.| |▹▹▹▹ data|GeometrySetRelationshipData|true|| |▹▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹▹ type|enum(geometry-set)|true|Resource object type.| |▹▹▹ *anonymous*|PartRevisionRelationship|false|Relationship to a `part-revision`.| |▹▹▹▹ data|PartRevisionRelationship_data|true|| |▹▹▹▹▹ id|any|true|ID of the resource.| |▹▹▹▹▹▹ *anonymous*|Uuid(uuid)|false|ID of the resource.| |▹▹▹▹▹▹ *anonymous*|PartRevisionSuppliedId|false|| |▹▹▹▹▹▹▹ suppliedPartId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| |▹▹▹▹▹▹▹ suppliedRevisionId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| |▹▹▹▹▹ type|enum(part-revision)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneItemRequest} createSceneItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneItem(
      id: string,
      createSceneItemRequest: CreateSceneItemRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await SceneItemsApiAxiosParamCreator(
        configuration
      ).createSceneItem(id, createSceneItemRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `queued-scene-item`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `scene-item`. Once created, commit the scene via the updateScene API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.
     * @param {string} id The &#x60;queued-scene-item&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedSceneItem(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await SceneItemsApiAxiosParamCreator(
        configuration
      ).getQueuedSceneItem(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `scene-item` by ID.
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneItem(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneItem>
    > {
      const localVarAxiosArgs = await SceneItemsApiAxiosParamCreator(
        configuration
      ).getSceneItem(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get `scenes-items` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {Array<string>} [filterSuppliedId] Filter with the given suppliedId(s).
     * @param {Array<string>} [filterParent] Filter with the given parent ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneItems(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: Array<string>,
      filterParent?: Array<string>,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneItemList>
    > {
      const localVarAxiosArgs = await SceneItemsApiAxiosParamCreator(
        configuration
      ).getSceneItems(
        id,
        pageCursor,
        pageSize,
        filterSuppliedId,
        filterParent,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Update a `scene-item`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneItemRequest_data|true|| |▹ attributes|UpdateSceneItemRequest_data_attributes|true|| |▹▹ materialOverride|MaterialOverride|false|Color material override.| |▹▹▹ value|ColorMaterial|false|Color properties describing how a material looks.| |▹▹▹▹ ambient|Color3|true|RGB color.| |▹▹▹▹▹ b|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹▹ g|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹▹ r|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ diffuse|Color3|true|RGB color.| |▹▹▹▹ emissive|Color3|true|RGB color.| |▹▹▹▹ glossiness|integer(int32)|true|Glossiness from 0 to 128.| |▹▹▹▹ opacity|integer(int32)|true|Opacity from 0 to 100.| |▹▹▹▹ specular|Color3|true|RGB color.| |▹▹ transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| |▹▹▹ r0|Vector4|true|4D vector.| |▹▹▹▹ w|number|true|w value.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ r1|Vector4|true|4D vector.| |▹▹▹ r2|Vector4|true|4D vector.| |▹▹▹ r3|Vector4|true|4D vector.| |▹▹ visible|boolean|false|Item visibility.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {UpdateSceneItemRequest} updateSceneItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSceneItem(
      id: string,
      updateSceneItemRequest: UpdateSceneItemRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneItem>
    > {
      const localVarAxiosArgs = await SceneItemsApiAxiosParamCreator(
        configuration
      ).updateSceneItem(id, updateSceneItemRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * SceneItemsApi - factory interface
 * @export
 */
export const SceneItemsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `scene-item` for a `scene`. This API is asynchronous, returning the location of a `queued-scene-item`. Check the status via the getQueuedSceneItem API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneItemRequest_data|true|| |▹ attributes|CreateSceneItemRequest_data_attributes|true|| |▹▹ materialOverride|ColorMaterial|false|Color properties describing how a material looks.| |▹▹▹ ambient|Color3|true|RGB color.| |▹▹▹▹ b|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ g|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ r|integer(int32)|true|Color value from 0 to 255.| |▹▹▹ diffuse|Color3|true|RGB color.| |▹▹▹ emissive|Color3|true|RGB color.| |▹▹▹ glossiness|integer(int32)|true|Glossiness from 0 to 128.| |▹▹▹ opacity|integer(int32)|true|Opacity from 0 to 100.| |▹▹▹ specular|Color3|true|RGB color.| |▹▹ suppliedId|string|false|ID provided for correlation. For example, an existing ID from a PLM system.| |▹▹ transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| |▹▹▹ r0|Vector4|true|4D vector.| |▹▹▹▹ w|number|true|w value.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ r1|Vector4|true|4D vector.| |▹▹▹ r2|Vector4|true|4D vector.| |▹▹▹ r3|Vector4|true|4D vector.| |▹▹ visible|boolean|false|Item visibility.| |▹ relationships|CreateSceneItemRequest_data_relationships|true|| |▹▹ source|any|true|Relationship to a `geometry-set` or `part-revision`.| |▹▹▹ *anonymous*|GeometrySetRelationship|false|Relationship to a `geometry-set`.| |▹▹▹▹ data|GeometrySetRelationshipData|true|| |▹▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹▹ type|enum(geometry-set)|true|Resource object type.| |▹▹▹ *anonymous*|PartRevisionRelationship|false|Relationship to a `part-revision`.| |▹▹▹▹ data|PartRevisionRelationship_data|true|| |▹▹▹▹▹ id|any|true|ID of the resource.| |▹▹▹▹▹▹ *anonymous*|Uuid(uuid)|false|ID of the resource.| |▹▹▹▹▹▹ *anonymous*|PartRevisionSuppliedId|false|| |▹▹▹▹▹▹▹ suppliedPartId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| |▹▹▹▹▹▹▹ suppliedRevisionId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| |▹▹▹▹▹ type|enum(part-revision)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneItemRequest} createSceneItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneItem(
      id: string,
      createSceneItemRequest: CreateSceneItemRequest,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return SceneItemsApiFp(configuration)
        .createSceneItem(id, createSceneItemRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `queued-scene-item`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `scene-item`. Once created, commit the scene via the updateScene API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.
     * @param {string} id The &#x60;queued-scene-item&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedSceneItem(id: string, options?: any): AxiosPromise<QueuedJob> {
      return SceneItemsApiFp(configuration)
        .getQueuedSceneItem(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `scene-item` by ID.
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneItem(id: string, options?: any): AxiosPromise<SceneItem> {
      return SceneItemsApiFp(configuration)
        .getSceneItem(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get `scenes-items` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {Array<string>} [filterSuppliedId] Filter with the given suppliedId(s).
     * @param {Array<string>} [filterParent] Filter with the given parent ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneItems(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: Array<string>,
      filterParent?: Array<string>,
      options?: any
    ): AxiosPromise<SceneItemList> {
      return SceneItemsApiFp(configuration)
        .getSceneItems(
          id,
          pageCursor,
          pageSize,
          filterSuppliedId,
          filterParent,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *  Update a `scene-item`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneItemRequest_data|true|| |▹ attributes|UpdateSceneItemRequest_data_attributes|true|| |▹▹ materialOverride|MaterialOverride|false|Color material override.| |▹▹▹ value|ColorMaterial|false|Color properties describing how a material looks.| |▹▹▹▹ ambient|Color3|true|RGB color.| |▹▹▹▹▹ b|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹▹ g|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹▹ r|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ diffuse|Color3|true|RGB color.| |▹▹▹▹ emissive|Color3|true|RGB color.| |▹▹▹▹ glossiness|integer(int32)|true|Glossiness from 0 to 128.| |▹▹▹▹ opacity|integer(int32)|true|Opacity from 0 to 100.| |▹▹▹▹ specular|Color3|true|RGB color.| |▹▹ transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| |▹▹▹ r0|Vector4|true|4D vector.| |▹▹▹▹ w|number|true|w value.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ r1|Vector4|true|4D vector.| |▹▹▹ r2|Vector4|true|4D vector.| |▹▹▹ r3|Vector4|true|4D vector.| |▹▹ visible|boolean|false|Item visibility.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {UpdateSceneItemRequest} updateSceneItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneItem(
      id: string,
      updateSceneItemRequest: UpdateSceneItemRequest,
      options?: any
    ): AxiosPromise<SceneItem> {
      return SceneItemsApiFp(configuration)
        .updateSceneItem(id, updateSceneItemRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SceneItemsApi - object-oriented interface
 * @export
 * @class SceneItemsApi
 * @extends {BaseAPI}
 */
export class SceneItemsApi extends BaseAPI {
  /**
   *  Create a `scene-item` for a `scene`. This API is asynchronous, returning the location of a `queued-scene-item`. Check the status via the getQueuedSceneItem API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneItemRequest_data|true|| |▹ attributes|CreateSceneItemRequest_data_attributes|true|| |▹▹ materialOverride|ColorMaterial|false|Color properties describing how a material looks.| |▹▹▹ ambient|Color3|true|RGB color.| |▹▹▹▹ b|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ g|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ r|integer(int32)|true|Color value from 0 to 255.| |▹▹▹ diffuse|Color3|true|RGB color.| |▹▹▹ emissive|Color3|true|RGB color.| |▹▹▹ glossiness|integer(int32)|true|Glossiness from 0 to 128.| |▹▹▹ opacity|integer(int32)|true|Opacity from 0 to 100.| |▹▹▹ specular|Color3|true|RGB color.| |▹▹ suppliedId|string|false|ID provided for correlation. For example, an existing ID from a PLM system.| |▹▹ transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| |▹▹▹ r0|Vector4|true|4D vector.| |▹▹▹▹ w|number|true|w value.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ r1|Vector4|true|4D vector.| |▹▹▹ r2|Vector4|true|4D vector.| |▹▹▹ r3|Vector4|true|4D vector.| |▹▹ visible|boolean|false|Item visibility.| |▹ relationships|CreateSceneItemRequest_data_relationships|true|| |▹▹ source|any|true|Relationship to a `geometry-set` or `part-revision`.| |▹▹▹ *anonymous*|GeometrySetRelationship|false|Relationship to a `geometry-set`.| |▹▹▹▹ data|GeometrySetRelationshipData|true|| |▹▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹▹ type|enum(geometry-set)|true|Resource object type.| |▹▹▹ *anonymous*|PartRevisionRelationship|false|Relationship to a `part-revision`.| |▹▹▹▹ data|PartRevisionRelationship_data|true|| |▹▹▹▹▹ id|any|true|ID of the resource.| |▹▹▹▹▹▹ *anonymous*|Uuid(uuid)|false|ID of the resource.| |▹▹▹▹▹▹ *anonymous*|PartRevisionSuppliedId|false|| |▹▹▹▹▹▹▹ suppliedPartId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| |▹▹▹▹▹▹▹ suppliedRevisionId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| |▹▹▹▹▹ type|enum(part-revision)|true|Resource object type.| |▹ type|string|true|Resource object type.|
   * @param {string} id The &#x60;scene&#x60; ID.
   * @param {CreateSceneItemRequest} createSceneItemRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemsApi
   */
  public createSceneItem(
    id: string,
    createSceneItemRequest: CreateSceneItemRequest,
    options?: any
  ) {
    return SceneItemsApiFp(this.configuration)
      .createSceneItem(id, createSceneItemRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `queued-scene-item`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `scene-item`. Once created, commit the scene via the updateScene API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.
   * @param {string} id The &#x60;queued-scene-item&#x60; ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemsApi
   */
  public getQueuedSceneItem(id: string, options?: any) {
    return SceneItemsApiFp(this.configuration)
      .getQueuedSceneItem(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `scene-item` by ID.
   * @param {string} id The &#x60;scene-item&#x60; ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemsApi
   */
  public getSceneItem(id: string, options?: any) {
    return SceneItemsApiFp(this.configuration)
      .getSceneItem(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get `scenes-items` for a `scene`.
   * @param {string} id The &#x60;scene&#x60; ID.
   * @param {string} [pageCursor] The cursor for the next page of items.
   * @param {number} [pageSize] The number of items to return.
   * @param {Array<string>} [filterSuppliedId] Filter with the given suppliedId(s).
   * @param {Array<string>} [filterParent] Filter with the given parent ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemsApi
   */
  public getSceneItems(
    id: string,
    pageCursor?: string,
    pageSize?: number,
    filterSuppliedId?: Array<string>,
    filterParent?: Array<string>,
    options?: any
  ) {
    return SceneItemsApiFp(this.configuration)
      .getSceneItems(
        id,
        pageCursor,
        pageSize,
        filterSuppliedId,
        filterParent,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Update a `scene-item`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneItemRequest_data|true|| |▹ attributes|UpdateSceneItemRequest_data_attributes|true|| |▹▹ materialOverride|MaterialOverride|false|Color material override.| |▹▹▹ value|ColorMaterial|false|Color properties describing how a material looks.| |▹▹▹▹ ambient|Color3|true|RGB color.| |▹▹▹▹▹ b|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹▹ g|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹▹ r|integer(int32)|true|Color value from 0 to 255.| |▹▹▹▹ diffuse|Color3|true|RGB color.| |▹▹▹▹ emissive|Color3|true|RGB color.| |▹▹▹▹ glossiness|integer(int32)|true|Glossiness from 0 to 128.| |▹▹▹▹ opacity|integer(int32)|true|Opacity from 0 to 100.| |▹▹▹▹ specular|Color3|true|RGB color.| |▹▹ transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| |▹▹▹ r0|Vector4|true|4D vector.| |▹▹▹▹ w|number|true|w value.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ r1|Vector4|true|4D vector.| |▹▹▹ r2|Vector4|true|4D vector.| |▹▹▹ r3|Vector4|true|4D vector.| |▹▹ visible|boolean|false|Item visibility.| |▹ type|string|true|Resource object type.|
   * @param {string} id The &#x60;scene-item&#x60; ID.
   * @param {UpdateSceneItemRequest} updateSceneItemRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemsApi
   */
  public updateSceneItem(
    id: string,
    updateSceneItemRequest: UpdateSceneItemRequest,
    options?: any
  ) {
    return SceneItemsApiFp(this.configuration)
      .updateSceneItem(id, updateSceneItemRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SceneTemplatesApi - axios parameter creator
 * @export
 */
export const SceneTemplatesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `scene-template`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneTemplateRequest_data|true|| |▹ attributes|CreateSceneTemplateRequest_data_attributes|true|| |▹▹ name|string|false|Name of the scene template.| |▹▹ suppliedId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| |▹ relationships|CreateGeometrySetRequest_data_relationships|true|| |▹▹ source|FileRelationship|true|Relationship to a `file`.| |▹▹▹ data|FileRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(file)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {CreateSceneTemplateRequest} createSceneTemplateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneTemplate: async (
      createSceneTemplateRequest: CreateSceneTemplateRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createSceneTemplateRequest' is not null or undefined
      if (
        createSceneTemplateRequest === null ||
        createSceneTemplateRequest === undefined
      ) {
        throw new RequiredError(
          'createSceneTemplateRequest',
          'Required parameter createSceneTemplateRequest was null or undefined when calling createSceneTemplate.'
        );
      }
      const localVarPath = `/scene-templates`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof createSceneTemplateRequest !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createSceneTemplateRequest !== undefined
              ? createSceneTemplateRequest
              : {}
          )
        : createSceneTemplateRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `queued-scene-template`.
     * @param {string} id The &#x60;queued-scene-template&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedSceneTemplate: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getQueuedSceneTemplate.'
        );
      }
      const localVarPath = `/queued-scene-templates/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `scene-template` by ID.
     * @param {string} id The &#x60;scene-template&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneTemplate: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getSceneTemplate.'
        );
      }
      const localVarPath = `/scene-templates/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get `scene-templates`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneTemplates: async (
      pageCursor?: string,
      pageSize?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/scene-templates`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SceneTemplatesApi - functional programming interface
 * @export
 */
export const SceneTemplatesApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create a `scene-template`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneTemplateRequest_data|true|| |▹ attributes|CreateSceneTemplateRequest_data_attributes|true|| |▹▹ name|string|false|Name of the scene template.| |▹▹ suppliedId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| |▹ relationships|CreateGeometrySetRequest_data_relationships|true|| |▹▹ source|FileRelationship|true|Relationship to a `file`.| |▹▹▹ data|FileRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(file)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {CreateSceneTemplateRequest} createSceneTemplateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneTemplate(
      createSceneTemplateRequest: CreateSceneTemplateRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await SceneTemplatesApiAxiosParamCreator(
        configuration
      ).createSceneTemplate(createSceneTemplateRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `queued-scene-template`.
     * @param {string} id The &#x60;queued-scene-template&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedSceneTemplate(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await SceneTemplatesApiAxiosParamCreator(
        configuration
      ).getQueuedSceneTemplate(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `scene-template` by ID.
     * @param {string} id The &#x60;scene-template&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneTemplate(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneTemplate>
    > {
      const localVarAxiosArgs = await SceneTemplatesApiAxiosParamCreator(
        configuration
      ).getSceneTemplate(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get `scene-templates`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneTemplates(
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneTemplateList>
    > {
      const localVarAxiosArgs = await SceneTemplatesApiAxiosParamCreator(
        configuration
      ).getSceneTemplates(pageCursor, pageSize, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * SceneTemplatesApi - factory interface
 * @export
 */
export const SceneTemplatesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `scene-template`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneTemplateRequest_data|true|| |▹ attributes|CreateSceneTemplateRequest_data_attributes|true|| |▹▹ name|string|false|Name of the scene template.| |▹▹ suppliedId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| |▹ relationships|CreateGeometrySetRequest_data_relationships|true|| |▹▹ source|FileRelationship|true|Relationship to a `file`.| |▹▹▹ data|FileRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(file)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {CreateSceneTemplateRequest} createSceneTemplateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneTemplate(
      createSceneTemplateRequest: CreateSceneTemplateRequest,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return SceneTemplatesApiFp(configuration)
        .createSceneTemplate(createSceneTemplateRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `queued-scene-template`.
     * @param {string} id The &#x60;queued-scene-template&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedSceneTemplate(id: string, options?: any): AxiosPromise<QueuedJob> {
      return SceneTemplatesApiFp(configuration)
        .getQueuedSceneTemplate(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `scene-template` by ID.
     * @param {string} id The &#x60;scene-template&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneTemplate(id: string, options?: any): AxiosPromise<SceneTemplate> {
      return SceneTemplatesApiFp(configuration)
        .getSceneTemplate(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get `scene-templates`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneTemplates(
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<SceneTemplateList> {
      return SceneTemplatesApiFp(configuration)
        .getSceneTemplates(pageCursor, pageSize, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SceneTemplatesApi - object-oriented interface
 * @export
 * @class SceneTemplatesApi
 * @extends {BaseAPI}
 */
export class SceneTemplatesApi extends BaseAPI {
  /**
   *  Create a `scene-template`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneTemplateRequest_data|true|| |▹ attributes|CreateSceneTemplateRequest_data_attributes|true|| |▹▹ name|string|false|Name of the scene template.| |▹▹ suppliedId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| |▹ relationships|CreateGeometrySetRequest_data_relationships|true|| |▹▹ source|FileRelationship|true|Relationship to a `file`.| |▹▹▹ data|FileRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(file)|true|Resource object type.| |▹ type|string|true|Resource object type.|
   * @param {CreateSceneTemplateRequest} createSceneTemplateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneTemplatesApi
   */
  public createSceneTemplate(
    createSceneTemplateRequest: CreateSceneTemplateRequest,
    options?: any
  ) {
    return SceneTemplatesApiFp(this.configuration)
      .createSceneTemplate(createSceneTemplateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `queued-scene-template`.
   * @param {string} id The &#x60;queued-scene-template&#x60; ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneTemplatesApi
   */
  public getQueuedSceneTemplate(id: string, options?: any) {
    return SceneTemplatesApiFp(this.configuration)
      .getQueuedSceneTemplate(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `scene-template` by ID.
   * @param {string} id The &#x60;scene-template&#x60; ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneTemplatesApi
   */
  public getSceneTemplate(id: string, options?: any) {
    return SceneTemplatesApiFp(this.configuration)
      .getSceneTemplate(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get `scene-templates`.
   * @param {string} [pageCursor] The cursor for the next page of items.
   * @param {number} [pageSize] The number of items to return.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneTemplatesApi
   */
  public getSceneTemplates(
    pageCursor?: string,
    pageSize?: number,
    options?: any
  ) {
    return SceneTemplatesApiFp(this.configuration)
      .getSceneTemplates(pageCursor, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SceneViewsApi - axios parameter creator
 * @export
 */
export const SceneViewsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `scene-view` of a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneViewRequest_data|true|| |▹ attributes|CreateSceneViewRequest_data_attributes|true|| |▹▹ camera|Camera|false|Camera placement in 3D space.| |▹▹▹ lookAt|Vector3|true|3D vector.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ position|Vector3|true|3D vector.| |▹▹▹ up|Vector3|true|3D vector.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneViewRequest} createSceneViewRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneView: async (
      id: string,
      createSceneViewRequest: CreateSceneViewRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling createSceneView.'
        );
      }
      // verify required parameter 'createSceneViewRequest' is not null or undefined
      if (
        createSceneViewRequest === null ||
        createSceneViewRequest === undefined
      ) {
        throw new RequiredError(
          'createSceneViewRequest',
          'Required parameter createSceneViewRequest was null or undefined when calling createSceneView.'
        );
      }
      const localVarPath = `/scenes/{id}/scene-views`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof createSceneViewRequest !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createSceneViewRequest !== undefined ? createSceneViewRequest : {}
          )
        : createSceneViewRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Delete a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSceneView: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteSceneView.'
        );
      }
      const localVarPath = `/scene-views/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `scene-view` by ID.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneView: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getSceneView.'
        );
      }
      const localVarPath = `/scene-views/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a rendered image of a `scene-view`. If a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {number} [height] The height of the image to render.
     * @param {number} [width] The width of the image to render.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    renderSceneView: async (
      id: string,
      height?: number,
      width?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling renderSceneView.'
        );
      }
      const localVarPath = `/scene-views/{id}/image`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (height !== undefined) {
        localVarQueryParameter['height'] = height;
      }

      if (width !== undefined) {
        localVarQueryParameter['width'] = width;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Update a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneViewRequest_data|true|| |▹ attributes|UpdateSceneViewRequest_data_attributes|true|| |▹▹ camera|any|false|| |▹▹▹ *anonymous*|Camera|false|Camera placement in 3D space.| |▹▹▹▹ lookAt|Vector3|true|3D vector.| |▹▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹▹ position|Vector3|true|3D vector.| |▹▹▹▹ up|Vector3|true|3D vector.| |▹▹▹ *anonymous*|CameraFit|false|Fit camera in 3D space based on items in scene.| |▹▹▹▹ type|enum(fit-visible-scene-items)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {UpdateSceneViewRequest} updateSceneViewRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneView: async (
      id: string,
      updateSceneViewRequest: UpdateSceneViewRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateSceneView.'
        );
      }
      // verify required parameter 'updateSceneViewRequest' is not null or undefined
      if (
        updateSceneViewRequest === null ||
        updateSceneViewRequest === undefined
      ) {
        throw new RequiredError(
          'updateSceneViewRequest',
          'Required parameter updateSceneViewRequest was null or undefined when calling updateSceneView.'
        );
      }
      const localVarPath = `/scene-views/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof updateSceneViewRequest !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            updateSceneViewRequest !== undefined ? updateSceneViewRequest : {}
          )
        : updateSceneViewRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SceneViewsApi - functional programming interface
 * @export
 */
export const SceneViewsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create a `scene-view` of a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneViewRequest_data|true|| |▹ attributes|CreateSceneViewRequest_data_attributes|true|| |▹▹ camera|Camera|false|Camera placement in 3D space.| |▹▹▹ lookAt|Vector3|true|3D vector.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ position|Vector3|true|3D vector.| |▹▹▹ up|Vector3|true|3D vector.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneViewRequest} createSceneViewRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneView(
      id: string,
      createSceneViewRequest: CreateSceneViewRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneView>
    > {
      const localVarAxiosArgs = await SceneViewsApiAxiosParamCreator(
        configuration
      ).createSceneView(id, createSceneViewRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Delete a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSceneView(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SceneViewsApiAxiosParamCreator(
        configuration
      ).deleteSceneView(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `scene-view` by ID.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneView(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneView>
    > {
      const localVarAxiosArgs = await SceneViewsApiAxiosParamCreator(
        configuration
      ).getSceneView(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a rendered image of a `scene-view`. If a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {number} [height] The height of the image to render.
     * @param {number} [width] The width of the image to render.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async renderSceneView(
      id: string,
      height?: number,
      width?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs = await SceneViewsApiAxiosParamCreator(
        configuration
      ).renderSceneView(id, height, width, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Update a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneViewRequest_data|true|| |▹ attributes|UpdateSceneViewRequest_data_attributes|true|| |▹▹ camera|any|false|| |▹▹▹ *anonymous*|Camera|false|Camera placement in 3D space.| |▹▹▹▹ lookAt|Vector3|true|3D vector.| |▹▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹▹ position|Vector3|true|3D vector.| |▹▹▹▹ up|Vector3|true|3D vector.| |▹▹▹ *anonymous*|CameraFit|false|Fit camera in 3D space based on items in scene.| |▹▹▹▹ type|enum(fit-visible-scene-items)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {UpdateSceneViewRequest} updateSceneViewRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSceneView(
      id: string,
      updateSceneViewRequest: UpdateSceneViewRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneView>
    > {
      const localVarAxiosArgs = await SceneViewsApiAxiosParamCreator(
        configuration
      ).updateSceneView(id, updateSceneViewRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * SceneViewsApi - factory interface
 * @export
 */
export const SceneViewsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `scene-view` of a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneViewRequest_data|true|| |▹ attributes|CreateSceneViewRequest_data_attributes|true|| |▹▹ camera|Camera|false|Camera placement in 3D space.| |▹▹▹ lookAt|Vector3|true|3D vector.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ position|Vector3|true|3D vector.| |▹▹▹ up|Vector3|true|3D vector.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneViewRequest} createSceneViewRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneView(
      id: string,
      createSceneViewRequest: CreateSceneViewRequest,
      options?: any
    ): AxiosPromise<SceneView> {
      return SceneViewsApiFp(configuration)
        .createSceneView(id, createSceneViewRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Delete a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSceneView(id: string, options?: any): AxiosPromise<void> {
      return SceneViewsApiFp(configuration)
        .deleteSceneView(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `scene-view` by ID.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneView(id: string, options?: any): AxiosPromise<SceneView> {
      return SceneViewsApiFp(configuration)
        .getSceneView(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a rendered image of a `scene-view`. If a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {number} [height] The height of the image to render.
     * @param {number} [width] The width of the image to render.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    renderSceneView(
      id: string,
      height?: number,
      width?: number,
      options?: any
    ): AxiosPromise<any> {
      return SceneViewsApiFp(configuration)
        .renderSceneView(id, height, width, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Update a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneViewRequest_data|true|| |▹ attributes|UpdateSceneViewRequest_data_attributes|true|| |▹▹ camera|any|false|| |▹▹▹ *anonymous*|Camera|false|Camera placement in 3D space.| |▹▹▹▹ lookAt|Vector3|true|3D vector.| |▹▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹▹ position|Vector3|true|3D vector.| |▹▹▹▹ up|Vector3|true|3D vector.| |▹▹▹ *anonymous*|CameraFit|false|Fit camera in 3D space based on items in scene.| |▹▹▹▹ type|enum(fit-visible-scene-items)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {UpdateSceneViewRequest} updateSceneViewRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneView(
      id: string,
      updateSceneViewRequest: UpdateSceneViewRequest,
      options?: any
    ): AxiosPromise<SceneView> {
      return SceneViewsApiFp(configuration)
        .updateSceneView(id, updateSceneViewRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SceneViewsApi - object-oriented interface
 * @export
 * @class SceneViewsApi
 * @extends {BaseAPI}
 */
export class SceneViewsApi extends BaseAPI {
  /**
   *  Create a `scene-view` of a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneViewRequest_data|true|| |▹ attributes|CreateSceneViewRequest_data_attributes|true|| |▹▹ camera|Camera|false|Camera placement in 3D space.| |▹▹▹ lookAt|Vector3|true|3D vector.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ position|Vector3|true|3D vector.| |▹▹▹ up|Vector3|true|3D vector.| |▹ type|string|true|Resource object type.|
   * @param {string} id The &#x60;scene&#x60; ID.
   * @param {CreateSceneViewRequest} createSceneViewRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewsApi
   */
  public createSceneView(
    id: string,
    createSceneViewRequest: CreateSceneViewRequest,
    options?: any
  ) {
    return SceneViewsApiFp(this.configuration)
      .createSceneView(id, createSceneViewRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Delete a `scene-view`.
   * @param {string} id The &#x60;scene-view&#x60; ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewsApi
   */
  public deleteSceneView(id: string, options?: any) {
    return SceneViewsApiFp(this.configuration)
      .deleteSceneView(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `scene-view` by ID.
   * @param {string} id The &#x60;scene-view&#x60; ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewsApi
   */
  public getSceneView(id: string, options?: any) {
    return SceneViewsApiFp(this.configuration)
      .getSceneView(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a rendered image of a `scene-view`. If a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
   * @param {string} id The &#x60;scene-view&#x60; ID.
   * @param {number} [height] The height of the image to render.
   * @param {number} [width] The width of the image to render.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewsApi
   */
  public renderSceneView(
    id: string,
    height?: number,
    width?: number,
    options?: any
  ) {
    return SceneViewsApiFp(this.configuration)
      .renderSceneView(id, height, width, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Update a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneViewRequest_data|true|| |▹ attributes|UpdateSceneViewRequest_data_attributes|true|| |▹▹ camera|any|false|| |▹▹▹ *anonymous*|Camera|false|Camera placement in 3D space.| |▹▹▹▹ lookAt|Vector3|true|3D vector.| |▹▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹▹ position|Vector3|true|3D vector.| |▹▹▹▹ up|Vector3|true|3D vector.| |▹▹▹ *anonymous*|CameraFit|false|Fit camera in 3D space based on items in scene.| |▹▹▹▹ type|enum(fit-visible-scene-items)|true|Resource object type.| |▹ type|string|true|Resource object type.|
   * @param {string} id The &#x60;scene-view&#x60; ID.
   * @param {UpdateSceneViewRequest} updateSceneViewRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewsApi
   */
  public updateSceneView(
    id: string,
    updateSceneViewRequest: UpdateSceneViewRequest,
    options?: any
  ) {
    return SceneViewsApiFp(this.configuration)
      .updateSceneView(id, updateSceneViewRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ScenesApi - axios parameter creator
 * @export
 */
export const ScenesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `scene`. Once created, add scene items via the createSceneItem API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneRequest_data|true|| |▹ attributes|CreateSceneViewRequest_data_attributes|true|| |▹▹ camera|Camera|false|Camera placement in 3D space.| |▹▹▹ lookAt|Vector3|true|3D vector.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ position|Vector3|true|3D vector.| |▹▹▹ up|Vector3|true|3D vector.| |▹ relationships|CreateSceneRequest_data_relationships|false|| |▹▹ source|SceneTemplateRelationship|true|Relationship to a `scene-template`.| |▹▹▹ data|SceneTemplateRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(scene-template)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {CreateSceneRequest} createSceneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createScene: async (
      createSceneRequest: CreateSceneRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createSceneRequest' is not null or undefined
      if (createSceneRequest === null || createSceneRequest === undefined) {
        throw new RequiredError(
          'createSceneRequest',
          'Required parameter createSceneRequest was null or undefined when calling createScene.'
        );
      }
      const localVarPath = `/scenes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof createSceneRequest !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createSceneRequest !== undefined ? createSceneRequest : {}
          )
        : createSceneRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `queued-scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedScene: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getQueuedScene.'
        );
      }
      const localVarPath = `/queued-scenes/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `scene` by ID.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScene: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getScene.'
        );
      }
      const localVarPath = `/scenes/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get `scenes`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScenes: async (
      pageCursor?: string,
      pageSize?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/scenes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a rendered image of a `scene`. If only a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {number} [height] The height of the image to render.
     * @param {number} [width] The width of the image to render.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    renderScene: async (
      id: string,
      height?: number,
      width?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling renderScene.'
        );
      }
      const localVarPath = `/scenes/{id}/image`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (height !== undefined) {
        localVarQueryParameter['height'] = height;
      }

      if (width !== undefined) {
        localVarQueryParameter['width'] = width;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Update a `scene` camera and/or state. Once updated, view the scene via the renderScene API or with the Viewer SDK. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneRequest_data|true|| |▹ attributes|UpdateSceneRequest_data_attributes|true|| |▹▹ camera|any|false|| |▹▹▹ *anonymous*|Camera|false|Camera placement in 3D space.| |▹▹▹▹ lookAt|Vector3|true|3D vector.| |▹▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹▹ position|Vector3|true|3D vector.| |▹▹▹▹ up|Vector3|true|3D vector.| |▹▹▹ *anonymous*|CameraFit|false|Fit camera in 3D space based on items in scene.| |▹▹▹▹ type|enum(fit-visible-scene-items)|true|Resource object type.| |▹▹ state|enum(draft, commit)|false|State of the scene.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {UpdateSceneRequest} updateSceneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateScene: async (
      id: string,
      updateSceneRequest: UpdateSceneRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateScene.'
        );
      }
      // verify required parameter 'updateSceneRequest' is not null or undefined
      if (updateSceneRequest === null || updateSceneRequest === undefined) {
        throw new RequiredError(
          'updateSceneRequest',
          'Required parameter updateSceneRequest was null or undefined when calling updateScene.'
        );
      }
      const localVarPath = `/scenes/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof updateSceneRequest !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            updateSceneRequest !== undefined ? updateSceneRequest : {}
          )
        : updateSceneRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ScenesApi - functional programming interface
 * @export
 */
export const ScenesApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create a `scene`. Once created, add scene items via the createSceneItem API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneRequest_data|true|| |▹ attributes|CreateSceneViewRequest_data_attributes|true|| |▹▹ camera|Camera|false|Camera placement in 3D space.| |▹▹▹ lookAt|Vector3|true|3D vector.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ position|Vector3|true|3D vector.| |▹▹▹ up|Vector3|true|3D vector.| |▹ relationships|CreateSceneRequest_data_relationships|false|| |▹▹ source|SceneTemplateRelationship|true|Relationship to a `scene-template`.| |▹▹▹ data|SceneTemplateRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(scene-template)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {CreateSceneRequest} createSceneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createScene(
      createSceneRequest: CreateSceneRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scene>
    > {
      const localVarAxiosArgs = await ScenesApiAxiosParamCreator(
        configuration
      ).createScene(createSceneRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `queued-scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedScene(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await ScenesApiAxiosParamCreator(
        configuration
      ).getQueuedScene(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `scene` by ID.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getScene(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scene>
    > {
      const localVarAxiosArgs = await ScenesApiAxiosParamCreator(
        configuration
      ).getScene(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get `scenes`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getScenes(
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneList>
    > {
      const localVarAxiosArgs = await ScenesApiAxiosParamCreator(
        configuration
      ).getScenes(pageCursor, pageSize, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a rendered image of a `scene`. If only a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {number} [height] The height of the image to render.
     * @param {number} [width] The width of the image to render.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async renderScene(
      id: string,
      height?: number,
      width?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs = await ScenesApiAxiosParamCreator(
        configuration
      ).renderScene(id, height, width, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Update a `scene` camera and/or state. Once updated, view the scene via the renderScene API or with the Viewer SDK. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneRequest_data|true|| |▹ attributes|UpdateSceneRequest_data_attributes|true|| |▹▹ camera|any|false|| |▹▹▹ *anonymous*|Camera|false|Camera placement in 3D space.| |▹▹▹▹ lookAt|Vector3|true|3D vector.| |▹▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹▹ position|Vector3|true|3D vector.| |▹▹▹▹ up|Vector3|true|3D vector.| |▹▹▹ *anonymous*|CameraFit|false|Fit camera in 3D space based on items in scene.| |▹▹▹▹ type|enum(fit-visible-scene-items)|true|Resource object type.| |▹▹ state|enum(draft, commit)|false|State of the scene.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {UpdateSceneRequest} updateSceneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateScene(
      id: string,
      updateSceneRequest: UpdateSceneRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scene>
    > {
      const localVarAxiosArgs = await ScenesApiAxiosParamCreator(
        configuration
      ).updateScene(id, updateSceneRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * ScenesApi - factory interface
 * @export
 */
export const ScenesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `scene`. Once created, add scene items via the createSceneItem API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneRequest_data|true|| |▹ attributes|CreateSceneViewRequest_data_attributes|true|| |▹▹ camera|Camera|false|Camera placement in 3D space.| |▹▹▹ lookAt|Vector3|true|3D vector.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ position|Vector3|true|3D vector.| |▹▹▹ up|Vector3|true|3D vector.| |▹ relationships|CreateSceneRequest_data_relationships|false|| |▹▹ source|SceneTemplateRelationship|true|Relationship to a `scene-template`.| |▹▹▹ data|SceneTemplateRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(scene-template)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {CreateSceneRequest} createSceneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createScene(
      createSceneRequest: CreateSceneRequest,
      options?: any
    ): AxiosPromise<Scene> {
      return ScenesApiFp(configuration)
        .createScene(createSceneRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `queued-scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedScene(id: string, options?: any): AxiosPromise<QueuedJob> {
      return ScenesApiFp(configuration)
        .getQueuedScene(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `scene` by ID.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScene(id: string, options?: any): AxiosPromise<Scene> {
      return ScenesApiFp(configuration)
        .getScene(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get `scenes`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScenes(
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<SceneList> {
      return ScenesApiFp(configuration)
        .getScenes(pageCursor, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a rendered image of a `scene`. If only a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {number} [height] The height of the image to render.
     * @param {number} [width] The width of the image to render.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    renderScene(
      id: string,
      height?: number,
      width?: number,
      options?: any
    ): AxiosPromise<any> {
      return ScenesApiFp(configuration)
        .renderScene(id, height, width, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Update a `scene` camera and/or state. Once updated, view the scene via the renderScene API or with the Viewer SDK. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneRequest_data|true|| |▹ attributes|UpdateSceneRequest_data_attributes|true|| |▹▹ camera|any|false|| |▹▹▹ *anonymous*|Camera|false|Camera placement in 3D space.| |▹▹▹▹ lookAt|Vector3|true|3D vector.| |▹▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹▹ position|Vector3|true|3D vector.| |▹▹▹▹ up|Vector3|true|3D vector.| |▹▹▹ *anonymous*|CameraFit|false|Fit camera in 3D space based on items in scene.| |▹▹▹▹ type|enum(fit-visible-scene-items)|true|Resource object type.| |▹▹ state|enum(draft, commit)|false|State of the scene.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {UpdateSceneRequest} updateSceneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateScene(
      id: string,
      updateSceneRequest: UpdateSceneRequest,
      options?: any
    ): AxiosPromise<Scene> {
      return ScenesApiFp(configuration)
        .updateScene(id, updateSceneRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ScenesApi - object-oriented interface
 * @export
 * @class ScenesApi
 * @extends {BaseAPI}
 */
export class ScenesApi extends BaseAPI {
  /**
   *  Create a `scene`. Once created, add scene items via the createSceneItem API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneRequest_data|true|| |▹ attributes|CreateSceneViewRequest_data_attributes|true|| |▹▹ camera|Camera|false|Camera placement in 3D space.| |▹▹▹ lookAt|Vector3|true|3D vector.| |▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹ position|Vector3|true|3D vector.| |▹▹▹ up|Vector3|true|3D vector.| |▹ relationships|CreateSceneRequest_data_relationships|false|| |▹▹ source|SceneTemplateRelationship|true|Relationship to a `scene-template`.| |▹▹▹ data|SceneTemplateRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(scene-template)|true|Resource object type.| |▹ type|string|true|Resource object type.|
   * @param {CreateSceneRequest} createSceneRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public createScene(createSceneRequest: CreateSceneRequest, options?: any) {
    return ScenesApiFp(this.configuration)
      .createScene(createSceneRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `queued-scene`.
   * @param {string} id The &#x60;scene&#x60; ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public getQueuedScene(id: string, options?: any) {
    return ScenesApiFp(this.configuration)
      .getQueuedScene(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `scene` by ID.
   * @param {string} id The &#x60;scene&#x60; ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public getScene(id: string, options?: any) {
    return ScenesApiFp(this.configuration)
      .getScene(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get `scenes`.
   * @param {string} [pageCursor] The cursor for the next page of items.
   * @param {number} [pageSize] The number of items to return.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public getScenes(pageCursor?: string, pageSize?: number, options?: any) {
    return ScenesApiFp(this.configuration)
      .getScenes(pageCursor, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a rendered image of a `scene`. If only a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
   * @param {string} id The &#x60;scene&#x60; ID.
   * @param {number} [height] The height of the image to render.
   * @param {number} [width] The width of the image to render.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public renderScene(
    id: string,
    height?: number,
    width?: number,
    options?: any
  ) {
    return ScenesApiFp(this.configuration)
      .renderScene(id, height, width, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Update a `scene` camera and/or state. Once updated, view the scene via the renderScene API or with the Viewer SDK. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneRequest_data|true|| |▹ attributes|UpdateSceneRequest_data_attributes|true|| |▹▹ camera|any|false|| |▹▹▹ *anonymous*|Camera|false|Camera placement in 3D space.| |▹▹▹▹ lookAt|Vector3|true|3D vector.| |▹▹▹▹▹ x|number|true|x-axis coordinate.| |▹▹▹▹▹ y|number|true|y-axis coordinate.| |▹▹▹▹▹ z|number|true|z-axis coordinate.| |▹▹▹▹ position|Vector3|true|3D vector.| |▹▹▹▹ up|Vector3|true|3D vector.| |▹▹▹ *anonymous*|CameraFit|false|Fit camera in 3D space based on items in scene.| |▹▹▹▹ type|enum(fit-visible-scene-items)|true|Resource object type.| |▹▹ state|enum(draft, commit)|false|State of the scene.| |▹ type|string|true|Resource object type.|
   * @param {string} id The &#x60;scene&#x60; ID.
   * @param {UpdateSceneRequest} updateSceneRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public updateScene(
    id: string,
    updateSceneRequest: UpdateSceneRequest,
    options?: any
  ) {
    return ScenesApiFp(this.configuration)
      .updateScene(id, updateSceneRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * StreamKeysApi - axios parameter creator
 * @export
 */
export const StreamKeysApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `stream-key` for a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateStreamKeyRequest_data|true|| |▹ attributes|CreateStreamKeyRequest_data_attributes|true|| |▹▹ expiry|integer(int32)|false|Number of seconds before the `stream-key` expires.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateStreamKeyRequest} createStreamKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneStreamKey: async (
      id: string,
      createStreamKeyRequest: CreateStreamKeyRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling createSceneStreamKey.'
        );
      }
      // verify required parameter 'createStreamKeyRequest' is not null or undefined
      if (
        createStreamKeyRequest === null ||
        createStreamKeyRequest === undefined
      ) {
        throw new RequiredError(
          'createStreamKeyRequest',
          'Required parameter createStreamKeyRequest was null or undefined when calling createSceneStreamKey.'
        );
      }
      const localVarPath = `/scenes/{id}/stream-keys`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof createStreamKeyRequest !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createStreamKeyRequest !== undefined ? createStreamKeyRequest : {}
          )
        : createStreamKeyRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Delete a `stream-key`.
     * @param {string} id The &#x60;stream-key&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteStreamKey: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteStreamKey.'
        );
      }
      const localVarPath = `/stream-keys/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get `stream-key`s.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStreamKeys: async (
      pageCursor?: string,
      pageSize?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/stream-keys`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StreamKeysApi - functional programming interface
 * @export
 */
export const StreamKeysApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create a `stream-key` for a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateStreamKeyRequest_data|true|| |▹ attributes|CreateStreamKeyRequest_data_attributes|true|| |▹▹ expiry|integer(int32)|false|Number of seconds before the `stream-key` expires.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateStreamKeyRequest} createStreamKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneStreamKey(
      id: string,
      createStreamKeyRequest: CreateStreamKeyRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamKey>
    > {
      const localVarAxiosArgs = await StreamKeysApiAxiosParamCreator(
        configuration
      ).createSceneStreamKey(id, createStreamKeyRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Delete a `stream-key`.
     * @param {string} id The &#x60;stream-key&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteStreamKey(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await StreamKeysApiAxiosParamCreator(
        configuration
      ).deleteStreamKey(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get `stream-key`s.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStreamKeys(
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamKeyList>
    > {
      const localVarAxiosArgs = await StreamKeysApiAxiosParamCreator(
        configuration
      ).getStreamKeys(pageCursor, pageSize, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * StreamKeysApi - factory interface
 * @export
 */
export const StreamKeysApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `stream-key` for a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateStreamKeyRequest_data|true|| |▹ attributes|CreateStreamKeyRequest_data_attributes|true|| |▹▹ expiry|integer(int32)|false|Number of seconds before the `stream-key` expires.| |▹ type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateStreamKeyRequest} createStreamKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneStreamKey(
      id: string,
      createStreamKeyRequest: CreateStreamKeyRequest,
      options?: any
    ): AxiosPromise<StreamKey> {
      return StreamKeysApiFp(configuration)
        .createSceneStreamKey(id, createStreamKeyRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Delete a `stream-key`.
     * @param {string} id The &#x60;stream-key&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteStreamKey(id: string, options?: any): AxiosPromise<void> {
      return StreamKeysApiFp(configuration)
        .deleteStreamKey(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get `stream-key`s.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStreamKeys(
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<StreamKeyList> {
      return StreamKeysApiFp(configuration)
        .getStreamKeys(pageCursor, pageSize, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * StreamKeysApi - object-oriented interface
 * @export
 * @class StreamKeysApi
 * @extends {BaseAPI}
 */
export class StreamKeysApi extends BaseAPI {
  /**
   *  Create a `stream-key` for a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateStreamKeyRequest_data|true|| |▹ attributes|CreateStreamKeyRequest_data_attributes|true|| |▹▹ expiry|integer(int32)|false|Number of seconds before the `stream-key` expires.| |▹ type|string|true|Resource object type.|
   * @param {string} id The &#x60;scene&#x60; ID.
   * @param {CreateStreamKeyRequest} createStreamKeyRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StreamKeysApi
   */
  public createSceneStreamKey(
    id: string,
    createStreamKeyRequest: CreateStreamKeyRequest,
    options?: any
  ) {
    return StreamKeysApiFp(this.configuration)
      .createSceneStreamKey(id, createStreamKeyRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Delete a `stream-key`.
   * @param {string} id The &#x60;stream-key&#x60; ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StreamKeysApi
   */
  public deleteStreamKey(id: string, options?: any) {
    return StreamKeysApiFp(this.configuration)
      .deleteStreamKey(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get `stream-key`s.
   * @param {string} [pageCursor] The cursor for the next page of items.
   * @param {number} [pageSize] The number of items to return.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StreamKeysApi
   */
  public getStreamKeys(pageCursor?: string, pageSize?: number, options?: any) {
    return StreamKeysApiFp(this.configuration)
      .getStreamKeys(pageCursor, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TranslationInspectionsApi - axios parameter creator
 * @export
 */
export const TranslationInspectionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `translation-inspection`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateTranslationInspectionRequest_data|true|| |▹ relationships|CreateGeometrySetRequest_data_relationships|true|| |▹▹ source|FileRelationship|true|Relationship to a `file`.| |▹▹▹ data|FileRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(file)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {CreateTranslationInspectionRequest} createTranslationInspectionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTranslationInspection: async (
      createTranslationInspectionRequest: CreateTranslationInspectionRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createTranslationInspectionRequest' is not null or undefined
      if (
        createTranslationInspectionRequest === null ||
        createTranslationInspectionRequest === undefined
      ) {
        throw new RequiredError(
          'createTranslationInspectionRequest',
          'Required parameter createTranslationInspectionRequest was null or undefined when calling createTranslationInspection.'
        );
      }
      const localVarPath = `/translation-inspections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof createTranslationInspectionRequest !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createTranslationInspectionRequest !== undefined
              ? createTranslationInspectionRequest
              : {}
          )
        : createTranslationInspectionRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `translation-inspection` by ID.
     * @param {string} id The &#x60;translation-inspection&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInspectionJob: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getInspectionJob.'
        );
      }
      const localVarPath = `/translation-inspections/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `queued-translation`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `part-revision`. Once created, create scenes via the createScene API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.
     * @param {string} id The &#x60;queued-translation&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedTranslation: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getQueuedTranslation.'
        );
      }
      const localVarPath = `/queued-translations/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        query.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TranslationInspectionsApi - functional programming interface
 * @export
 */
export const TranslationInspectionsApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `translation-inspection`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateTranslationInspectionRequest_data|true|| |▹ relationships|CreateGeometrySetRequest_data_relationships|true|| |▹▹ source|FileRelationship|true|Relationship to a `file`.| |▹▹▹ data|FileRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(file)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {CreateTranslationInspectionRequest} createTranslationInspectionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTranslationInspection(
      createTranslationInspectionRequest: CreateTranslationInspectionRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<TranslationInspectionJob>
    > {
      const localVarAxiosArgs = await TranslationInspectionsApiAxiosParamCreator(
        configuration
      ).createTranslationInspection(
        createTranslationInspectionRequest,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `translation-inspection` by ID.
     * @param {string} id The &#x60;translation-inspection&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInspectionJob(
      id: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<TranslationInspectionJob>
    > {
      const localVarAxiosArgs = await TranslationInspectionsApiAxiosParamCreator(
        configuration
      ).getInspectionJob(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `queued-translation`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `part-revision`. Once created, create scenes via the createScene API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.
     * @param {string} id The &#x60;queued-translation&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedTranslation(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await TranslationInspectionsApiAxiosParamCreator(
        configuration
      ).getQueuedTranslation(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * TranslationInspectionsApi - factory interface
 * @export
 */
export const TranslationInspectionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `translation-inspection`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateTranslationInspectionRequest_data|true|| |▹ relationships|CreateGeometrySetRequest_data_relationships|true|| |▹▹ source|FileRelationship|true|Relationship to a `file`.| |▹▹▹ data|FileRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(file)|true|Resource object type.| |▹ type|string|true|Resource object type.|
     * @param {CreateTranslationInspectionRequest} createTranslationInspectionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTranslationInspection(
      createTranslationInspectionRequest: CreateTranslationInspectionRequest,
      options?: any
    ): AxiosPromise<TranslationInspectionJob> {
      return TranslationInspectionsApiFp(configuration)
        .createTranslationInspection(
          createTranslationInspectionRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `translation-inspection` by ID.
     * @param {string} id The &#x60;translation-inspection&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInspectionJob(
      id: string,
      options?: any
    ): AxiosPromise<TranslationInspectionJob> {
      return TranslationInspectionsApiFp(configuration)
        .getInspectionJob(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `queued-translation`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `part-revision`. Once created, create scenes via the createScene API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.
     * @param {string} id The &#x60;queued-translation&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedTranslation(id: string, options?: any): AxiosPromise<QueuedJob> {
      return TranslationInspectionsApiFp(configuration)
        .getQueuedTranslation(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TranslationInspectionsApi - object-oriented interface
 * @export
 * @class TranslationInspectionsApi
 * @extends {BaseAPI}
 */
export class TranslationInspectionsApi extends BaseAPI {
  /**
   *  Create a `translation-inspection`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateTranslationInspectionRequest_data|true|| |▹ relationships|CreateGeometrySetRequest_data_relationships|true|| |▹▹ source|FileRelationship|true|Relationship to a `file`.| |▹▹▹ data|FileRelationship_data|true|| |▹▹▹▹ id|string(uuid)|true|ID of the resource.| |▹▹▹▹ type|enum(file)|true|Resource object type.| |▹ type|string|true|Resource object type.|
   * @param {CreateTranslationInspectionRequest} createTranslationInspectionRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranslationInspectionsApi
   */
  public createTranslationInspection(
    createTranslationInspectionRequest: CreateTranslationInspectionRequest,
    options?: any
  ) {
    return TranslationInspectionsApiFp(this.configuration)
      .createTranslationInspection(createTranslationInspectionRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `translation-inspection` by ID.
   * @param {string} id The &#x60;translation-inspection&#x60; ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranslationInspectionsApi
   */
  public getInspectionJob(id: string, options?: any) {
    return TranslationInspectionsApiFp(this.configuration)
      .getInspectionJob(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `queued-translation`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `part-revision`. Once created, create scenes via the createScene API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.
   * @param {string} id The &#x60;queued-translation&#x60; ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranslationInspectionsApi
   */
  public getQueuedTranslation(id: string, options?: any) {
    return TranslationInspectionsApiFp(this.configuration)
      .getQueuedTranslation(id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
