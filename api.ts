/* tslint:disable */
/* eslint-disable */
/**
 * Vertex Platform API
 * The Vertex distributed cloud rendering platform includes a set of APIs and SDKs, which together allow easily integrating 3D product data into your business application.  See our [Developer Portal Guides](https://developer.vertexvis.com/docs/guides/getting-started/) to get started.  Note that we use auto-generated UUIDs in example requests that may share the same value. This is for ease of documentation only. In actual requests and responses, they should uniquely identify their corresponding resource.
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Camera placement in 3D space.
 * @export
 * @interface Camera
 */
export interface Camera {
  /**
   *
   * @type {Vector3}
   * @memberof Camera
   */
  lookAt: Vector3;
  /**
   *
   * @type {Vector3}
   * @memberof Camera
   */
  position: Vector3;
  /**
   *
   * @type {Vector3}
   * @memberof Camera
   */
  up: Vector3;
}
/**
 * Fit camera in 3D space based on items in scene.
 * @export
 * @interface CameraFit
 */
export interface CameraFit {
  /**
   * Resource object type.
   * @type {string}
   * @memberof CameraFit
   */
  type: CameraFitTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum CameraFitTypeEnum {
  FitVisibleSceneItems = 'fit-visible-scene-items',
}

/**
 *
 * @export
 * @interface ChangeMaterialOperation
 */
export interface ChangeMaterialOperation {
  /**
   *
   * @type {ColorMaterial}
   * @memberof ChangeMaterialOperation
   */
  material: ColorMaterial;
  /**
   * Resource object type.
   * @type {string}
   * @memberof ChangeMaterialOperation
   */
  type: ChangeMaterialOperationTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum ChangeMaterialOperationTypeEnum {
  ChangeMaterial = 'change-material',
}

/**
 *
 * @export
 * @interface ChangeTransformOperation
 */
export interface ChangeTransformOperation {
  /**
   *
   * @type {Matrix4}
   * @memberof ChangeTransformOperation
   */
  transform: Matrix4;
  /**
   * Resource object type.
   * @type {string}
   * @memberof ChangeTransformOperation
   */
  type: ChangeTransformOperationTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum ChangeTransformOperationTypeEnum {
  ChangeTransform = 'change-transform',
}

/**
 *
 * @export
 * @interface ChangeVisibilityOperation
 */
export interface ChangeVisibilityOperation {
  /**
   * Resource object type.
   * @type {string}
   * @memberof ChangeVisibilityOperation
   */
  type: ChangeVisibilityOperationTypeEnum;
  /**
   * Item visibility.
   * @type {boolean}
   * @memberof ChangeVisibilityOperation
   */
  visible: boolean;
}

/**
 * @export
 * @enum {string}
 */
export enum ChangeVisibilityOperationTypeEnum {
  ChangeVisibility = 'change-visibility',
}

/**
 *
 * @export
 * @interface ClearMaterialOperation
 */
export interface ClearMaterialOperation {
  /**
   * Resource object type.
   * @type {string}
   * @memberof ClearMaterialOperation
   */
  type: ClearMaterialOperationTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum ClearMaterialOperationTypeEnum {
  ClearMaterial = 'clear-material',
}

/**
 *
 * @export
 * @interface ClearTransformOperation
 */
export interface ClearTransformOperation {
  /**
   * Resource object type.
   * @type {string}
   * @memberof ClearTransformOperation
   */
  type: ClearTransformOperationTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum ClearTransformOperationTypeEnum {
  ClearTransform = 'clear-transform',
}

/**
 * RGB color.
 * @export
 * @interface Color3
 */
export interface Color3 {
  /**
   * Color value from 0 to 255.
   * @type {number}
   * @memberof Color3
   */
  b: number;
  /**
   * Color value from 0 to 255.
   * @type {number}
   * @memberof Color3
   */
  g: number;
  /**
   * Color value from 0 to 255.
   * @type {number}
   * @memberof Color3
   */
  r: number;
}
/**
 * Color properties describing how a material looks.
 * @export
 * @interface ColorMaterial
 */
export interface ColorMaterial {
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterial
   */
  ambient: Color3;
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterial
   */
  diffuse: Color3;
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterial
   */
  emissive: Color3;
  /**
   * Glossiness from 0 to 128.
   * @type {number}
   * @memberof ColorMaterial
   */
  glossiness: number;
  /**
   * Opacity from 0 to 100.
   * @type {number}
   * @memberof ColorMaterial
   */
  opacity: number;
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterial
   */
  specular: Color3;
}
/**
 * Color properties describing how a material looks.
 * @export
 * @interface ColorMaterialNullable
 */
export interface ColorMaterialNullable {
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterialNullable
   */
  ambient: Color3;
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterialNullable
   */
  diffuse: Color3;
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterialNullable
   */
  emissive: Color3;
  /**
   * Glossiness from 0 to 128.
   * @type {number}
   * @memberof ColorMaterialNullable
   */
  glossiness: number;
  /**
   * Opacity from 0 to 100.
   * @type {number}
   * @memberof ColorMaterialNullable
   */
  opacity: number;
  /**
   *
   * @type {Color3}
   * @memberof ColorMaterialNullable
   */
  specular: Color3;
}
/**
 *
 * @export
 * @interface CreateFileRequest
 */
export interface CreateFileRequest {
  /**
   *
   * @type {CreateFileRequestData}
   * @memberof CreateFileRequest
   */
  data: CreateFileRequestData;
}
/**
 *
 * @export
 * @interface CreateFileRequestData
 */
export interface CreateFileRequestData {
  /**
   *
   * @type {CreateFileRequestDataAttributes}
   * @memberof CreateFileRequestData
   */
  attributes: CreateFileRequestDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateFileRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreateFileRequestDataAttributes
 */
export interface CreateFileRequestDataAttributes {
  /**
   * Name matching that of the file you are uploading, including file extension.
   * @type {string}
   * @memberof CreateFileRequestDataAttributes
   */
  name: string;
  /**
   * File name of the root part or assembly, including file extension. Required if `name` references an archive file extension, ignored otherwise.
   * @type {string}
   * @memberof CreateFileRequestDataAttributes
   */
  rootFileName?: string;
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof CreateFileRequestDataAttributes
   */
  suppliedId?: string;
}
/**
 *
 * @export
 * @interface CreateGeometrySetRequest
 */
export interface CreateGeometrySetRequest {
  /**
   *
   * @type {CreateGeometrySetRequestData}
   * @memberof CreateGeometrySetRequest
   */
  data: CreateGeometrySetRequestData;
}
/**
 *
 * @export
 * @interface CreateGeometrySetRequestData
 */
export interface CreateGeometrySetRequestData {
  /**
   *
   * @type {CreateGeometrySetRequestDataRelationships}
   * @memberof CreateGeometrySetRequestData
   */
  relationships: CreateGeometrySetRequestDataRelationships;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateGeometrySetRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreateGeometrySetRequestDataRelationships
 */
export interface CreateGeometrySetRequestDataRelationships {
  /**
   *
   * @type {FileRelationship}
   * @memberof CreateGeometrySetRequestDataRelationships
   */
  source: FileRelationship;
}
/**
 *
 * @export
 * @interface CreateHitRequest
 */
export interface CreateHitRequest {
  /**
   *
   * @type {CreateHitRequestData}
   * @memberof CreateHitRequest
   */
  data: CreateHitRequestData;
}
/**
 *
 * @export
 * @interface CreateHitRequestData
 */
export interface CreateHitRequestData {
  /**
   *
   * @type {CreateHitRequestDataAttributes}
   * @memberof CreateHitRequestData
   */
  attributes: CreateHitRequestDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateHitRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreateHitRequestDataAttributes
 */
export interface CreateHitRequestDataAttributes {
  /**
   *
   * @type {Point}
   * @memberof CreateHitRequestDataAttributes
   */
  point: Point;
  /**
   *
   * @type {Dimensions}
   * @memberof CreateHitRequestDataAttributes
   */
  viewport: Dimensions;
}
/**
 *
 * @export
 * @interface CreatePartRequest
 */
export interface CreatePartRequest {
  /**
   *
   * @type {CreatePartRequestData}
   * @memberof CreatePartRequest
   */
  data: CreatePartRequestData;
}
/**
 *
 * @export
 * @interface CreatePartRequestData
 */
export interface CreatePartRequestData {
  /**
   *
   * @type {CreatePartRequestDataAttributes}
   * @memberof CreatePartRequestData
   */
  attributes: CreatePartRequestDataAttributes;
  /**
   *
   * @type {CreateGeometrySetRequestDataRelationships}
   * @memberof CreatePartRequestData
   */
  relationships: CreateGeometrySetRequestDataRelationships;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreatePartRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreatePartRequestDataAttributes
 */
export interface CreatePartRequestDataAttributes {
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof CreatePartRequestDataAttributes
   */
  suppliedId: string;
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof CreatePartRequestDataAttributes
   */
  suppliedRevisionId: string;
}
/**
 *
 * @export
 * @interface CreateSceneAlterationRequest
 */
export interface CreateSceneAlterationRequest {
  /**
   *
   * @type {CreateSceneAlterationRequestData}
   * @memberof CreateSceneAlterationRequest
   */
  data: CreateSceneAlterationRequestData;
}
/**
 *
 * @export
 * @interface CreateSceneAlterationRequestData
 */
export interface CreateSceneAlterationRequestData {
  /**
   *
   * @type {CreateSceneAlterationRequestDataAttributes}
   * @memberof CreateSceneAlterationRequestData
   */
  attributes: CreateSceneAlterationRequestDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSceneAlterationRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreateSceneAlterationRequestDataAttributes
 */
export interface CreateSceneAlterationRequestDataAttributes {
  /**
   * List of alterations to apply.
   * @type {Array<SceneOperation>}
   * @memberof CreateSceneAlterationRequestDataAttributes
   */
  alterations: Array<SceneOperation>;
}
/**
 *
 * @export
 * @interface CreateSceneItemOverrideRequest
 */
export interface CreateSceneItemOverrideRequest {
  /**
   *
   * @type {CreateSceneItemOverrideRequestData}
   * @memberof CreateSceneItemOverrideRequest
   */
  data: CreateSceneItemOverrideRequestData;
}
/**
 *
 * @export
 * @interface CreateSceneItemOverrideRequestData
 */
export interface CreateSceneItemOverrideRequestData {
  /**
   *
   * @type {CreateSceneItemOverrideRequestDataAttributes}
   * @memberof CreateSceneItemOverrideRequestData
   */
  attributes: CreateSceneItemOverrideRequestDataAttributes;
  /**
   *
   * @type {CreateSceneItemOverrideRequestDataRelationships}
   * @memberof CreateSceneItemOverrideRequestData
   */
  relationships: CreateSceneItemOverrideRequestDataRelationships;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSceneItemOverrideRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreateSceneItemOverrideRequestDataAttributes
 */
export interface CreateSceneItemOverrideRequestDataAttributes {
  /**
   *
   * @type {ColorMaterial}
   * @memberof CreateSceneItemOverrideRequestDataAttributes
   */
  material?: ColorMaterial;
  /**
   *
   * @type {Matrix4}
   * @memberof CreateSceneItemOverrideRequestDataAttributes
   */
  transform?: Matrix4;
  /**
   * Item visibility.
   * @type {boolean}
   * @memberof CreateSceneItemOverrideRequestDataAttributes
   */
  visible?: boolean;
}
/**
 *
 * @export
 * @interface CreateSceneItemOverrideRequestDataRelationships
 */
export interface CreateSceneItemOverrideRequestDataRelationships {
  /**
   *
   * @type {SceneItemRelationship}
   * @memberof CreateSceneItemOverrideRequestDataRelationships
   */
  sceneItem: SceneItemRelationship;
}
/**
 *
 * @export
 * @interface CreateSceneItemRequest
 */
export interface CreateSceneItemRequest {
  /**
   *
   * @type {CreateSceneItemRequestData}
   * @memberof CreateSceneItemRequest
   */
  data: CreateSceneItemRequestData;
}
/**
 *
 * @export
 * @interface CreateSceneItemRequestData
 */
export interface CreateSceneItemRequestData {
  /**
   *
   * @type {CreateSceneItemRequestDataAttributes}
   * @memberof CreateSceneItemRequestData
   */
  attributes: CreateSceneItemRequestDataAttributes;
  /**
   *
   * @type {CreateSceneItemRequestDataRelationships}
   * @memberof CreateSceneItemRequestData
   */
  relationships: CreateSceneItemRequestDataRelationships;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSceneItemRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreateSceneItemRequestDataAttributes
 */
export interface CreateSceneItemRequestDataAttributes {
  /**
   *
   * @type {ColorMaterial}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  materialOverride?: ColorMaterial;
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  parent?: string;
  /**
   *
   * @type {PartRevisionSuppliedId}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  source?: PartRevisionSuppliedId;
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  suppliedId?: string;
  /**
   *
   * @type {Matrix4}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  transform?: Matrix4;
  /**
   * Item visibility.
   * @type {boolean}
   * @memberof CreateSceneItemRequestDataAttributes
   */
  visible?: boolean;
}
/**
 *
 * @export
 * @interface CreateSceneItemRequestDataRelationships
 */
export interface CreateSceneItemRequestDataRelationships {
  /**
   *
   * @type {SceneItemRelationship}
   * @memberof CreateSceneItemRequestDataRelationships
   */
  parent?: SceneItemRelationship;
  /**
   * Relationship to a `geometry-set` or `part-revision`.
   * @type {GeometrySetRelationship | PartRevisionRelationship}
   * @memberof CreateSceneItemRequestDataRelationships
   */
  source?: GeometrySetRelationship | PartRevisionRelationship;
}
/**
 *
 * @export
 * @interface CreateSceneRequest
 */
export interface CreateSceneRequest {
  /**
   *
   * @type {CreateSceneRequestData}
   * @memberof CreateSceneRequest
   */
  data: CreateSceneRequestData;
}
/**
 *
 * @export
 * @interface CreateSceneRequestData
 */
export interface CreateSceneRequestData {
  /**
   *
   * @type {CreateSceneViewRequestDataAttributes}
   * @memberof CreateSceneRequestData
   */
  attributes: CreateSceneViewRequestDataAttributes;
  /**
   *
   * @type {CreateSceneRequestDataRelationships}
   * @memberof CreateSceneRequestData
   */
  relationships?: CreateSceneRequestDataRelationships;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSceneRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreateSceneRequestDataRelationships
 */
export interface CreateSceneRequestDataRelationships {
  /**
   *
   * @type {SceneTemplateRelationship}
   * @memberof CreateSceneRequestDataRelationships
   */
  source: SceneTemplateRelationship;
}
/**
 *
 * @export
 * @interface CreateSceneTemplateRequest
 */
export interface CreateSceneTemplateRequest {
  /**
   *
   * @type {CreateSceneTemplateRequestData}
   * @memberof CreateSceneTemplateRequest
   */
  data: CreateSceneTemplateRequestData;
}
/**
 *
 * @export
 * @interface CreateSceneTemplateRequestData
 */
export interface CreateSceneTemplateRequestData {
  /**
   *
   * @type {CreateSceneTemplateRequestDataAttributes}
   * @memberof CreateSceneTemplateRequestData
   */
  attributes: CreateSceneTemplateRequestDataAttributes;
  /**
   *
   * @type {CreateGeometrySetRequestDataRelationships}
   * @memberof CreateSceneTemplateRequestData
   */
  relationships: CreateGeometrySetRequestDataRelationships;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSceneTemplateRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreateSceneTemplateRequestDataAttributes
 */
export interface CreateSceneTemplateRequestDataAttributes {
  /**
   * Name of the scene template.
   * @type {string}
   * @memberof CreateSceneTemplateRequestDataAttributes
   */
  name?: string;
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof CreateSceneTemplateRequestDataAttributes
   */
  suppliedId: string;
}
/**
 *
 * @export
 * @interface CreateSceneViewRequest
 */
export interface CreateSceneViewRequest {
  /**
   *
   * @type {CreateSceneViewRequestData}
   * @memberof CreateSceneViewRequest
   */
  data: CreateSceneViewRequestData;
}
/**
 *
 * @export
 * @interface CreateSceneViewRequestData
 */
export interface CreateSceneViewRequestData {
  /**
   *
   * @type {CreateSceneViewRequestDataAttributes}
   * @memberof CreateSceneViewRequestData
   */
  attributes: CreateSceneViewRequestDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateSceneViewRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreateSceneViewRequestDataAttributes
 */
export interface CreateSceneViewRequestDataAttributes {
  /**
   *
   * @type {Camera}
   * @memberof CreateSceneViewRequestDataAttributes
   */
  camera?: Camera;
}
/**
 *
 * @export
 * @interface CreateStreamKeyRequest
 */
export interface CreateStreamKeyRequest {
  /**
   *
   * @type {CreateStreamKeyRequestData}
   * @memberof CreateStreamKeyRequest
   */
  data: CreateStreamKeyRequestData;
}
/**
 *
 * @export
 * @interface CreateStreamKeyRequestData
 */
export interface CreateStreamKeyRequestData {
  /**
   *
   * @type {CreateStreamKeyRequestDataAttributes}
   * @memberof CreateStreamKeyRequestData
   */
  attributes: CreateStreamKeyRequestDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateStreamKeyRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface CreateStreamKeyRequestDataAttributes
 */
export interface CreateStreamKeyRequestDataAttributes {
  /**
   * Number of seconds before the `stream-key` expires.
   * @type {number}
   * @memberof CreateStreamKeyRequestDataAttributes
   */
  expiry?: number;
}
/**
 *
 * @export
 * @interface CreateTokenRequest
 */
export interface CreateTokenRequest {
  /**
   *
   * @type {string}
   * @memberof CreateTokenRequest
   */
  grant_type: string;
  /**
   *
   * @type {string}
   * @memberof CreateTokenRequest
   */
  scope?: string;
}
/**
 *
 * @export
 * @interface CreateTranslationInspectionRequest
 */
export interface CreateTranslationInspectionRequest {
  /**
   *
   * @type {CreateTranslationInspectionRequestData}
   * @memberof CreateTranslationInspectionRequest
   */
  data: CreateTranslationInspectionRequestData;
}
/**
 *
 * @export
 * @interface CreateTranslationInspectionRequestData
 */
export interface CreateTranslationInspectionRequestData {
  /**
   *
   * @type {CreateGeometrySetRequestDataRelationships}
   * @memberof CreateTranslationInspectionRequestData
   */
  relationships: CreateGeometrySetRequestDataRelationships;
  /**
   * Resource object type.
   * @type {string}
   * @memberof CreateTranslationInspectionRequestData
   */
  type: string;
}
/**
 * An item\'s height and width.
 * @export
 * @interface Dimensions
 */
export interface Dimensions {
  /**
   * Item\'s height.
   * @type {number}
   * @memberof Dimensions
   */
  height: number;
  /**
   * Item\'s width.
   * @type {number}
   * @memberof Dimensions
   */
  width: number;
}
/**
 *
 * @export
 * @interface ErrorSource
 */
export interface ErrorSource {
  /**
   *
   * @type {string}
   * @memberof ErrorSource
   */
  parameter?: string;
  /**
   *
   * @type {string}
   * @memberof ErrorSource
   */
  pointer?: string;
}
/**
 *
 * @export
 * @interface Failure
 */
export interface Failure {
  /**
   *
   * @type {Set<Error>}
   * @memberof Failure
   */
  errors: Set<Error>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof Failure
   */
  links?: { [key: string]: Link };
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof Failure
   */
  meta?: { [key: string]: string };
}
/**
 *
 * @export
 * @interface FileList
 */
export interface FileList {
  /**
   *
   * @type {Array<FileMetadataData>}
   * @memberof FileList
   */
  data: Array<FileMetadataData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof FileList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface FileMetadata
 */
export interface FileMetadata {
  /**
   *
   * @type {FileMetadataData}
   * @memberof FileMetadata
   */
  data: FileMetadataData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof FileMetadata
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface FileMetadataData
 */
export interface FileMetadataData {
  /**
   *
   * @type {FileMetadataDataAttributes}
   * @memberof FileMetadataData
   */
  attributes: FileMetadataDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof FileMetadataData
   */
  id: string;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof FileMetadataData
   */
  links?: { [key: string]: Link };
  /**
   *
   * @type {string}
   * @memberof FileMetadataData
   */
  type: string;
}
/**
 *
 * @export
 * @interface FileMetadataDataAttributes
 */
export interface FileMetadataDataAttributes {
  /**
   *
   * @type {string}
   * @memberof FileMetadataDataAttributes
   */
  created: string;
  /**
   *
   * @type {string}
   * @memberof FileMetadataDataAttributes
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof FileMetadataDataAttributes
   */
  rootFileName?: string;
  /**
   *
   * @type {string}
   * @memberof FileMetadataDataAttributes
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof FileMetadataDataAttributes
   */
  suppliedId?: string;
  /**
   *
   * @type {string}
   * @memberof FileMetadataDataAttributes
   */
  uploaded?: string;
}
/**
 * Relationship to a `file`.
 * @export
 * @interface FileRelationship
 */
export interface FileRelationship {
  /**
   *
   * @type {FileRelationshipData}
   * @memberof FileRelationship
   */
  data: FileRelationshipData;
}
/**
 *
 * @export
 * @interface FileRelationshipData
 */
export interface FileRelationshipData {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof FileRelationshipData
   */
  id: string;
  /**
   * Resource object type.
   * @type {string}
   * @memberof FileRelationshipData
   */
  type: FileRelationshipDataTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum FileRelationshipDataTypeEnum {
  File = 'file',
}

/**
 *
 * @export
 * @interface GeometrySet
 */
export interface GeometrySet {
  /**
   *
   * @type {GeometrySetData}
   * @memberof GeometrySet
   */
  data: GeometrySetData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof GeometrySet
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface GeometrySetData
 */
export interface GeometrySetData {
  /**
   *
   * @type {HitDataAttributes}
   * @memberof GeometrySetData
   */
  attributes: HitDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof GeometrySetData
   */
  id: string;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof GeometrySetData
   */
  links?: { [key: string]: Link };
  /**
   *
   * @type {string}
   * @memberof GeometrySetData
   */
  type: string;
}
/**
 *
 * @export
 * @interface GeometrySetList
 */
export interface GeometrySetList {
  /**
   *
   * @type {Array<GeometrySetData>}
   * @memberof GeometrySetList
   */
  data: Array<GeometrySetData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof GeometrySetList
   */
  links: { [key: string]: Link };
}
/**
 * Relationship to a `geometry-set`.
 * @export
 * @interface GeometrySetRelationship
 */
export interface GeometrySetRelationship {
  /**
   *
   * @type {GeometrySetRelationshipData}
   * @memberof GeometrySetRelationship
   */
  data: GeometrySetRelationshipData;
}
/**
 *
 * @export
 * @interface GeometrySetRelationshipData
 */
export interface GeometrySetRelationshipData {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof GeometrySetRelationshipData
   */
  id: string;
  /**
   * Resource object type.
   * @type {string}
   * @memberof GeometrySetRelationshipData
   */
  type: GeometrySetRelationshipDataTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum GeometrySetRelationshipDataTypeEnum {
  GeometrySet = 'geometry-set',
}

/**
 *
 * @export
 * @interface Hit
 */
export interface Hit {
  /**
   *
   * @type {HitData}
   * @memberof Hit
   */
  data: HitData;
  /**
   *
   * @type {Array<HitResultData | SceneItemData | PartRevisionData>}
   * @memberof Hit
   */
  included: Array<HitResultData | SceneItemData | PartRevisionData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof Hit
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface HitData
 */
export interface HitData {
  /**
   *
   * @type {HitDataAttributes}
   * @memberof HitData
   */
  attributes: HitDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof HitData
   */
  id: string;
  /**
   *
   * @type {HitDataRelationships}
   * @memberof HitData
   */
  relationships: HitDataRelationships;
  /**
   *
   * @type {string}
   * @memberof HitData
   */
  type: string;
}
/**
 *
 * @export
 * @interface HitDataAttributes
 */
export interface HitDataAttributes {
  /**
   *
   * @type {string}
   * @memberof HitDataAttributes
   */
  created: string;
}
/**
 *
 * @export
 * @interface HitDataRelationships
 */
export interface HitDataRelationships {
  /**
   *
   * @type {Array<RelationshipData>}
   * @memberof HitDataRelationships
   */
  results: Array<RelationshipData>;
}
/**
 *
 * @export
 * @interface HitResultData
 */
export interface HitResultData {
  /**
   *
   * @type {HitResultDataAttributes}
   * @memberof HitResultData
   */
  attributes: HitResultDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof HitResultData
   */
  id: string;
  /**
   *
   * @type {HitResultDataRelationships}
   * @memberof HitResultData
   */
  relationships: HitResultDataRelationships;
  /**
   *
   * @type {string}
   * @memberof HitResultData
   */
  type: string;
}
/**
 *
 * @export
 * @interface HitResultDataAttributes
 */
export interface HitResultDataAttributes {
  /**
   *
   * @type {Vector3}
   * @memberof HitResultDataAttributes
   */
  normal: Vector3;
  /**
   *
   * @type {Vector3}
   * @memberof HitResultDataAttributes
   */
  point: Vector3;
}
/**
 *
 * @export
 * @interface HitResultDataRelationships
 */
export interface HitResultDataRelationships {
  /**
   *
   * @type {RelationshipData}
   * @memberof HitResultDataRelationships
   */
  sceneItem: RelationshipData;
}
/**
 *
 * @export
 * @interface Link
 */
export interface Link {
  /**
   *
   * @type {string}
   * @memberof Link
   */
  href: string;
}
/**
 * Color material override.
 * @export
 * @interface MaterialOverride
 */
export interface MaterialOverride {
  /**
   *
   * @type {ColorMaterial}
   * @memberof MaterialOverride
   */
  value?: ColorMaterial;
}
/**
 * 4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.
 * @export
 * @interface Matrix4
 */
export interface Matrix4 {
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4
   */
  r0: Vector4;
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4
   */
  r1: Vector4;
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4
   */
  r2: Vector4;
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4
   */
  r3: Vector4;
}
/**
 * 4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.
 * @export
 * @interface Matrix4Nullable
 */
export interface Matrix4Nullable {
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4Nullable
   */
  r0: Vector4;
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4Nullable
   */
  r1: Vector4;
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4Nullable
   */
  r2: Vector4;
  /**
   *
   * @type {Vector4}
   * @memberof Matrix4Nullable
   */
  r3: Vector4;
}
/**
 *
 * @export
 * @interface MetadataValue
 */
export interface MetadataValue {
  /**
   * Type of metadata value.
   * @type {string}
   * @memberof MetadataValue
   */
  type: MetadataValueTypeEnum;
  /**
   * Metadata value.
   * @type {string}
   * @memberof MetadataValue
   */
  value?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum MetadataValueTypeEnum {
  String = 'string',
  Long = 'long',
  Float = 'float',
  Date = 'date',
  Null = 'null',
}

/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  detail?: string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  id?: string;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof ModelError
   */
  links?: { [key: string]: Link };
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof ModelError
   */
  meta?: { [key: string]: string };
  /**
   *
   * @type {ErrorSource}
   * @memberof ModelError
   */
  source?: ErrorSource;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  title?: string;
}
/**
 *
 * @export
 * @interface OAuth2BadRequest
 */
export interface OAuth2BadRequest {
  /**
   *
   * @type {string}
   * @memberof OAuth2BadRequest
   */
  error: string;
}
/**
 *
 * @export
 * @interface OAuth2Token
 */
export interface OAuth2Token {
  /**
   *
   * @type {string}
   * @memberof OAuth2Token
   */
  access_token: string;
  /**
   *
   * @type {string}
   * @memberof OAuth2Token
   */
  account_id: string;
  /**
   *
   * @type {number}
   * @memberof OAuth2Token
   */
  expires_in: number;
  /**
   *
   * @type {Array<string>}
   * @memberof OAuth2Token
   */
  scopes: Array<string>;
  /**
   *
   * @type {string}
   * @memberof OAuth2Token
   */
  token_type: string;
}
/**
 *
 * @export
 * @interface Part
 */
export interface Part {
  /**
   *
   * @type {PartData}
   * @memberof Part
   */
  data: PartData;
  /**
   *
   * @type {Array<PartRevisionData>}
   * @memberof Part
   */
  included?: Array<PartRevisionData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof Part
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface PartData
 */
export interface PartData {
  /**
   *
   * @type {PartDataAttributes}
   * @memberof PartData
   */
  attributes: PartDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PartData
   */
  id: string;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PartData
   */
  links?: { [key: string]: Link };
  /**
   *
   * @type {PartDataRelationships}
   * @memberof PartData
   */
  relationships?: PartDataRelationships;
  /**
   *
   * @type {string}
   * @memberof PartData
   */
  type: string;
}
/**
 *
 * @export
 * @interface PartDataAttributes
 */
export interface PartDataAttributes {
  /**
   *
   * @type {string}
   * @memberof PartDataAttributes
   */
  created: string;
  /**
   *
   * @type {string}
   * @memberof PartDataAttributes
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof PartDataAttributes
   */
  suppliedId: string;
}
/**
 *
 * @export
 * @interface PartDataRelationships
 */
export interface PartDataRelationships {
  /**
   *
   * @type {Array<PartDataRelationshipsPartRevisions>}
   * @memberof PartDataRelationships
   */
  partRevisions: Array<PartDataRelationshipsPartRevisions>;
}
/**
 *
 * @export
 * @interface PartDataRelationshipsPartRevisions
 */
export interface PartDataRelationshipsPartRevisions {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PartDataRelationshipsPartRevisions
   */
  id: string;
  /**
   * Resource object type.
   * @type {string}
   * @memberof PartDataRelationshipsPartRevisions
   */
  type: PartDataRelationshipsPartRevisionsTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum PartDataRelationshipsPartRevisionsTypeEnum {
  PartRevision = 'part-revision',
}

/**
 *
 * @export
 * @interface PartList
 */
export interface PartList {
  /**
   *
   * @type {Array<PartData>}
   * @memberof PartList
   */
  data: Array<PartData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PartList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface PartRelationshipData
 */
export interface PartRelationshipData {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PartRelationshipData
   */
  id: string;
  /**
   * Resource object type.
   * @type {string}
   * @memberof PartRelationshipData
   */
  type: PartRelationshipDataTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum PartRelationshipDataTypeEnum {
  Part = 'part',
}

/**
 *
 * @export
 * @interface PartRevision
 */
export interface PartRevision {
  /**
   *
   * @type {PartRevisionData}
   * @memberof PartRevision
   */
  data: PartRevisionData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PartRevision
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface PartRevisionData
 */
export interface PartRevisionData {
  /**
   *
   * @type {PartRevisionDataAttributes}
   * @memberof PartRevisionData
   */
  attributes: PartRevisionDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof PartRevisionData
   */
  id: string;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PartRevisionData
   */
  links?: { [key: string]: Link };
  /**
   *
   * @type {PartRevisionDataRelationships}
   * @memberof PartRevisionData
   */
  relationships: PartRevisionDataRelationships;
  /**
   *
   * @type {string}
   * @memberof PartRevisionData
   */
  type: string;
}
/**
 *
 * @export
 * @interface PartRevisionDataAttributes
 */
export interface PartRevisionDataAttributes {
  /**
   *
   * @type {string}
   * @memberof PartRevisionDataAttributes
   */
  created?: string;
  /**
   *
   * @type {{ [key: string]: MetadataValue; }}
   * @memberof PartRevisionDataAttributes
   */
  metadata?: { [key: string]: MetadataValue };
  /**
   *
   * @type {string}
   * @memberof PartRevisionDataAttributes
   */
  suppliedId?: string;
}
/**
 *
 * @export
 * @interface PartRevisionDataRelationships
 */
export interface PartRevisionDataRelationships {
  /**
   *
   * @type {GeometrySetRelationshipData}
   * @memberof PartRevisionDataRelationships
   */
  geometrySet?: GeometrySetRelationshipData;
  /**
   *
   * @type {PartRelationshipData}
   * @memberof PartRevisionDataRelationships
   */
  part?: PartRelationshipData;
}
/**
 *
 * @export
 * @interface PartRevisionList
 */
export interface PartRevisionList {
  /**
   *
   * @type {Array<PartRevisionData>}
   * @memberof PartRevisionList
   */
  data: Array<PartRevisionData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof PartRevisionList
   */
  links: { [key: string]: Link };
}
/**
 * Relationship to a `part-revision`.
 * @export
 * @interface PartRevisionRelationship
 */
export interface PartRevisionRelationship {
  /**
   *
   * @type {PartDataRelationshipsPartRevisions}
   * @memberof PartRevisionRelationship
   */
  data: PartDataRelationshipsPartRevisions;
}
/**
 *
 * @export
 * @interface PartRevisionSuppliedId
 */
export interface PartRevisionSuppliedId {
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof PartRevisionSuppliedId
   */
  suppliedPartId: string;
  /**
   * ID provided for correlation. For example, an existing ID from a PLM system.
   * @type {string}
   * @memberof PartRevisionSuppliedId
   */
  suppliedRevisionId: string;
}
/**
 * 2D point.
 * @export
 * @interface Point
 */
export interface Point {
  /**
   * x-axis coordinate.
   * @type {number}
   * @memberof Point
   */
  dx: number;
  /**
   * y-axis coordinate.
   * @type {number}
   * @memberof Point
   */
  dy: number;
}
/**
 * Resource object type.
 * @export
 * @enum {string}
 */
export enum QueryAll {
  All = 'all',
}

/**
 *
 * @export
 * @interface QueryByCollection
 */
export interface QueryByCollection {
  /**
   *
   * @type {QueryByCollectionData}
   * @memberof QueryByCollection
   */
  data: QueryByCollectionData;
}
/**
 *
 * @export
 * @interface QueryByCollectionData
 */
export interface QueryByCollectionData {
  /**
   *
   * @type {QueryByCollectionDataAttributes}
   * @memberof QueryByCollectionData
   */
  attributes: QueryByCollectionDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof QueryByCollectionData
   */
  type: QueryByCollectionDataTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum QueryByCollectionDataTypeEnum {
  QueryByCollection = 'query-by-collection',
}

/**
 *
 * @export
 * @interface QueryByCollectionDataAttributes
 */
export interface QueryByCollectionDataAttributes {
  /**
   * Resource object type.
   * @type {string}
   * @memberof QueryByCollectionDataAttributes
   */
  type: QueryByCollectionDataAttributesTypeEnum;
  /**
   * Query `scene-items`.
   * @type {Array<QueryById>}
   * @memberof QueryByCollectionDataAttributes
   */
  values: Array<QueryById>;
}

/**
 * @export
 * @enum {string}
 */
export enum QueryByCollectionDataAttributesTypeEnum {
  And = 'and',
  Or = 'or',
}

/**
 *
 * @export
 * @interface QueryById
 */
export interface QueryById {
  /**
   *
   * @type {QueryByIdData}
   * @memberof QueryById
   */
  data: QueryByIdData;
}
/**
 *
 * @export
 * @interface QueryByIdData
 */
export interface QueryByIdData {
  /**
   *
   * @type {QueryByIdDataAttributes}
   * @memberof QueryByIdData
   */
  attributes: QueryByIdDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof QueryByIdData
   */
  type: QueryByIdDataTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum QueryByIdDataTypeEnum {
  QueryById = 'query-by-id',
}

/**
 *
 * @export
 * @interface QueryByIdDataAttributes
 */
export interface QueryByIdDataAttributes {
  /**
   * Resource object type.
   * @type {string}
   * @memberof QueryByIdDataAttributes
   */
  type: QueryByIdDataAttributesTypeEnum;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof QueryByIdDataAttributes
   */
  value: string;
}

/**
 * @export
 * @enum {string}
 */
export enum QueryByIdDataAttributesTypeEnum {
  Id = 'id',
  SuppliedId = 'suppliedId',
}

/**
 *
 * @export
 * @interface QueuedJob
 */
export interface QueuedJob {
  /**
   *
   * @type {QueuedJobData}
   * @memberof QueuedJob
   */
  data: QueuedJobData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof QueuedJob
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface QueuedJobData
 */
export interface QueuedJobData {
  /**
   *
   * @type {QueuedJobDataAttributes}
   * @memberof QueuedJobData
   */
  attributes: QueuedJobDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof QueuedJobData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof QueuedJobData
   */
  type: string;
}
/**
 *
 * @export
 * @interface QueuedJobDataAttributes
 */
export interface QueuedJobDataAttributes {
  /**
   *
   * @type {Set<Error>}
   * @memberof QueuedJobDataAttributes
   */
  errors?: Set<Error>;
  /**
   *
   * @type {string}
   * @memberof QueuedJobDataAttributes
   */
  status: string;
}
/**
 *
 * @export
 * @interface RelationshipData
 */
export interface RelationshipData {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof RelationshipData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof RelationshipData
   */
  type: string;
}
/**
 *
 * @export
 * @interface RevokeOAuth2TokenRequest
 */
export interface RevokeOAuth2TokenRequest {
  /**
   *
   * @type {RevokeOAuth2TokenRequestData}
   * @memberof RevokeOAuth2TokenRequest
   */
  data: RevokeOAuth2TokenRequestData;
}
/**
 *
 * @export
 * @interface RevokeOAuth2TokenRequestData
 */
export interface RevokeOAuth2TokenRequestData {
  /**
   *
   * @type {RevokeOAuth2TokenRequestDataAttributes}
   * @memberof RevokeOAuth2TokenRequestData
   */
  attributes: RevokeOAuth2TokenRequestDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof RevokeOAuth2TokenRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface RevokeOAuth2TokenRequestDataAttributes
 */
export interface RevokeOAuth2TokenRequestDataAttributes {
  /**
   * Token to revoke.
   * @type {string}
   * @memberof RevokeOAuth2TokenRequestDataAttributes
   */
  token: string;
}
/**
 *
 * @export
 * @interface Scene
 */
export interface Scene {
  /**
   *
   * @type {SceneData}
   * @memberof Scene
   */
  data: SceneData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof Scene
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneAlteration
 */
export interface SceneAlteration {
  /**
   *
   * @type {SceneAlterationData}
   * @memberof SceneAlteration
   */
  data: SceneAlterationData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneAlteration
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneAlterationData
 */
export interface SceneAlterationData {
  /**
   *
   * @type {HitDataAttributes}
   * @memberof SceneAlterationData
   */
  attributes: HitDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneAlterationData
   */
  id: string;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneAlterationData
   */
  links?: { [key: string]: Link };
  /**
   *
   * @type {SceneAlterationDataRelationships}
   * @memberof SceneAlterationData
   */
  relationships: SceneAlterationDataRelationships;
  /**
   *
   * @type {string}
   * @memberof SceneAlterationData
   */
  type: string;
}
/**
 *
 * @export
 * @interface SceneAlterationDataRelationships
 */
export interface SceneAlterationDataRelationships {
  /**
   *
   * @type {SceneViewRelationship}
   * @memberof SceneAlterationDataRelationships
   */
  sceneView: SceneViewRelationship;
}
/**
 *
 * @export
 * @interface SceneAlterationList
 */
export interface SceneAlterationList {
  /**
   *
   * @type {Array<SceneAlterationData>}
   * @memberof SceneAlterationList
   */
  data: Array<SceneAlterationData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneAlterationList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneData
 */
export interface SceneData {
  /**
   *
   * @type {SceneDataAttributes}
   * @memberof SceneData
   */
  attributes: SceneDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneData
   */
  id: string;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneData
   */
  links?: { [key: string]: Link };
  /**
   *
   * @type {string}
   * @memberof SceneData
   */
  type: string;
}
/**
 *
 * @export
 * @interface SceneDataAttributes
 */
export interface SceneDataAttributes {
  /**
   *
   * @type {Camera}
   * @memberof SceneDataAttributes
   */
  camera?: Camera;
  /**
   *
   * @type {string}
   * @memberof SceneDataAttributes
   */
  state: string;
}
/**
 *
 * @export
 * @interface SceneItem
 */
export interface SceneItem {
  /**
   *
   * @type {SceneItemData}
   * @memberof SceneItem
   */
  data: SceneItemData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneItem
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneItemData
 */
export interface SceneItemData {
  /**
   *
   * @type {SceneItemDataAttributes}
   * @memberof SceneItemData
   */
  attributes: SceneItemDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneItemData
   */
  id: string;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneItemData
   */
  links?: { [key: string]: Link };
  /**
   *
   * @type {SceneItemDataRelationships}
   * @memberof SceneItemData
   */
  relationships: SceneItemDataRelationships;
  /**
   *
   * @type {string}
   * @memberof SceneItemData
   */
  type: string;
}
/**
 *
 * @export
 * @interface SceneItemDataAttributes
 */
export interface SceneItemDataAttributes {
  /**
   *
   * @type {ColorMaterial}
   * @memberof SceneItemDataAttributes
   */
  materialOverride?: ColorMaterial;
  /**
   *
   * @type {string}
   * @memberof SceneItemDataAttributes
   */
  suppliedId: string;
  /**
   *
   * @type {Matrix4}
   * @memberof SceneItemDataAttributes
   */
  transform: Matrix4;
  /**
   *
   * @type {boolean}
   * @memberof SceneItemDataAttributes
   */
  visible: boolean;
}
/**
 *
 * @export
 * @interface SceneItemDataRelationships
 */
export interface SceneItemDataRelationships {
  /**
   *
   * @type {SceneItemRelationship}
   * @memberof SceneItemDataRelationships
   */
  parent?: SceneItemRelationship;
  /**
   *
   * @type {GeometrySetRelationship | PartRevisionRelationship}
   * @memberof SceneItemDataRelationships
   */
  source?: GeometrySetRelationship | PartRevisionRelationship;
}
/**
 *
 * @export
 * @interface SceneItemList
 */
export interface SceneItemList {
  /**
   *
   * @type {Array<SceneItemData>}
   * @memberof SceneItemList
   */
  data: Array<SceneItemData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneItemList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneItemOverride
 */
export interface SceneItemOverride {
  /**
   *
   * @type {SceneItemOverrideData}
   * @memberof SceneItemOverride
   */
  data: SceneItemOverrideData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneItemOverride
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneItemOverrideData
 */
export interface SceneItemOverrideData {
  /**
   *
   * @type {SceneItemOverrideDataAttributes}
   * @memberof SceneItemOverrideData
   */
  attributes: SceneItemOverrideDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneItemOverrideData
   */
  id: string;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneItemOverrideData
   */
  links?: { [key: string]: Link };
  /**
   *
   * @type {SceneItemOverrideDataRelationships}
   * @memberof SceneItemOverrideData
   */
  relationships: SceneItemOverrideDataRelationships;
  /**
   *
   * @type {string}
   * @memberof SceneItemOverrideData
   */
  type: string;
}
/**
 *
 * @export
 * @interface SceneItemOverrideDataAttributes
 */
export interface SceneItemOverrideDataAttributes {
  /**
   *
   * @type {string}
   * @memberof SceneItemOverrideDataAttributes
   */
  created: string;
  /**
   *
   * @type {ColorMaterial}
   * @memberof SceneItemOverrideDataAttributes
   */
  material?: ColorMaterial;
  /**
   *
   * @type {Matrix4}
   * @memberof SceneItemOverrideDataAttributes
   */
  transform?: Matrix4;
  /**
   *
   * @type {boolean}
   * @memberof SceneItemOverrideDataAttributes
   */
  visible?: boolean;
}
/**
 *
 * @export
 * @interface SceneItemOverrideDataRelationships
 */
export interface SceneItemOverrideDataRelationships {
  /**
   *
   * @type {SceneItemRelationship}
   * @memberof SceneItemOverrideDataRelationships
   */
  sceneItem: SceneItemRelationship;
  /**
   *
   * @type {SceneViewRelationship}
   * @memberof SceneItemOverrideDataRelationships
   */
  sceneView: SceneViewRelationship;
}
/**
 *
 * @export
 * @interface SceneItemOverrideList
 */
export interface SceneItemOverrideList {
  /**
   *
   * @type {Array<SceneItemOverrideData>}
   * @memberof SceneItemOverrideList
   */
  data: Array<SceneItemOverrideData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneItemOverrideList
   */
  links: { [key: string]: Link };
}
/**
 * Relationship to a `scene-item`.
 * @export
 * @interface SceneItemRelationship
 */
export interface SceneItemRelationship {
  /**
   *
   * @type {SceneItemRelationshipData}
   * @memberof SceneItemRelationship
   */
  data: SceneItemRelationshipData;
}
/**
 *
 * @export
 * @interface SceneItemRelationshipData
 */
export interface SceneItemRelationshipData {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneItemRelationshipData
   */
  id: string;
  /**
   * Resource object type.
   * @type {string}
   * @memberof SceneItemRelationshipData
   */
  type: SceneItemRelationshipDataTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum SceneItemRelationshipDataTypeEnum {
  SceneItem = 'scene-item',
}

/**
 *
 * @export
 * @interface SceneList
 */
export interface SceneList {
  /**
   *
   * @type {Array<SceneData>}
   * @memberof SceneList
   */
  data: Array<SceneData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneOperation
 */
export interface SceneOperation {
  /**
   * List of operations to perform on `scene-items` matching the query.
   * @type {Array<ChangeVisibilityOperation | ChangeMaterialOperation | ClearMaterialOperation | ChangeTransformOperation | ClearTransformOperation>}
   * @memberof SceneOperation
   */
  operations: Array<
    | ChangeVisibilityOperation
    | ChangeMaterialOperation
    | ClearMaterialOperation
    | ChangeTransformOperation
    | ClearTransformOperation
  >;
  /**
   * Query `scene-items`. Use `query-by-collection` to combine multiple queries.
   * @type {QueryById | QueryByCollection | QueryAll}
   * @memberof SceneOperation
   */
  query: QueryById | QueryByCollection | QueryAll;
}
/**
 * Relationship to a `scene`.
 * @export
 * @interface SceneRelationship
 */
export interface SceneRelationship {
  /**
   *
   * @type {SceneRelationshipData}
   * @memberof SceneRelationship
   */
  data: SceneRelationshipData;
}
/**
 *
 * @export
 * @interface SceneRelationshipData
 */
export interface SceneRelationshipData {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneRelationshipData
   */
  id: string;
  /**
   * Resource object type.
   * @type {string}
   * @memberof SceneRelationshipData
   */
  type: SceneRelationshipDataTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum SceneRelationshipDataTypeEnum {
  Scene = 'scene',
}

/**
 *
 * @export
 * @interface SceneTemplate
 */
export interface SceneTemplate {
  /**
   *
   * @type {SceneTemplateData}
   * @memberof SceneTemplate
   */
  data: SceneTemplateData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneTemplate
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneTemplateData
 */
export interface SceneTemplateData {
  /**
   *
   * @type {SceneTemplateDataAttributes}
   * @memberof SceneTemplateData
   */
  attributes: SceneTemplateDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneTemplateData
   */
  id: string;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneTemplateData
   */
  links?: { [key: string]: Link };
  /**
   *
   * @type {string}
   * @memberof SceneTemplateData
   */
  type: string;
}
/**
 *
 * @export
 * @interface SceneTemplateDataAttributes
 */
export interface SceneTemplateDataAttributes {
  /**
   *
   * @type {string}
   * @memberof SceneTemplateDataAttributes
   */
  created: string;
  /**
   *
   * @type {string}
   * @memberof SceneTemplateDataAttributes
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof SceneTemplateDataAttributes
   */
  suppliedId: string;
}
/**
 *
 * @export
 * @interface SceneTemplateList
 */
export interface SceneTemplateList {
  /**
   *
   * @type {Array<SceneTemplateData>}
   * @memberof SceneTemplateList
   */
  data: Array<SceneTemplateData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneTemplateList
   */
  links: { [key: string]: Link };
}
/**
 * Relationship to a `scene-template`.
 * @export
 * @interface SceneTemplateRelationship
 */
export interface SceneTemplateRelationship {
  /**
   *
   * @type {SceneTemplateRelationshipData}
   * @memberof SceneTemplateRelationship
   */
  data: SceneTemplateRelationshipData;
}
/**
 *
 * @export
 * @interface SceneTemplateRelationshipData
 */
export interface SceneTemplateRelationshipData {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneTemplateRelationshipData
   */
  id: string;
  /**
   * Resource object type.
   * @type {string}
   * @memberof SceneTemplateRelationshipData
   */
  type: SceneTemplateRelationshipDataTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum SceneTemplateRelationshipDataTypeEnum {
  SceneTemplate = 'scene-template',
}

/**
 *
 * @export
 * @interface SceneView
 */
export interface SceneView {
  /**
   *
   * @type {SceneViewData}
   * @memberof SceneView
   */
  data: SceneViewData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof SceneView
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface SceneViewData
 */
export interface SceneViewData {
  /**
   *
   * @type {SceneViewDataAttributes}
   * @memberof SceneViewData
   */
  attributes: SceneViewDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneViewData
   */
  id: string;
  /**
   *
   * @type {SceneViewDataRelationships}
   * @memberof SceneViewData
   */
  relationships: SceneViewDataRelationships;
  /**
   *
   * @type {string}
   * @memberof SceneViewData
   */
  type: string;
}
/**
 *
 * @export
 * @interface SceneViewDataAttributes
 */
export interface SceneViewDataAttributes {
  /**
   *
   * @type {Camera}
   * @memberof SceneViewDataAttributes
   */
  camera: Camera;
  /**
   *
   * @type {string}
   * @memberof SceneViewDataAttributes
   */
  created: string;
}
/**
 *
 * @export
 * @interface SceneViewDataRelationships
 */
export interface SceneViewDataRelationships {
  /**
   *
   * @type {SceneRelationship}
   * @memberof SceneViewDataRelationships
   */
  scene: SceneRelationship;
}
/**
 * Relationship to a `scene-view`.
 * @export
 * @interface SceneViewRelationship
 */
export interface SceneViewRelationship {
  /**
   *
   * @type {SceneViewRelationshipData}
   * @memberof SceneViewRelationship
   */
  data: SceneViewRelationshipData;
}
/**
 *
 * @export
 * @interface SceneViewRelationshipData
 */
export interface SceneViewRelationshipData {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof SceneViewRelationshipData
   */
  id: string;
  /**
   * Resource object type.
   * @type {string}
   * @memberof SceneViewRelationshipData
   */
  type: SceneViewRelationshipDataTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum SceneViewRelationshipDataTypeEnum {
  SceneView = 'scene-view',
}

/**
 *
 * @export
 * @interface StreamKey
 */
export interface StreamKey {
  /**
   *
   * @type {StreamKeyData}
   * @memberof StreamKey
   */
  data: StreamKeyData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof StreamKey
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface StreamKeyData
 */
export interface StreamKeyData {
  /**
   *
   * @type {StreamKeyDataAttributes}
   * @memberof StreamKeyData
   */
  attributes: StreamKeyDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof StreamKeyData
   */
  id: string;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof StreamKeyData
   */
  links?: { [key: string]: Link };
  /**
   *
   * @type {SceneViewDataRelationships}
   * @memberof StreamKeyData
   */
  relationships: SceneViewDataRelationships;
  /**
   *
   * @type {string}
   * @memberof StreamKeyData
   */
  type: string;
}
/**
 *
 * @export
 * @interface StreamKeyDataAttributes
 */
export interface StreamKeyDataAttributes {
  /**
   *
   * @type {string}
   * @memberof StreamKeyDataAttributes
   */
  created: string;
  /**
   *
   * @type {number}
   * @memberof StreamKeyDataAttributes
   */
  expiry: number;
  /**
   *
   * @type {string}
   * @memberof StreamKeyDataAttributes
   */
  key?: string;
}
/**
 *
 * @export
 * @interface StreamKeyList
 */
export interface StreamKeyList {
  /**
   *
   * @type {Array<StreamKeyData>}
   * @memberof StreamKeyList
   */
  data: Array<StreamKeyData>;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof StreamKeyList
   */
  links: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface TranslationInspectionJob
 */
export interface TranslationInspectionJob {
  /**
   *
   * @type {TranslationInspectionJobData}
   * @memberof TranslationInspectionJob
   */
  data: TranslationInspectionJobData;
  /**
   *
   * @type {{ [key: string]: Link; }}
   * @memberof TranslationInspectionJob
   */
  links?: { [key: string]: Link };
}
/**
 *
 * @export
 * @interface TranslationInspectionJobData
 */
export interface TranslationInspectionJobData {
  /**
   *
   * @type {TranslationInspectionJobDataAttributes}
   * @memberof TranslationInspectionJobData
   */
  attributes: TranslationInspectionJobDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof TranslationInspectionJobData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof TranslationInspectionJobData
   */
  type: string;
}
/**
 *
 * @export
 * @interface TranslationInspectionJobDataAttributes
 */
export interface TranslationInspectionJobDataAttributes {
  /**
   *
   * @type {Array<string>}
   * @memberof TranslationInspectionJobDataAttributes
   */
  missing: Array<string>;
  /**
   *
   * @type {string}
   * @memberof TranslationInspectionJobDataAttributes
   */
  status: string;
}
/**
 *
 * @export
 * @interface UpdatePartRevisionRequest
 */
export interface UpdatePartRevisionRequest {
  /**
   *
   * @type {UpdatePartRevisionRequestData}
   * @memberof UpdatePartRevisionRequest
   */
  data: UpdatePartRevisionRequestData;
}
/**
 *
 * @export
 * @interface UpdatePartRevisionRequestData
 */
export interface UpdatePartRevisionRequestData {
  /**
   *
   * @type {UpdatePartRevisionRequestDataAttributes}
   * @memberof UpdatePartRevisionRequestData
   */
  attributes: UpdatePartRevisionRequestDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof UpdatePartRevisionRequestData
   */
  id: string;
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdatePartRevisionRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface UpdatePartRevisionRequestDataAttributes
 */
export interface UpdatePartRevisionRequestDataAttributes {
  /**
   * Metadata about the `part` and/or `part-revision`.
   * @type {{ [key: string]: MetadataValue; }}
   * @memberof UpdatePartRevisionRequestDataAttributes
   */
  metadata?: { [key: string]: MetadataValue };
}
/**
 *
 * @export
 * @interface UpdateSceneItemOverrideRequest
 */
export interface UpdateSceneItemOverrideRequest {
  /**
   *
   * @type {UpdateSceneItemOverrideRequestData}
   * @memberof UpdateSceneItemOverrideRequest
   */
  data: UpdateSceneItemOverrideRequestData;
}
/**
 *
 * @export
 * @interface UpdateSceneItemOverrideRequestData
 */
export interface UpdateSceneItemOverrideRequestData {
  /**
   *
   * @type {UpdateSceneItemOverrideRequestDataAttributes}
   * @memberof UpdateSceneItemOverrideRequestData
   */
  attributes: UpdateSceneItemOverrideRequestDataAttributes;
  /**
   * ID of the resource.
   * @type {string}
   * @memberof UpdateSceneItemOverrideRequestData
   */
  id: string;
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdateSceneItemOverrideRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface UpdateSceneItemOverrideRequestDataAttributes
 */
export interface UpdateSceneItemOverrideRequestDataAttributes {
  /**
   *
   * @type {ColorMaterialNullable}
   * @memberof UpdateSceneItemOverrideRequestDataAttributes
   */
  material?: ColorMaterialNullable | null;
  /**
   *
   * @type {Matrix4Nullable}
   * @memberof UpdateSceneItemOverrideRequestDataAttributes
   */
  transform?: Matrix4Nullable | null;
  /**
   * Item visibility.
   * @type {boolean}
   * @memberof UpdateSceneItemOverrideRequestDataAttributes
   */
  visible?: boolean | null;
}
/**
 *
 * @export
 * @interface UpdateSceneItemRequest
 */
export interface UpdateSceneItemRequest {
  /**
   *
   * @type {UpdateSceneItemRequestData}
   * @memberof UpdateSceneItemRequest
   */
  data: UpdateSceneItemRequestData;
}
/**
 *
 * @export
 * @interface UpdateSceneItemRequestData
 */
export interface UpdateSceneItemRequestData {
  /**
   *
   * @type {UpdateSceneItemRequestDataAttributes}
   * @memberof UpdateSceneItemRequestData
   */
  attributes: UpdateSceneItemRequestDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdateSceneItemRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface UpdateSceneItemRequestDataAttributes
 */
export interface UpdateSceneItemRequestDataAttributes {
  /**
   *
   * @type {MaterialOverride}
   * @memberof UpdateSceneItemRequestDataAttributes
   */
  materialOverride?: MaterialOverride;
  /**
   *
   * @type {Matrix4}
   * @memberof UpdateSceneItemRequestDataAttributes
   */
  transform?: Matrix4;
  /**
   * Item visibility.
   * @type {boolean}
   * @memberof UpdateSceneItemRequestDataAttributes
   */
  visible?: boolean;
}
/**
 *
 * @export
 * @interface UpdateSceneRequest
 */
export interface UpdateSceneRequest {
  /**
   *
   * @type {UpdateSceneRequestData}
   * @memberof UpdateSceneRequest
   */
  data: UpdateSceneRequestData;
}
/**
 *
 * @export
 * @interface UpdateSceneRequestData
 */
export interface UpdateSceneRequestData {
  /**
   *
   * @type {UpdateSceneRequestDataAttributes}
   * @memberof UpdateSceneRequestData
   */
  attributes: UpdateSceneRequestDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdateSceneRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface UpdateSceneRequestDataAttributes
 */
export interface UpdateSceneRequestDataAttributes {
  /**
   *
   * @type {Camera | CameraFit}
   * @memberof UpdateSceneRequestDataAttributes
   */
  camera?: Camera | CameraFit;
  /**
   * State of the scene.
   * @type {string}
   * @memberof UpdateSceneRequestDataAttributes
   */
  state?: UpdateSceneRequestDataAttributesStateEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum UpdateSceneRequestDataAttributesStateEnum {
  Draft = 'draft',
  Commit = 'commit',
}

/**
 *
 * @export
 * @interface UpdateSceneViewRequest
 */
export interface UpdateSceneViewRequest {
  /**
   *
   * @type {UpdateSceneViewRequestData}
   * @memberof UpdateSceneViewRequest
   */
  data: UpdateSceneViewRequestData;
}
/**
 *
 * @export
 * @interface UpdateSceneViewRequestData
 */
export interface UpdateSceneViewRequestData {
  /**
   *
   * @type {UpdateSceneViewRequestDataAttributes}
   * @memberof UpdateSceneViewRequestData
   */
  attributes: UpdateSceneViewRequestDataAttributes;
  /**
   * Resource object type.
   * @type {string}
   * @memberof UpdateSceneViewRequestData
   */
  type: string;
}
/**
 *
 * @export
 * @interface UpdateSceneViewRequestDataAttributes
 */
export interface UpdateSceneViewRequestDataAttributes {
  /**
   *
   * @type {Camera | CameraFit}
   * @memberof UpdateSceneViewRequestDataAttributes
   */
  camera?: Camera | CameraFit;
}
/**
 * 3D vector.
 * @export
 * @interface Vector3
 */
export interface Vector3 {
  /**
   * x-axis coordinate.
   * @type {number}
   * @memberof Vector3
   */
  x: number;
  /**
   * y-axis coordinate.
   * @type {number}
   * @memberof Vector3
   */
  y: number;
  /**
   * z-axis coordinate.
   * @type {number}
   * @memberof Vector3
   */
  z: number;
}
/**
 * 4D vector.
 * @export
 * @interface Vector4
 */
export interface Vector4 {
  /**
   * w value.
   * @type {number}
   * @memberof Vector4
   */
  w: number;
  /**
   * x-axis coordinate.
   * @type {number}
   * @memberof Vector4
   */
  x: number;
  /**
   * y-axis coordinate.
   * @type {number}
   * @memberof Vector4
   */
  y: number;
  /**
   * z-axis coordinate.
   * @type {number}
   * @memberof Vector4
   */
  z: number;
}

/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `file`. Once created, upload file content via the uploadFile API. For details including supported file formats, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateFileRequest_data|true|| | attributes|CreateFileRequest_data_attributes|true|| | name|string|true|Name matching that of the file you are uploading, including file extension.| | rootFileName|string|false|File name of the root part or assembly, including file extension. Required if `name` references an archive file extension, ignored otherwise.| | suppliedId|string|false|ID provided for correlation. For example, an existing ID from a PLM system.| | type|string|true|Resource object type.|
     * @param {CreateFileRequest} createFileRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFile: async (
      createFileRequest: CreateFileRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createFileRequest' is not null or undefined
      if (createFileRequest === null || createFileRequest === undefined) {
        throw new RequiredError(
          'createFileRequest',
          'Required parameter createFileRequest was null or undefined when calling createFile.'
        );
      }
      const localVarPath = `/files`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof createFileRequest !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type']
            )
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createFileRequest !== undefined ? createFileRequest : {}
          )
        : createFileRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Delete a `file`.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteFile.'
        );
      }
      const localVarPath = `/files/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `file` by ID.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getFile.'
        );
      }
      const localVarPath = `/files/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get `files`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFiles: async (
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/files`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (filterSuppliedId !== undefined) {
        localVarQueryParameter['filter[suppliedId]'] = filterSuppliedId;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Upload a `file`. Once uploaded, create either parts or geometry sets via the createPart or createGeometrySet APIs.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile: async (
      id: string,
      body: any,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling uploadFile.'
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling uploadFile.'
        );
      }
      const localVarPath = `/files/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof body !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type']
            )
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create a `file`. Once created, upload file content via the uploadFile API. For details including supported file formats, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateFileRequest_data|true|| | attributes|CreateFileRequest_data_attributes|true|| | name|string|true|Name matching that of the file you are uploading, including file extension.| | rootFileName|string|false|File name of the root part or assembly, including file extension. Required if `name` references an archive file extension, ignored otherwise.| | suppliedId|string|false|ID provided for correlation. For example, an existing ID from a PLM system.| | type|string|true|Resource object type.|
     * @param {CreateFileRequest} createFileRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFile(
      createFileRequest: CreateFileRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileMetadata>
    > {
      const localVarAxiosArgs = await FilesApiAxiosParamCreator(
        configuration
      ).createFile(createFileRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Delete a `file`.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFile(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileMetadata>
    > {
      const localVarAxiosArgs = await FilesApiAxiosParamCreator(
        configuration
      ).deleteFile(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `file` by ID.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFile(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileMetadata>
    > {
      const localVarAxiosArgs = await FilesApiAxiosParamCreator(
        configuration
      ).getFile(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get `files`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFiles(
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileList>
    > {
      const localVarAxiosArgs = await FilesApiAxiosParamCreator(
        configuration
      ).getFiles(pageCursor, pageSize, filterSuppliedId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Upload a `file`. Once uploaded, create either parts or geometry sets via the createPart or createGeometrySet APIs.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadFile(
      id: string,
      body: any,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await FilesApiAxiosParamCreator(
        configuration
      ).uploadFile(id, body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `file`. Once created, upload file content via the uploadFile API. For details including supported file formats, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateFileRequest_data|true|| | attributes|CreateFileRequest_data_attributes|true|| | name|string|true|Name matching that of the file you are uploading, including file extension.| | rootFileName|string|false|File name of the root part or assembly, including file extension. Required if `name` references an archive file extension, ignored otherwise.| | suppliedId|string|false|ID provided for correlation. For example, an existing ID from a PLM system.| | type|string|true|Resource object type.|
     * @param {CreateFileRequest} createFileRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFile(
      createFileRequest: CreateFileRequest,
      options?: any
    ): AxiosPromise<FileMetadata> {
      return FilesApiFp(configuration)
        .createFile(createFileRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Delete a `file`.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(id: string, options?: any): AxiosPromise<FileMetadata> {
      return FilesApiFp(configuration)
        .deleteFile(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `file` by ID.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile(id: string, options?: any): AxiosPromise<FileMetadata> {
      return FilesApiFp(configuration)
        .getFile(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get `files`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFiles(
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      options?: any
    ): AxiosPromise<FileList> {
      return FilesApiFp(configuration)
        .getFiles(pageCursor, pageSize, filterSuppliedId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Upload a `file`. Once uploaded, create either parts or geometry sets via the createPart or createGeometrySet APIs.
     * @param {string} id The &#x60;file&#x60; ID.
     * @param {any} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile(id: string, body: any, options?: any): AxiosPromise<void> {
      return FilesApiFp(configuration)
        .uploadFile(id, body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createFile operation in FilesApi.
 * @export
 * @interface FilesApiCreateFileRequest
 */
export interface FilesApiCreateFileRequest {
  /**
   *
   * @type {CreateFileRequest}
   * @memberof FilesApiCreateFile
   */
  readonly createFileRequest: CreateFileRequest;
}

/**
 * Request parameters for deleteFile operation in FilesApi.
 * @export
 * @interface FilesApiDeleteFileRequest
 */
export interface FilesApiDeleteFileRequest {
  /**
   * The &#x60;file&#x60; ID.
   * @type {string}
   * @memberof FilesApiDeleteFile
   */
  readonly id: string;
}

/**
 * Request parameters for getFile operation in FilesApi.
 * @export
 * @interface FilesApiGetFileRequest
 */
export interface FilesApiGetFileRequest {
  /**
   * The &#x60;file&#x60; ID.
   * @type {string}
   * @memberof FilesApiGetFile
   */
  readonly id: string;
}

/**
 * Request parameters for getFiles operation in FilesApi.
 * @export
 * @interface FilesApiGetFilesRequest
 */
export interface FilesApiGetFilesRequest {
  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof FilesApiGetFiles
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof FilesApiGetFiles
   */
  readonly pageSize?: number;

  /**
   * Comma-separated list of supplied IDs to filter on.
   * @type {string}
   * @memberof FilesApiGetFiles
   */
  readonly filterSuppliedId?: string;
}

/**
 * Request parameters for uploadFile operation in FilesApi.
 * @export
 * @interface FilesApiUploadFileRequest
 */
export interface FilesApiUploadFileRequest {
  /**
   * The &#x60;file&#x60; ID.
   * @type {string}
   * @memberof FilesApiUploadFile
   */
  readonly id: string;

  /**
   *
   * @type {any}
   * @memberof FilesApiUploadFile
   */
  readonly body: any;
}

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
  /**
   *  Create a `file`. Once created, upload file content via the uploadFile API. For details including supported file formats, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateFileRequest_data|true|| | attributes|CreateFileRequest_data_attributes|true|| | name|string|true|Name matching that of the file you are uploading, including file extension.| | rootFileName|string|false|File name of the root part or assembly, including file extension. Required if `name` references an archive file extension, ignored otherwise.| | suppliedId|string|false|ID provided for correlation. For example, an existing ID from a PLM system.| | type|string|true|Resource object type.|
   * @param {FilesApiCreateFileRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public createFile(
    requestParameters: FilesApiCreateFileRequest,
    options?: any
  ) {
    return FilesApiFp(this.configuration)
      .createFile(requestParameters.createFileRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Delete a `file`.
   * @param {FilesApiDeleteFileRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public deleteFile(
    requestParameters: FilesApiDeleteFileRequest,
    options?: any
  ) {
    return FilesApiFp(this.configuration)
      .deleteFile(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `file` by ID.
   * @param {FilesApiGetFileRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public getFile(requestParameters: FilesApiGetFileRequest, options?: any) {
    return FilesApiFp(this.configuration)
      .getFile(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get `files`.
   * @param {FilesApiGetFilesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public getFiles(
    requestParameters: FilesApiGetFilesRequest = {},
    options?: any
  ) {
    return FilesApiFp(this.configuration)
      .getFiles(
        requestParameters.pageCursor,
        requestParameters.pageSize,
        requestParameters.filterSuppliedId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Upload a `file`. Once uploaded, create either parts or geometry sets via the createPart or createGeometrySet APIs.
   * @param {FilesApiUploadFileRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public uploadFile(
    requestParameters: FilesApiUploadFileRequest,
    options?: any
  ) {
    return FilesApiFp(this.configuration)
      .uploadFile(requestParameters.id, requestParameters.body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * GeometrySetsApi - axios parameter creator
 * @export
 */
export const GeometrySetsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `geometry-set`. Once created, create scenes via the createScene API. For details, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateGeometrySetRequest_data|true|| | relationships|CreateGeometrySetRequest_data_relationships|true|| | source|FileRelationship|true|Relationship to a `file`.| | data|FileRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(file)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {CreateGeometrySetRequest} createGeometrySetRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGeometrySet: async (
      createGeometrySetRequest: CreateGeometrySetRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createGeometrySetRequest' is not null or undefined
      if (
        createGeometrySetRequest === null ||
        createGeometrySetRequest === undefined
      ) {
        throw new RequiredError(
          'createGeometrySetRequest',
          'Required parameter createGeometrySetRequest was null or undefined when calling createGeometrySet.'
        );
      }
      const localVarPath = `/geometry-sets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof createGeometrySetRequest !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type']
            )
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createGeometrySetRequest !== undefined
              ? createGeometrySetRequest
              : {}
          )
        : createGeometrySetRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `geometry-set` by ID.
     * @param {string} id The &#x60;geometry-set&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGeometrySet: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getGeometrySet.'
        );
      }
      const localVarPath = `/geometry-sets/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get `geometry-sets`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGeometrySets: async (
      pageCursor?: string,
      pageSize?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/geometry-sets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GeometrySetsApi - functional programming interface
 * @export
 */
export const GeometrySetsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create a `geometry-set`. Once created, create scenes via the createScene API. For details, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateGeometrySetRequest_data|true|| | relationships|CreateGeometrySetRequest_data_relationships|true|| | source|FileRelationship|true|Relationship to a `file`.| | data|FileRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(file)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {CreateGeometrySetRequest} createGeometrySetRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createGeometrySet(
      createGeometrySetRequest: CreateGeometrySetRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await GeometrySetsApiAxiosParamCreator(
        configuration
      ).createGeometrySet(createGeometrySetRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `geometry-set` by ID.
     * @param {string} id The &#x60;geometry-set&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGeometrySet(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeometrySet>
    > {
      const localVarAxiosArgs = await GeometrySetsApiAxiosParamCreator(
        configuration
      ).getGeometrySet(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get `geometry-sets`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGeometrySets(
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GeometrySetList>
    > {
      const localVarAxiosArgs = await GeometrySetsApiAxiosParamCreator(
        configuration
      ).getGeometrySets(pageCursor, pageSize, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * GeometrySetsApi - factory interface
 * @export
 */
export const GeometrySetsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `geometry-set`. Once created, create scenes via the createScene API. For details, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateGeometrySetRequest_data|true|| | relationships|CreateGeometrySetRequest_data_relationships|true|| | source|FileRelationship|true|Relationship to a `file`.| | data|FileRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(file)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {CreateGeometrySetRequest} createGeometrySetRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGeometrySet(
      createGeometrySetRequest: CreateGeometrySetRequest,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return GeometrySetsApiFp(configuration)
        .createGeometrySet(createGeometrySetRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `geometry-set` by ID.
     * @param {string} id The &#x60;geometry-set&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGeometrySet(id: string, options?: any): AxiosPromise<GeometrySet> {
      return GeometrySetsApiFp(configuration)
        .getGeometrySet(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get `geometry-sets`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGeometrySets(
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<GeometrySetList> {
      return GeometrySetsApiFp(configuration)
        .getGeometrySets(pageCursor, pageSize, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createGeometrySet operation in GeometrySetsApi.
 * @export
 * @interface GeometrySetsApiCreateGeometrySetRequest
 */
export interface GeometrySetsApiCreateGeometrySetRequest {
  /**
   *
   * @type {CreateGeometrySetRequest}
   * @memberof GeometrySetsApiCreateGeometrySet
   */
  readonly createGeometrySetRequest: CreateGeometrySetRequest;
}

/**
 * Request parameters for getGeometrySet operation in GeometrySetsApi.
 * @export
 * @interface GeometrySetsApiGetGeometrySetRequest
 */
export interface GeometrySetsApiGetGeometrySetRequest {
  /**
   * The &#x60;geometry-set&#x60; ID.
   * @type {string}
   * @memberof GeometrySetsApiGetGeometrySet
   */
  readonly id: string;
}

/**
 * Request parameters for getGeometrySets operation in GeometrySetsApi.
 * @export
 * @interface GeometrySetsApiGetGeometrySetsRequest
 */
export interface GeometrySetsApiGetGeometrySetsRequest {
  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof GeometrySetsApiGetGeometrySets
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof GeometrySetsApiGetGeometrySets
   */
  readonly pageSize?: number;
}

/**
 * GeometrySetsApi - object-oriented interface
 * @export
 * @class GeometrySetsApi
 * @extends {BaseAPI}
 */
export class GeometrySetsApi extends BaseAPI {
  /**
   *  Create a `geometry-set`. Once created, create scenes via the createScene API. For details, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateGeometrySetRequest_data|true|| | relationships|CreateGeometrySetRequest_data_relationships|true|| | source|FileRelationship|true|Relationship to a `file`.| | data|FileRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(file)|true|Resource object type.| | type|string|true|Resource object type.|
   * @param {GeometrySetsApiCreateGeometrySetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeometrySetsApi
   */
  public createGeometrySet(
    requestParameters: GeometrySetsApiCreateGeometrySetRequest,
    options?: any
  ) {
    return GeometrySetsApiFp(this.configuration)
      .createGeometrySet(requestParameters.createGeometrySetRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `geometry-set` by ID.
   * @param {GeometrySetsApiGetGeometrySetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeometrySetsApi
   */
  public getGeometrySet(
    requestParameters: GeometrySetsApiGetGeometrySetRequest,
    options?: any
  ) {
    return GeometrySetsApiFp(this.configuration)
      .getGeometrySet(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get `geometry-sets`.
   * @param {GeometrySetsApiGetGeometrySetsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeometrySetsApi
   */
  public getGeometrySets(
    requestParameters: GeometrySetsApiGetGeometrySetsRequest = {},
    options?: any
  ) {
    return GeometrySetsApiFp(this.configuration)
      .getGeometrySets(
        requestParameters.pageCursor,
        requestParameters.pageSize,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HitsApi - axios parameter creator
 * @export
 */
export const HitsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `hit` for a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateHitRequest_data|true|| | attributes|CreateHitRequest_data_attributes|true|| | point|Point|true|2D point.| | dx|integer(int32)|true|x-axis coordinate.| | dy|integer(int32)|true|y-axis coordinate.| | viewport|Dimensions|true|An item\'s height and width.| | height|integer(int32)|true|Item\'s height.| | width|integer(int32)|true|Item\'s width.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateHitRequest} createHitRequest
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {string} [fieldsPartRevision] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneHit: async (
      id: string,
      createHitRequest: CreateHitRequest,
      include?: string,
      fieldsPartRevision?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling createSceneHit.'
        );
      }
      // verify required parameter 'createHitRequest' is not null or undefined
      if (createHitRequest === null || createHitRequest === undefined) {
        throw new RequiredError(
          'createHitRequest',
          'Required parameter createHitRequest was null or undefined when calling createSceneHit.'
        );
      }
      const localVarPath = `/scenes/{id}/hits`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (include !== undefined) {
        localVarQueryParameter['include'] = include;
      }

      if (fieldsPartRevision !== undefined) {
        localVarQueryParameter['fields[part-revision]'] = fieldsPartRevision;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof createHitRequest !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type']
            )
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(createHitRequest !== undefined ? createHitRequest : {})
        : createHitRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Create a `hit` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateHitRequest_data|true|| | attributes|CreateHitRequest_data_attributes|true|| | point|Point|true|2D point.| | dx|integer(int32)|true|x-axis coordinate.| | dy|integer(int32)|true|y-axis coordinate.| | viewport|Dimensions|true|An item\'s height and width.| | height|integer(int32)|true|Item\'s height.| | width|integer(int32)|true|Item\'s width.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateHitRequest} createHitRequest
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {string} [fieldsPartRevision] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneViewHit: async (
      id: string,
      createHitRequest: CreateHitRequest,
      include?: string,
      fieldsPartRevision?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling createSceneViewHit.'
        );
      }
      // verify required parameter 'createHitRequest' is not null or undefined
      if (createHitRequest === null || createHitRequest === undefined) {
        throw new RequiredError(
          'createHitRequest',
          'Required parameter createHitRequest was null or undefined when calling createSceneViewHit.'
        );
      }
      const localVarPath = `/scene-views/{id}/hits`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (include !== undefined) {
        localVarQueryParameter['include'] = include;
      }

      if (fieldsPartRevision !== undefined) {
        localVarQueryParameter['fields[part-revision]'] = fieldsPartRevision;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof createHitRequest !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type']
            )
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(createHitRequest !== undefined ? createHitRequest : {})
        : createHitRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HitsApi - functional programming interface
 * @export
 */
export const HitsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create a `hit` for a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateHitRequest_data|true|| | attributes|CreateHitRequest_data_attributes|true|| | point|Point|true|2D point.| | dx|integer(int32)|true|x-axis coordinate.| | dy|integer(int32)|true|y-axis coordinate.| | viewport|Dimensions|true|An item\'s height and width.| | height|integer(int32)|true|Item\'s height.| | width|integer(int32)|true|Item\'s width.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateHitRequest} createHitRequest
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {string} [fieldsPartRevision] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneHit(
      id: string,
      createHitRequest: CreateHitRequest,
      include?: string,
      fieldsPartRevision?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hit>
    > {
      const localVarAxiosArgs = await HitsApiAxiosParamCreator(
        configuration
      ).createSceneHit(
        id,
        createHitRequest,
        include,
        fieldsPartRevision,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Create a `hit` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateHitRequest_data|true|| | attributes|CreateHitRequest_data_attributes|true|| | point|Point|true|2D point.| | dx|integer(int32)|true|x-axis coordinate.| | dy|integer(int32)|true|y-axis coordinate.| | viewport|Dimensions|true|An item\'s height and width.| | height|integer(int32)|true|Item\'s height.| | width|integer(int32)|true|Item\'s width.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateHitRequest} createHitRequest
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {string} [fieldsPartRevision] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneViewHit(
      id: string,
      createHitRequest: CreateHitRequest,
      include?: string,
      fieldsPartRevision?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hit>
    > {
      const localVarAxiosArgs = await HitsApiAxiosParamCreator(
        configuration
      ).createSceneViewHit(
        id,
        createHitRequest,
        include,
        fieldsPartRevision,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * HitsApi - factory interface
 * @export
 */
export const HitsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `hit` for a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateHitRequest_data|true|| | attributes|CreateHitRequest_data_attributes|true|| | point|Point|true|2D point.| | dx|integer(int32)|true|x-axis coordinate.| | dy|integer(int32)|true|y-axis coordinate.| | viewport|Dimensions|true|An item\'s height and width.| | height|integer(int32)|true|Item\'s height.| | width|integer(int32)|true|Item\'s width.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateHitRequest} createHitRequest
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {string} [fieldsPartRevision] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneHit(
      id: string,
      createHitRequest: CreateHitRequest,
      include?: string,
      fieldsPartRevision?: string,
      options?: any
    ): AxiosPromise<Hit> {
      return HitsApiFp(configuration)
        .createSceneHit(
          id,
          createHitRequest,
          include,
          fieldsPartRevision,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *  Create a `hit` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateHitRequest_data|true|| | attributes|CreateHitRequest_data_attributes|true|| | point|Point|true|2D point.| | dx|integer(int32)|true|x-axis coordinate.| | dy|integer(int32)|true|y-axis coordinate.| | viewport|Dimensions|true|An item\'s height and width.| | height|integer(int32)|true|Item\'s height.| | width|integer(int32)|true|Item\'s width.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateHitRequest} createHitRequest
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {string} [fieldsPartRevision] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneViewHit(
      id: string,
      createHitRequest: CreateHitRequest,
      include?: string,
      fieldsPartRevision?: string,
      options?: any
    ): AxiosPromise<Hit> {
      return HitsApiFp(configuration)
        .createSceneViewHit(
          id,
          createHitRequest,
          include,
          fieldsPartRevision,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createSceneHit operation in HitsApi.
 * @export
 * @interface HitsApiCreateSceneHitRequest
 */
export interface HitsApiCreateSceneHitRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof HitsApiCreateSceneHit
   */
  readonly id: string;

  /**
   *
   * @type {CreateHitRequest}
   * @memberof HitsApiCreateSceneHit
   */
  readonly createHitRequest: CreateHitRequest;

  /**
   * Comma-separated list of relationships to include in response.
   * @type {string}
   * @memberof HitsApiCreateSceneHit
   */
  readonly include?: string;

  /**
   * Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
   * @type {string}
   * @memberof HitsApiCreateSceneHit
   */
  readonly fieldsPartRevision?: string;
}

/**
 * Request parameters for createSceneViewHit operation in HitsApi.
 * @export
 * @interface HitsApiCreateSceneViewHitRequest
 */
export interface HitsApiCreateSceneViewHitRequest {
  /**
   * The &#x60;scene-view&#x60; ID.
   * @type {string}
   * @memberof HitsApiCreateSceneViewHit
   */
  readonly id: string;

  /**
   *
   * @type {CreateHitRequest}
   * @memberof HitsApiCreateSceneViewHit
   */
  readonly createHitRequest: CreateHitRequest;

  /**
   * Comma-separated list of relationships to include in response.
   * @type {string}
   * @memberof HitsApiCreateSceneViewHit
   */
  readonly include?: string;

  /**
   * Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
   * @type {string}
   * @memberof HitsApiCreateSceneViewHit
   */
  readonly fieldsPartRevision?: string;
}

/**
 * HitsApi - object-oriented interface
 * @export
 * @class HitsApi
 * @extends {BaseAPI}
 */
export class HitsApi extends BaseAPI {
  /**
   *  Create a `hit` for a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateHitRequest_data|true|| | attributes|CreateHitRequest_data_attributes|true|| | point|Point|true|2D point.| | dx|integer(int32)|true|x-axis coordinate.| | dy|integer(int32)|true|y-axis coordinate.| | viewport|Dimensions|true|An item\'s height and width.| | height|integer(int32)|true|Item\'s height.| | width|integer(int32)|true|Item\'s width.| | type|string|true|Resource object type.|
   * @param {HitsApiCreateSceneHitRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HitsApi
   */
  public createSceneHit(
    requestParameters: HitsApiCreateSceneHitRequest,
    options?: any
  ) {
    return HitsApiFp(this.configuration)
      .createSceneHit(
        requestParameters.id,
        requestParameters.createHitRequest,
        requestParameters.include,
        requestParameters.fieldsPartRevision,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Create a `hit` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateHitRequest_data|true|| | attributes|CreateHitRequest_data_attributes|true|| | point|Point|true|2D point.| | dx|integer(int32)|true|x-axis coordinate.| | dy|integer(int32)|true|y-axis coordinate.| | viewport|Dimensions|true|An item\'s height and width.| | height|integer(int32)|true|Item\'s height.| | width|integer(int32)|true|Item\'s width.| | type|string|true|Resource object type.|
   * @param {HitsApiCreateSceneViewHitRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HitsApi
   */
  public createSceneViewHit(
    requestParameters: HitsApiCreateSceneViewHitRequest,
    options?: any
  ) {
    return HitsApiFp(this.configuration)
      .createSceneViewHit(
        requestParameters.id,
        requestParameters.createHitRequest,
        requestParameters.include,
        requestParameters.fieldsPartRevision,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * Oauth2Api - axios parameter creator
 * @export
 */
export const Oauth2ApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create an OAuth2 access token. For details, see our [Authentication](https://developer.vertexvis.com/docs/guides/authentication) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |grant_type|string|true|| |scope|string|false||
     * @param {string} grantType
     * @param {string} [scope]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken: async (
      grantType: string,
      scope?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'grantType' is not null or undefined
      if (grantType === null || grantType === undefined) {
        throw new RequiredError(
          'grantType',
          'Required parameter grantType was null or undefined when calling createToken.'
        );
      }
      const localVarPath = `/oauth2/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      // authentication basicAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarRequestOptions['auth'] = {
          username: configuration.username,
          password: configuration.password,
        };
      }

      if (grantType !== undefined) {
        localVarFormParams.set('grant_type', grantType as any);
      }

      if (scope !== undefined) {
        localVarFormParams.set('scope', scope as any);
      }

      localVarHeaderParameter['Content-Type'] =
        'application/x-www-form-urlencoded';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Revoke an OAuth2 access token.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|RevokeOAuth2TokenRequest_data|true|| | attributes|RevokeOAuth2TokenRequest_data_attributes|true|| | token|string|true|Token to revoke.| | type|string|true|Resource object type.|
     * @param {RevokeOAuth2TokenRequest} revokeOAuth2TokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeToken: async (
      revokeOAuth2TokenRequest: RevokeOAuth2TokenRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'revokeOAuth2TokenRequest' is not null or undefined
      if (
        revokeOAuth2TokenRequest === null ||
        revokeOAuth2TokenRequest === undefined
      ) {
        throw new RequiredError(
          'revokeOAuth2TokenRequest',
          'Required parameter revokeOAuth2TokenRequest was null or undefined when calling revokeToken.'
        );
      }
      const localVarPath = `/oauth2/revoke`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      if (configuration && (configuration.username || configuration.password)) {
        localVarRequestOptions['auth'] = {
          username: configuration.username,
          password: configuration.password,
        };
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof revokeOAuth2TokenRequest !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type']
            )
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            revokeOAuth2TokenRequest !== undefined
              ? revokeOAuth2TokenRequest
              : {}
          )
        : revokeOAuth2TokenRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * Oauth2Api - functional programming interface
 * @export
 */
export const Oauth2ApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create an OAuth2 access token. For details, see our [Authentication](https://developer.vertexvis.com/docs/guides/authentication) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |grant_type|string|true|| |scope|string|false||
     * @param {string} grantType
     * @param {string} [scope]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createToken(
      grantType: string,
      scope?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2Token>
    > {
      const localVarAxiosArgs = await Oauth2ApiAxiosParamCreator(
        configuration
      ).createToken(grantType, scope, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Revoke an OAuth2 access token.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|RevokeOAuth2TokenRequest_data|true|| | attributes|RevokeOAuth2TokenRequest_data_attributes|true|| | token|string|true|Token to revoke.| | type|string|true|Resource object type.|
     * @param {RevokeOAuth2TokenRequest} revokeOAuth2TokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async revokeToken(
      revokeOAuth2TokenRequest: RevokeOAuth2TokenRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await Oauth2ApiAxiosParamCreator(
        configuration
      ).revokeToken(revokeOAuth2TokenRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * Oauth2Api - factory interface
 * @export
 */
export const Oauth2ApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create an OAuth2 access token. For details, see our [Authentication](https://developer.vertexvis.com/docs/guides/authentication) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |grant_type|string|true|| |scope|string|false||
     * @param {string} grantType
     * @param {string} [scope]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken(
      grantType: string,
      scope?: string,
      options?: any
    ): AxiosPromise<OAuth2Token> {
      return Oauth2ApiFp(configuration)
        .createToken(grantType, scope, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Revoke an OAuth2 access token.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|RevokeOAuth2TokenRequest_data|true|| | attributes|RevokeOAuth2TokenRequest_data_attributes|true|| | token|string|true|Token to revoke.| | type|string|true|Resource object type.|
     * @param {RevokeOAuth2TokenRequest} revokeOAuth2TokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeToken(
      revokeOAuth2TokenRequest: RevokeOAuth2TokenRequest,
      options?: any
    ): AxiosPromise<void> {
      return Oauth2ApiFp(configuration)
        .revokeToken(revokeOAuth2TokenRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createToken operation in Oauth2Api.
 * @export
 * @interface Oauth2ApiCreateTokenRequest
 */
export interface Oauth2ApiCreateTokenRequest {
  /**
   *
   * @type {string}
   * @memberof Oauth2ApiCreateToken
   */
  readonly grantType: string;

  /**
   *
   * @type {string}
   * @memberof Oauth2ApiCreateToken
   */
  readonly scope?: string;
}

/**
 * Request parameters for revokeToken operation in Oauth2Api.
 * @export
 * @interface Oauth2ApiRevokeTokenRequest
 */
export interface Oauth2ApiRevokeTokenRequest {
  /**
   *
   * @type {RevokeOAuth2TokenRequest}
   * @memberof Oauth2ApiRevokeToken
   */
  readonly revokeOAuth2TokenRequest: RevokeOAuth2TokenRequest;
}

/**
 * Oauth2Api - object-oriented interface
 * @export
 * @class Oauth2Api
 * @extends {BaseAPI}
 */
export class Oauth2Api extends BaseAPI {
  /**
   *  Create an OAuth2 access token. For details, see our [Authentication](https://developer.vertexvis.com/docs/guides/authentication) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |grant_type|string|true|| |scope|string|false||
   * @param {Oauth2ApiCreateTokenRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Oauth2Api
   */
  public createToken(
    requestParameters: Oauth2ApiCreateTokenRequest,
    options?: any
  ) {
    return Oauth2ApiFp(this.configuration)
      .createToken(
        requestParameters.grantType,
        requestParameters.scope,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Revoke an OAuth2 access token.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|RevokeOAuth2TokenRequest_data|true|| | attributes|RevokeOAuth2TokenRequest_data_attributes|true|| | token|string|true|Token to revoke.| | type|string|true|Resource object type.|
   * @param {Oauth2ApiRevokeTokenRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Oauth2Api
   */
  public revokeToken(
    requestParameters: Oauth2ApiRevokeTokenRequest,
    options?: any
  ) {
    return Oauth2ApiFp(this.configuration)
      .revokeToken(requestParameters.revokeOAuth2TokenRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PartRevisionsApi - axios parameter creator
 * @export
 */
export const PartRevisionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Get a `part-revision` by ID.
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {string} [fieldsPartRevision] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartRevision: async (
      id: string,
      fieldsPartRevision?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getPartRevision.'
        );
      }
      const localVarPath = `/part-revisions/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (fieldsPartRevision !== undefined) {
        localVarQueryParameter['fields[part-revision]'] = fieldsPartRevision;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get `part-revisions`.
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartRevisions: async (
      id: string,
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getPartRevisions.'
        );
      }
      const localVarPath = `/parts/{id}/part-revisions`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (filterSuppliedId !== undefined) {
        localVarQueryParameter['filter[suppliedId]'] = filterSuppliedId;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Update a `part-revision`. Note that metadata updates are eventually consistent.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdatePartRevisionRequest_data|true|| | attributes|UpdatePartRevisionRequest_data_attributes|true|| | metadata|object|false|Metadata about the `part` and/or `part-revision`.| | **additionalProperties**|MetadataValue|false|| | type|enum(string, long, float, date, null)|true|Type of metadata value.| | value|string|false|Metadata value.| | id|string(uuid)|true|ID of the resource.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {UpdatePartRevisionRequest} updatePartRevisionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePartRevision: async (
      id: string,
      updatePartRevisionRequest: UpdatePartRevisionRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updatePartRevision.'
        );
      }
      // verify required parameter 'updatePartRevisionRequest' is not null or undefined
      if (
        updatePartRevisionRequest === null ||
        updatePartRevisionRequest === undefined
      ) {
        throw new RequiredError(
          'updatePartRevisionRequest',
          'Required parameter updatePartRevisionRequest was null or undefined when calling updatePartRevision.'
        );
      }
      const localVarPath = `/part-revisions/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof updatePartRevisionRequest !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type']
            )
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            updatePartRevisionRequest !== undefined
              ? updatePartRevisionRequest
              : {}
          )
        : updatePartRevisionRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PartRevisionsApi - functional programming interface
 * @export
 */
export const PartRevisionsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Get a `part-revision` by ID.
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {string} [fieldsPartRevision] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPartRevision(
      id: string,
      fieldsPartRevision?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartRevision>
    > {
      const localVarAxiosArgs = await PartRevisionsApiAxiosParamCreator(
        configuration
      ).getPartRevision(id, fieldsPartRevision, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get `part-revisions`.
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPartRevisions(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PartRevisionList>
    > {
      const localVarAxiosArgs = await PartRevisionsApiAxiosParamCreator(
        configuration
      ).getPartRevisions(id, pageCursor, pageSize, filterSuppliedId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Update a `part-revision`. Note that metadata updates are eventually consistent.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdatePartRevisionRequest_data|true|| | attributes|UpdatePartRevisionRequest_data_attributes|true|| | metadata|object|false|Metadata about the `part` and/or `part-revision`.| | **additionalProperties**|MetadataValue|false|| | type|enum(string, long, float, date, null)|true|Type of metadata value.| | value|string|false|Metadata value.| | id|string(uuid)|true|ID of the resource.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {UpdatePartRevisionRequest} updatePartRevisionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePartRevision(
      id: string,
      updatePartRevisionRequest: UpdatePartRevisionRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartRevision>
    > {
      const localVarAxiosArgs = await PartRevisionsApiAxiosParamCreator(
        configuration
      ).updatePartRevision(id, updatePartRevisionRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * PartRevisionsApi - factory interface
 * @export
 */
export const PartRevisionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Get a `part-revision` by ID.
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {string} [fieldsPartRevision] Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartRevision(
      id: string,
      fieldsPartRevision?: string,
      options?: any
    ): AxiosPromise<PartRevision> {
      return PartRevisionsApiFp(configuration)
        .getPartRevision(id, fieldsPartRevision, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get `part-revisions`.
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPartRevisions(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      options?: any
    ): AxiosPromise<PartRevisionList> {
      return PartRevisionsApiFp(configuration)
        .getPartRevisions(id, pageCursor, pageSize, filterSuppliedId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Update a `part-revision`. Note that metadata updates are eventually consistent.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdatePartRevisionRequest_data|true|| | attributes|UpdatePartRevisionRequest_data_attributes|true|| | metadata|object|false|Metadata about the `part` and/or `part-revision`.| | **additionalProperties**|MetadataValue|false|| | type|enum(string, long, float, date, null)|true|Type of metadata value.| | value|string|false|Metadata value.| | id|string(uuid)|true|ID of the resource.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;part-revision&#x60; ID.
     * @param {UpdatePartRevisionRequest} updatePartRevisionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePartRevision(
      id: string,
      updatePartRevisionRequest: UpdatePartRevisionRequest,
      options?: any
    ): AxiosPromise<PartRevision> {
      return PartRevisionsApiFp(configuration)
        .updatePartRevision(id, updatePartRevisionRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for getPartRevision operation in PartRevisionsApi.
 * @export
 * @interface PartRevisionsApiGetPartRevisionRequest
 */
export interface PartRevisionsApiGetPartRevisionRequest {
  /**
   * The &#x60;part-revision&#x60; ID.
   * @type {string}
   * @memberof PartRevisionsApiGetPartRevision
   */
  readonly id: string;

  /**
   * Comma-separated list of fields to return in response. An empty value returns no fields. Due to its potential size, metadata is only returned if explicitly requested.
   * @type {string}
   * @memberof PartRevisionsApiGetPartRevision
   */
  readonly fieldsPartRevision?: string;
}

/**
 * Request parameters for getPartRevisions operation in PartRevisionsApi.
 * @export
 * @interface PartRevisionsApiGetPartRevisionsRequest
 */
export interface PartRevisionsApiGetPartRevisionsRequest {
  /**
   * The &#x60;part&#x60; ID.
   * @type {string}
   * @memberof PartRevisionsApiGetPartRevisions
   */
  readonly id: string;

  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof PartRevisionsApiGetPartRevisions
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof PartRevisionsApiGetPartRevisions
   */
  readonly pageSize?: number;

  /**
   * Comma-separated list of supplied IDs to filter on.
   * @type {string}
   * @memberof PartRevisionsApiGetPartRevisions
   */
  readonly filterSuppliedId?: string;
}

/**
 * Request parameters for updatePartRevision operation in PartRevisionsApi.
 * @export
 * @interface PartRevisionsApiUpdatePartRevisionRequest
 */
export interface PartRevisionsApiUpdatePartRevisionRequest {
  /**
   * The &#x60;part-revision&#x60; ID.
   * @type {string}
   * @memberof PartRevisionsApiUpdatePartRevision
   */
  readonly id: string;

  /**
   *
   * @type {UpdatePartRevisionRequest}
   * @memberof PartRevisionsApiUpdatePartRevision
   */
  readonly updatePartRevisionRequest: UpdatePartRevisionRequest;
}

/**
 * PartRevisionsApi - object-oriented interface
 * @export
 * @class PartRevisionsApi
 * @extends {BaseAPI}
 */
export class PartRevisionsApi extends BaseAPI {
  /**
   *  Get a `part-revision` by ID.
   * @param {PartRevisionsApiGetPartRevisionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartRevisionsApi
   */
  public getPartRevision(
    requestParameters: PartRevisionsApiGetPartRevisionRequest,
    options?: any
  ) {
    return PartRevisionsApiFp(this.configuration)
      .getPartRevision(
        requestParameters.id,
        requestParameters.fieldsPartRevision,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get `part-revisions`.
   * @param {PartRevisionsApiGetPartRevisionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartRevisionsApi
   */
  public getPartRevisions(
    requestParameters: PartRevisionsApiGetPartRevisionsRequest,
    options?: any
  ) {
    return PartRevisionsApiFp(this.configuration)
      .getPartRevisions(
        requestParameters.id,
        requestParameters.pageCursor,
        requestParameters.pageSize,
        requestParameters.filterSuppliedId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Update a `part-revision`. Note that metadata updates are eventually consistent.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdatePartRevisionRequest_data|true|| | attributes|UpdatePartRevisionRequest_data_attributes|true|| | metadata|object|false|Metadata about the `part` and/or `part-revision`.| | **additionalProperties**|MetadataValue|false|| | type|enum(string, long, float, date, null)|true|Type of metadata value.| | value|string|false|Metadata value.| | id|string(uuid)|true|ID of the resource.| | type|string|true|Resource object type.|
   * @param {PartRevisionsApiUpdatePartRevisionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartRevisionsApi
   */
  public updatePartRevision(
    requestParameters: PartRevisionsApiUpdatePartRevisionRequest,
    options?: any
  ) {
    return PartRevisionsApiFp(this.configuration)
      .updatePartRevision(
        requestParameters.id,
        requestParameters.updatePartRevisionRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PartsApi - axios parameter creator
 * @export
 */
export const PartsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `part`. This API is asynchronous, returning the location of a `queued-translation`. Check the status via the getQueuedTranslation API. For details, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreatePartRequest_data|true|| | attributes|CreatePartRequest_data_attributes|true|| | suppliedId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| | suppliedRevisionId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| | relationships|CreateGeometrySetRequest_data_relationships|true|| | source|FileRelationship|true|Relationship to a `file`.| | data|FileRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(file)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {CreatePartRequest} createPartRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPart: async (
      createPartRequest: CreatePartRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPartRequest' is not null or undefined
      if (createPartRequest === null || createPartRequest === undefined) {
        throw new RequiredError(
          'createPartRequest',
          'Required parameter createPartRequest was null or undefined when calling createPart.'
        );
      }
      const localVarPath = `/parts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof createPartRequest !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type']
            )
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createPartRequest !== undefined ? createPartRequest : {}
          )
        : createPartRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `part` by ID.
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPart: async (
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getPart.'
        );
      }
      const localVarPath = `/parts/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (include !== undefined) {
        localVarQueryParameter['include'] = include;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get `parts`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getParts: async (
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/parts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (filterSuppliedId !== undefined) {
        localVarQueryParameter['filter[suppliedId]'] = filterSuppliedId;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PartsApi - functional programming interface
 * @export
 */
export const PartsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create a `part`. This API is asynchronous, returning the location of a `queued-translation`. Check the status via the getQueuedTranslation API. For details, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreatePartRequest_data|true|| | attributes|CreatePartRequest_data_attributes|true|| | suppliedId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| | suppliedRevisionId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| | relationships|CreateGeometrySetRequest_data_relationships|true|| | source|FileRelationship|true|Relationship to a `file`.| | data|FileRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(file)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {CreatePartRequest} createPartRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPart(
      createPartRequest: CreatePartRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await PartsApiAxiosParamCreator(
        configuration
      ).createPart(createPartRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `part` by ID.
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPart(
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Part>
    > {
      const localVarAxiosArgs = await PartsApiAxiosParamCreator(
        configuration
      ).getPart(id, include, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get `parts`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getParts(
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartList>
    > {
      const localVarAxiosArgs = await PartsApiAxiosParamCreator(
        configuration
      ).getParts(pageCursor, pageSize, filterSuppliedId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * PartsApi - factory interface
 * @export
 */
export const PartsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `part`. This API is asynchronous, returning the location of a `queued-translation`. Check the status via the getQueuedTranslation API. For details, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreatePartRequest_data|true|| | attributes|CreatePartRequest_data_attributes|true|| | suppliedId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| | suppliedRevisionId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| | relationships|CreateGeometrySetRequest_data_relationships|true|| | source|FileRelationship|true|Relationship to a `file`.| | data|FileRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(file)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {CreatePartRequest} createPartRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPart(
      createPartRequest: CreatePartRequest,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return PartsApiFp(configuration)
        .createPart(createPartRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `part` by ID.
     * @param {string} id The &#x60;part&#x60; ID.
     * @param {string} [include] Comma-separated list of relationships to include in response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPart(id: string, include?: string, options?: any): AxiosPromise<Part> {
      return PartsApiFp(configuration)
        .getPart(id, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get `parts`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getParts(
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      options?: any
    ): AxiosPromise<PartList> {
      return PartsApiFp(configuration)
        .getParts(pageCursor, pageSize, filterSuppliedId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createPart operation in PartsApi.
 * @export
 * @interface PartsApiCreatePartRequest
 */
export interface PartsApiCreatePartRequest {
  /**
   *
   * @type {CreatePartRequest}
   * @memberof PartsApiCreatePart
   */
  readonly createPartRequest: CreatePartRequest;
}

/**
 * Request parameters for getPart operation in PartsApi.
 * @export
 * @interface PartsApiGetPartRequest
 */
export interface PartsApiGetPartRequest {
  /**
   * The &#x60;part&#x60; ID.
   * @type {string}
   * @memberof PartsApiGetPart
   */
  readonly id: string;

  /**
   * Comma-separated list of relationships to include in response.
   * @type {string}
   * @memberof PartsApiGetPart
   */
  readonly include?: string;
}

/**
 * Request parameters for getParts operation in PartsApi.
 * @export
 * @interface PartsApiGetPartsRequest
 */
export interface PartsApiGetPartsRequest {
  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof PartsApiGetParts
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof PartsApiGetParts
   */
  readonly pageSize?: number;

  /**
   * Comma-separated list of supplied IDs to filter on.
   * @type {string}
   * @memberof PartsApiGetParts
   */
  readonly filterSuppliedId?: string;
}

/**
 * PartsApi - object-oriented interface
 * @export
 * @class PartsApi
 * @extends {BaseAPI}
 */
export class PartsApi extends BaseAPI {
  /**
   *  Create a `part`. This API is asynchronous, returning the location of a `queued-translation`. Check the status via the getQueuedTranslation API. For details, see our [Importing data](https://developer.vertexvis.com/docs/guides/importing-data) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreatePartRequest_data|true|| | attributes|CreatePartRequest_data_attributes|true|| | suppliedId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| | suppliedRevisionId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| | relationships|CreateGeometrySetRequest_data_relationships|true|| | source|FileRelationship|true|Relationship to a `file`.| | data|FileRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(file)|true|Resource object type.| | type|string|true|Resource object type.|
   * @param {PartsApiCreatePartRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartsApi
   */
  public createPart(
    requestParameters: PartsApiCreatePartRequest,
    options?: any
  ) {
    return PartsApiFp(this.configuration)
      .createPart(requestParameters.createPartRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `part` by ID.
   * @param {PartsApiGetPartRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartsApi
   */
  public getPart(requestParameters: PartsApiGetPartRequest, options?: any) {
    return PartsApiFp(this.configuration)
      .getPart(requestParameters.id, requestParameters.include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get `parts`.
   * @param {PartsApiGetPartsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PartsApi
   */
  public getParts(
    requestParameters: PartsApiGetPartsRequest = {},
    options?: any
  ) {
    return PartsApiFp(this.configuration)
      .getParts(
        requestParameters.pageCursor,
        requestParameters.pageSize,
        requestParameters.filterSuppliedId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SceneAlterationsApi - axios parameter creator
 * @export
 */
export const SceneAlterationsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `scene-alteration` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneAlterationRequest_data|true|| | attributes|CreateSceneAlterationRequest_data_attributes|true|| | alterations|[SceneOperation]|true|List of alterations to apply.| | operations|[anyOf]|true|List of operations to perform on `scene-items` matching the query.| | *anonymous*|ChangeVisibilityOperation|false|| | type|enum(change-visibility)|true|Resource object type.| | visible|boolean|true|Item visibility.| | *anonymous*|ChangeMaterialOperation|false|| | material|ColorMaterial|true|Color properties describing how a material looks.| | ambient|Color3|true|RGB color.| | b|integer(int32)|true|Color value from 0 to 255.| | g|integer(int32)|true|Color value from 0 to 255.| | r|integer(int32)|true|Color value from 0 to 255.| | diffuse|Color3|true|RGB color.| | emissive|Color3|true|RGB color.| | glossiness|integer(int32)|true|Glossiness from 0 to 128.| | opacity|integer(int32)|true|Opacity from 0 to 100.| | specular|Color3|true|RGB color.| | type|enum(change-material)|true|Resource object type.| | *anonymous*|ClearMaterialOperation|false|| | type|enum(clear-material)|true|Resource object type.| | *anonymous*|ChangeTransformOperation|false|| | transform|Matrix4|true|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| | r0|Vector4|true|4D vector.| | w|number|true|w value.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | r1|Vector4|true|4D vector.| | r2|Vector4|true|4D vector.| | r3|Vector4|true|4D vector.| | type|enum(change-transform)|true|Resource object type.| | *anonymous*|ClearTransformOperation|false|| | type|enum(clear-transform)|true|Resource object type.| | query|any|true|Query `scene-items`. Use `query-by-collection` to combine multiple queries.| | *anonymous*|QueryById|false|| | data|QueryById_data|true|| | attributes|QueryById_data_attributes|true|| | type|enum(id, suppliedId)|true|Resource object type.| | value|string|true|ID of the resource.| | type|enum(query-by-id)|true|Resource object type.| | *anonymous*|QueryByCollection|false|| | data|QueryByCollection_data|true|| | attributes|QueryByCollection_data_attributes|true|| | type|enum(and, or)|true|Resource object type.| | values|[QueryById]|true|Query `scene-items`.| | type|enum(query-by-collection)|true|Resource object type.| | *anonymous*|QueryAll|false|Resource object type.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateSceneAlterationRequest} createSceneAlterationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneAlteration: async (
      id: string,
      createSceneAlterationRequest: CreateSceneAlterationRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling createSceneAlteration.'
        );
      }
      // verify required parameter 'createSceneAlterationRequest' is not null or undefined
      if (
        createSceneAlterationRequest === null ||
        createSceneAlterationRequest === undefined
      ) {
        throw new RequiredError(
          'createSceneAlterationRequest',
          'Required parameter createSceneAlterationRequest was null or undefined when calling createSceneAlteration.'
        );
      }
      const localVarPath = `/scene-views/{id}/scene-alterations`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof createSceneAlterationRequest !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type']
            )
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createSceneAlterationRequest !== undefined
              ? createSceneAlterationRequest
              : {}
          )
        : createSceneAlterationRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `queued-scene-alteration` by ID.
     * @param {string} id The &#x60;queued-scene-alteration&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedSceneAlteration: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getQueuedSceneAlteration.'
        );
      }
      const localVarPath = `/queued-scene-alterations/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `scene-alteration` by ID.
     * @param {string} id The &#x60;scene-alteration&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneAlteration: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getSceneAlteration.'
        );
      }
      const localVarPath = `/scene-alterations/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get `scene-alterations`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneAlterations: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getSceneAlterations.'
        );
      }
      const localVarPath = `/scene-views/{id}/scene-alterations`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SceneAlterationsApi - functional programming interface
 * @export
 */
export const SceneAlterationsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create a `scene-alteration` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneAlterationRequest_data|true|| | attributes|CreateSceneAlterationRequest_data_attributes|true|| | alterations|[SceneOperation]|true|List of alterations to apply.| | operations|[anyOf]|true|List of operations to perform on `scene-items` matching the query.| | *anonymous*|ChangeVisibilityOperation|false|| | type|enum(change-visibility)|true|Resource object type.| | visible|boolean|true|Item visibility.| | *anonymous*|ChangeMaterialOperation|false|| | material|ColorMaterial|true|Color properties describing how a material looks.| | ambient|Color3|true|RGB color.| | b|integer(int32)|true|Color value from 0 to 255.| | g|integer(int32)|true|Color value from 0 to 255.| | r|integer(int32)|true|Color value from 0 to 255.| | diffuse|Color3|true|RGB color.| | emissive|Color3|true|RGB color.| | glossiness|integer(int32)|true|Glossiness from 0 to 128.| | opacity|integer(int32)|true|Opacity from 0 to 100.| | specular|Color3|true|RGB color.| | type|enum(change-material)|true|Resource object type.| | *anonymous*|ClearMaterialOperation|false|| | type|enum(clear-material)|true|Resource object type.| | *anonymous*|ChangeTransformOperation|false|| | transform|Matrix4|true|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| | r0|Vector4|true|4D vector.| | w|number|true|w value.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | r1|Vector4|true|4D vector.| | r2|Vector4|true|4D vector.| | r3|Vector4|true|4D vector.| | type|enum(change-transform)|true|Resource object type.| | *anonymous*|ClearTransformOperation|false|| | type|enum(clear-transform)|true|Resource object type.| | query|any|true|Query `scene-items`. Use `query-by-collection` to combine multiple queries.| | *anonymous*|QueryById|false|| | data|QueryById_data|true|| | attributes|QueryById_data_attributes|true|| | type|enum(id, suppliedId)|true|Resource object type.| | value|string|true|ID of the resource.| | type|enum(query-by-id)|true|Resource object type.| | *anonymous*|QueryByCollection|false|| | data|QueryByCollection_data|true|| | attributes|QueryByCollection_data_attributes|true|| | type|enum(and, or)|true|Resource object type.| | values|[QueryById]|true|Query `scene-items`.| | type|enum(query-by-collection)|true|Resource object type.| | *anonymous*|QueryAll|false|Resource object type.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateSceneAlterationRequest} createSceneAlterationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneAlteration(
      id: string,
      createSceneAlterationRequest: CreateSceneAlterationRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await SceneAlterationsApiAxiosParamCreator(
        configuration
      ).createSceneAlteration(id, createSceneAlterationRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `queued-scene-alteration` by ID.
     * @param {string} id The &#x60;queued-scene-alteration&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedSceneAlteration(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await SceneAlterationsApiAxiosParamCreator(
        configuration
      ).getQueuedSceneAlteration(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `scene-alteration` by ID.
     * @param {string} id The &#x60;scene-alteration&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneAlteration(
      id: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneAlteration>
    > {
      const localVarAxiosArgs = await SceneAlterationsApiAxiosParamCreator(
        configuration
      ).getSceneAlteration(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get `scene-alterations`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneAlterations(
      id: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneAlterationList>
    > {
      const localVarAxiosArgs = await SceneAlterationsApiAxiosParamCreator(
        configuration
      ).getSceneAlterations(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * SceneAlterationsApi - factory interface
 * @export
 */
export const SceneAlterationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `scene-alteration` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneAlterationRequest_data|true|| | attributes|CreateSceneAlterationRequest_data_attributes|true|| | alterations|[SceneOperation]|true|List of alterations to apply.| | operations|[anyOf]|true|List of operations to perform on `scene-items` matching the query.| | *anonymous*|ChangeVisibilityOperation|false|| | type|enum(change-visibility)|true|Resource object type.| | visible|boolean|true|Item visibility.| | *anonymous*|ChangeMaterialOperation|false|| | material|ColorMaterial|true|Color properties describing how a material looks.| | ambient|Color3|true|RGB color.| | b|integer(int32)|true|Color value from 0 to 255.| | g|integer(int32)|true|Color value from 0 to 255.| | r|integer(int32)|true|Color value from 0 to 255.| | diffuse|Color3|true|RGB color.| | emissive|Color3|true|RGB color.| | glossiness|integer(int32)|true|Glossiness from 0 to 128.| | opacity|integer(int32)|true|Opacity from 0 to 100.| | specular|Color3|true|RGB color.| | type|enum(change-material)|true|Resource object type.| | *anonymous*|ClearMaterialOperation|false|| | type|enum(clear-material)|true|Resource object type.| | *anonymous*|ChangeTransformOperation|false|| | transform|Matrix4|true|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| | r0|Vector4|true|4D vector.| | w|number|true|w value.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | r1|Vector4|true|4D vector.| | r2|Vector4|true|4D vector.| | r3|Vector4|true|4D vector.| | type|enum(change-transform)|true|Resource object type.| | *anonymous*|ClearTransformOperation|false|| | type|enum(clear-transform)|true|Resource object type.| | query|any|true|Query `scene-items`. Use `query-by-collection` to combine multiple queries.| | *anonymous*|QueryById|false|| | data|QueryById_data|true|| | attributes|QueryById_data_attributes|true|| | type|enum(id, suppliedId)|true|Resource object type.| | value|string|true|ID of the resource.| | type|enum(query-by-id)|true|Resource object type.| | *anonymous*|QueryByCollection|false|| | data|QueryByCollection_data|true|| | attributes|QueryByCollection_data_attributes|true|| | type|enum(and, or)|true|Resource object type.| | values|[QueryById]|true|Query `scene-items`.| | type|enum(query-by-collection)|true|Resource object type.| | *anonymous*|QueryAll|false|Resource object type.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateSceneAlterationRequest} createSceneAlterationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneAlteration(
      id: string,
      createSceneAlterationRequest: CreateSceneAlterationRequest,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return SceneAlterationsApiFp(configuration)
        .createSceneAlteration(id, createSceneAlterationRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `queued-scene-alteration` by ID.
     * @param {string} id The &#x60;queued-scene-alteration&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedSceneAlteration(
      id: string,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return SceneAlterationsApiFp(configuration)
        .getQueuedSceneAlteration(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `scene-alteration` by ID.
     * @param {string} id The &#x60;scene-alteration&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneAlteration(
      id: string,
      options?: any
    ): AxiosPromise<SceneAlteration> {
      return SceneAlterationsApiFp(configuration)
        .getSceneAlteration(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get `scene-alterations`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneAlterations(
      id: string,
      options?: any
    ): AxiosPromise<SceneAlterationList> {
      return SceneAlterationsApiFp(configuration)
        .getSceneAlterations(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createSceneAlteration operation in SceneAlterationsApi.
 * @export
 * @interface SceneAlterationsApiCreateSceneAlterationRequest
 */
export interface SceneAlterationsApiCreateSceneAlterationRequest {
  /**
   * The &#x60;scene-view&#x60; ID.
   * @type {string}
   * @memberof SceneAlterationsApiCreateSceneAlteration
   */
  readonly id: string;

  /**
   *
   * @type {CreateSceneAlterationRequest}
   * @memberof SceneAlterationsApiCreateSceneAlteration
   */
  readonly createSceneAlterationRequest: CreateSceneAlterationRequest;
}

/**
 * Request parameters for getQueuedSceneAlteration operation in SceneAlterationsApi.
 * @export
 * @interface SceneAlterationsApiGetQueuedSceneAlterationRequest
 */
export interface SceneAlterationsApiGetQueuedSceneAlterationRequest {
  /**
   * The &#x60;queued-scene-alteration&#x60; ID.
   * @type {string}
   * @memberof SceneAlterationsApiGetQueuedSceneAlteration
   */
  readonly id: string;
}

/**
 * Request parameters for getSceneAlteration operation in SceneAlterationsApi.
 * @export
 * @interface SceneAlterationsApiGetSceneAlterationRequest
 */
export interface SceneAlterationsApiGetSceneAlterationRequest {
  /**
   * The &#x60;scene-alteration&#x60; ID.
   * @type {string}
   * @memberof SceneAlterationsApiGetSceneAlteration
   */
  readonly id: string;
}

/**
 * Request parameters for getSceneAlterations operation in SceneAlterationsApi.
 * @export
 * @interface SceneAlterationsApiGetSceneAlterationsRequest
 */
export interface SceneAlterationsApiGetSceneAlterationsRequest {
  /**
   * The &#x60;scene-view&#x60; ID.
   * @type {string}
   * @memberof SceneAlterationsApiGetSceneAlterations
   */
  readonly id: string;
}

/**
 * SceneAlterationsApi - object-oriented interface
 * @export
 * @class SceneAlterationsApi
 * @extends {BaseAPI}
 */
export class SceneAlterationsApi extends BaseAPI {
  /**
   *  Create a `scene-alteration` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneAlterationRequest_data|true|| | attributes|CreateSceneAlterationRequest_data_attributes|true|| | alterations|[SceneOperation]|true|List of alterations to apply.| | operations|[anyOf]|true|List of operations to perform on `scene-items` matching the query.| | *anonymous*|ChangeVisibilityOperation|false|| | type|enum(change-visibility)|true|Resource object type.| | visible|boolean|true|Item visibility.| | *anonymous*|ChangeMaterialOperation|false|| | material|ColorMaterial|true|Color properties describing how a material looks.| | ambient|Color3|true|RGB color.| | b|integer(int32)|true|Color value from 0 to 255.| | g|integer(int32)|true|Color value from 0 to 255.| | r|integer(int32)|true|Color value from 0 to 255.| | diffuse|Color3|true|RGB color.| | emissive|Color3|true|RGB color.| | glossiness|integer(int32)|true|Glossiness from 0 to 128.| | opacity|integer(int32)|true|Opacity from 0 to 100.| | specular|Color3|true|RGB color.| | type|enum(change-material)|true|Resource object type.| | *anonymous*|ClearMaterialOperation|false|| | type|enum(clear-material)|true|Resource object type.| | *anonymous*|ChangeTransformOperation|false|| | transform|Matrix4|true|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| | r0|Vector4|true|4D vector.| | w|number|true|w value.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | r1|Vector4|true|4D vector.| | r2|Vector4|true|4D vector.| | r3|Vector4|true|4D vector.| | type|enum(change-transform)|true|Resource object type.| | *anonymous*|ClearTransformOperation|false|| | type|enum(clear-transform)|true|Resource object type.| | query|any|true|Query `scene-items`. Use `query-by-collection` to combine multiple queries.| | *anonymous*|QueryById|false|| | data|QueryById_data|true|| | attributes|QueryById_data_attributes|true|| | type|enum(id, suppliedId)|true|Resource object type.| | value|string|true|ID of the resource.| | type|enum(query-by-id)|true|Resource object type.| | *anonymous*|QueryByCollection|false|| | data|QueryByCollection_data|true|| | attributes|QueryByCollection_data_attributes|true|| | type|enum(and, or)|true|Resource object type.| | values|[QueryById]|true|Query `scene-items`.| | type|enum(query-by-collection)|true|Resource object type.| | *anonymous*|QueryAll|false|Resource object type.| | type|string|true|Resource object type.|
   * @param {SceneAlterationsApiCreateSceneAlterationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneAlterationsApi
   */
  public createSceneAlteration(
    requestParameters: SceneAlterationsApiCreateSceneAlterationRequest,
    options?: any
  ) {
    return SceneAlterationsApiFp(this.configuration)
      .createSceneAlteration(
        requestParameters.id,
        requestParameters.createSceneAlterationRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `queued-scene-alteration` by ID.
   * @param {SceneAlterationsApiGetQueuedSceneAlterationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneAlterationsApi
   */
  public getQueuedSceneAlteration(
    requestParameters: SceneAlterationsApiGetQueuedSceneAlterationRequest,
    options?: any
  ) {
    return SceneAlterationsApiFp(this.configuration)
      .getQueuedSceneAlteration(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `scene-alteration` by ID.
   * @param {SceneAlterationsApiGetSceneAlterationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneAlterationsApi
   */
  public getSceneAlteration(
    requestParameters: SceneAlterationsApiGetSceneAlterationRequest,
    options?: any
  ) {
    return SceneAlterationsApiFp(this.configuration)
      .getSceneAlteration(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get `scene-alterations`.
   * @param {SceneAlterationsApiGetSceneAlterationsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneAlterationsApi
   */
  public getSceneAlterations(
    requestParameters: SceneAlterationsApiGetSceneAlterationsRequest,
    options?: any
  ) {
    return SceneAlterationsApiFp(this.configuration)
      .getSceneAlterations(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SceneItemOverridesApi - axios parameter creator
 * @export
 */
export const SceneItemOverridesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `scene-item-override` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneItemOverrideRequest_data|true|| | attributes|CreateSceneItemOverrideRequest_data_attributes|true|| | material|ColorMaterial|false|Color properties describing how a material looks.| | ambient|Color3|true|RGB color.| | b|integer(int32)|true|Color value from 0 to 255.| | g|integer(int32)|true|Color value from 0 to 255.| | r|integer(int32)|true|Color value from 0 to 255.| | diffuse|Color3|true|RGB color.| | emissive|Color3|true|RGB color.| | glossiness|integer(int32)|true|Glossiness from 0 to 128.| | opacity|integer(int32)|true|Opacity from 0 to 100.| | specular|Color3|true|RGB color.| | transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| | r0|Vector4|true|4D vector.| | w|number|true|w value.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | r1|Vector4|true|4D vector.| | r2|Vector4|true|4D vector.| | r3|Vector4|true|4D vector.| | visible|boolean|false|Item visibility.| | relationships|CreateSceneItemOverrideRequest_data_relationships|true|| | sceneItem|SceneItemRelationship|true|Relationship to a `scene-item`.| | data|SceneItemRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(scene-item)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateSceneItemOverrideRequest} createSceneItemOverrideRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneItemOverride: async (
      id: string,
      createSceneItemOverrideRequest: CreateSceneItemOverrideRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling createSceneItemOverride.'
        );
      }
      // verify required parameter 'createSceneItemOverrideRequest' is not null or undefined
      if (
        createSceneItemOverrideRequest === null ||
        createSceneItemOverrideRequest === undefined
      ) {
        throw new RequiredError(
          'createSceneItemOverrideRequest',
          'Required parameter createSceneItemOverrideRequest was null or undefined when calling createSceneItemOverride.'
        );
      }
      const localVarPath = `/scene-views/{id}/scene-item-overrides`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof createSceneItemOverrideRequest !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type']
            )
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createSceneItemOverrideRequest !== undefined
              ? createSceneItemOverrideRequest
              : {}
          )
        : createSceneItemOverrideRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Delete a `scene-item-override`.
     * @param {string} id The &#x60;scene-item-override&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSceneItemOverride: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteSceneItemOverride.'
        );
      }
      const localVarPath = `/scene-item-overrides/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get `scene-item-overrides` for a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneItemOverrides: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getSceneItemOverrides.'
        );
      }
      const localVarPath = `/scene-views/{id}/scene-item-overrides`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Update a `scene-item-override`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneItemOverrideRequest_data|true|| | attributes|UpdateSceneItemOverrideRequest_data_attributes|true|| | material|ColorMaterialNullablenull|false|Color properties describing how a material looks.| | ambient|Color3|true|RGB color.| | b|integer(int32)|true|Color value from 0 to 255.| | g|integer(int32)|true|Color value from 0 to 255.| | r|integer(int32)|true|Color value from 0 to 255.| | diffuse|Color3|true|RGB color.| | emissive|Color3|true|RGB color.| | glossiness|integer(int32)|true|Glossiness from 0 to 128.| | opacity|integer(int32)|true|Opacity from 0 to 100.| | specular|Color3|true|RGB color.| | transform|Matrix4Nullablenull|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| | r0|Vector4|true|4D vector.| | w|number|true|w value.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | r1|Vector4|true|4D vector.| | r2|Vector4|true|4D vector.| | r3|Vector4|true|4D vector.| | visible|booleannull|false|Item visibility.| | id|string(uuid)|true|ID of the resource.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-item-override&#x60; ID.
     * @param {UpdateSceneItemOverrideRequest} updateSceneItemOverrideRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneItemOverride: async (
      id: string,
      updateSceneItemOverrideRequest: UpdateSceneItemOverrideRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateSceneItemOverride.'
        );
      }
      // verify required parameter 'updateSceneItemOverrideRequest' is not null or undefined
      if (
        updateSceneItemOverrideRequest === null ||
        updateSceneItemOverrideRequest === undefined
      ) {
        throw new RequiredError(
          'updateSceneItemOverrideRequest',
          'Required parameter updateSceneItemOverrideRequest was null or undefined when calling updateSceneItemOverride.'
        );
      }
      const localVarPath = `/scene-item-overrides/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof updateSceneItemOverrideRequest !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type']
            )
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            updateSceneItemOverrideRequest !== undefined
              ? updateSceneItemOverrideRequest
              : {}
          )
        : updateSceneItemOverrideRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SceneItemOverridesApi - functional programming interface
 * @export
 */
export const SceneItemOverridesApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `scene-item-override` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneItemOverrideRequest_data|true|| | attributes|CreateSceneItemOverrideRequest_data_attributes|true|| | material|ColorMaterial|false|Color properties describing how a material looks.| | ambient|Color3|true|RGB color.| | b|integer(int32)|true|Color value from 0 to 255.| | g|integer(int32)|true|Color value from 0 to 255.| | r|integer(int32)|true|Color value from 0 to 255.| | diffuse|Color3|true|RGB color.| | emissive|Color3|true|RGB color.| | glossiness|integer(int32)|true|Glossiness from 0 to 128.| | opacity|integer(int32)|true|Opacity from 0 to 100.| | specular|Color3|true|RGB color.| | transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| | r0|Vector4|true|4D vector.| | w|number|true|w value.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | r1|Vector4|true|4D vector.| | r2|Vector4|true|4D vector.| | r3|Vector4|true|4D vector.| | visible|boolean|false|Item visibility.| | relationships|CreateSceneItemOverrideRequest_data_relationships|true|| | sceneItem|SceneItemRelationship|true|Relationship to a `scene-item`.| | data|SceneItemRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(scene-item)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateSceneItemOverrideRequest} createSceneItemOverrideRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneItemOverride(
      id: string,
      createSceneItemOverrideRequest: CreateSceneItemOverrideRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneItemOverride>
    > {
      const localVarAxiosArgs = await SceneItemOverridesApiAxiosParamCreator(
        configuration
      ).createSceneItemOverride(id, createSceneItemOverrideRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Delete a `scene-item-override`.
     * @param {string} id The &#x60;scene-item-override&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSceneItemOverride(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SceneItemOverridesApiAxiosParamCreator(
        configuration
      ).deleteSceneItemOverride(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get `scene-item-overrides` for a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneItemOverrides(
      id: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneItemOverrideList>
    > {
      const localVarAxiosArgs = await SceneItemOverridesApiAxiosParamCreator(
        configuration
      ).getSceneItemOverrides(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Update a `scene-item-override`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneItemOverrideRequest_data|true|| | attributes|UpdateSceneItemOverrideRequest_data_attributes|true|| | material|ColorMaterialNullablenull|false|Color properties describing how a material looks.| | ambient|Color3|true|RGB color.| | b|integer(int32)|true|Color value from 0 to 255.| | g|integer(int32)|true|Color value from 0 to 255.| | r|integer(int32)|true|Color value from 0 to 255.| | diffuse|Color3|true|RGB color.| | emissive|Color3|true|RGB color.| | glossiness|integer(int32)|true|Glossiness from 0 to 128.| | opacity|integer(int32)|true|Opacity from 0 to 100.| | specular|Color3|true|RGB color.| | transform|Matrix4Nullablenull|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| | r0|Vector4|true|4D vector.| | w|number|true|w value.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | r1|Vector4|true|4D vector.| | r2|Vector4|true|4D vector.| | r3|Vector4|true|4D vector.| | visible|booleannull|false|Item visibility.| | id|string(uuid)|true|ID of the resource.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-item-override&#x60; ID.
     * @param {UpdateSceneItemOverrideRequest} updateSceneItemOverrideRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSceneItemOverride(
      id: string,
      updateSceneItemOverrideRequest: UpdateSceneItemOverrideRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneItemOverride>
    > {
      const localVarAxiosArgs = await SceneItemOverridesApiAxiosParamCreator(
        configuration
      ).updateSceneItemOverride(id, updateSceneItemOverrideRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * SceneItemOverridesApi - factory interface
 * @export
 */
export const SceneItemOverridesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `scene-item-override` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneItemOverrideRequest_data|true|| | attributes|CreateSceneItemOverrideRequest_data_attributes|true|| | material|ColorMaterial|false|Color properties describing how a material looks.| | ambient|Color3|true|RGB color.| | b|integer(int32)|true|Color value from 0 to 255.| | g|integer(int32)|true|Color value from 0 to 255.| | r|integer(int32)|true|Color value from 0 to 255.| | diffuse|Color3|true|RGB color.| | emissive|Color3|true|RGB color.| | glossiness|integer(int32)|true|Glossiness from 0 to 128.| | opacity|integer(int32)|true|Opacity from 0 to 100.| | specular|Color3|true|RGB color.| | transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| | r0|Vector4|true|4D vector.| | w|number|true|w value.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | r1|Vector4|true|4D vector.| | r2|Vector4|true|4D vector.| | r3|Vector4|true|4D vector.| | visible|boolean|false|Item visibility.| | relationships|CreateSceneItemOverrideRequest_data_relationships|true|| | sceneItem|SceneItemRelationship|true|Relationship to a `scene-item`.| | data|SceneItemRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(scene-item)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {CreateSceneItemOverrideRequest} createSceneItemOverrideRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneItemOverride(
      id: string,
      createSceneItemOverrideRequest: CreateSceneItemOverrideRequest,
      options?: any
    ): AxiosPromise<SceneItemOverride> {
      return SceneItemOverridesApiFp(configuration)
        .createSceneItemOverride(id, createSceneItemOverrideRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Delete a `scene-item-override`.
     * @param {string} id The &#x60;scene-item-override&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSceneItemOverride(id: string, options?: any): AxiosPromise<void> {
      return SceneItemOverridesApiFp(configuration)
        .deleteSceneItemOverride(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get `scene-item-overrides` for a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneItemOverrides(
      id: string,
      options?: any
    ): AxiosPromise<SceneItemOverrideList> {
      return SceneItemOverridesApiFp(configuration)
        .getSceneItemOverrides(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Update a `scene-item-override`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneItemOverrideRequest_data|true|| | attributes|UpdateSceneItemOverrideRequest_data_attributes|true|| | material|ColorMaterialNullablenull|false|Color properties describing how a material looks.| | ambient|Color3|true|RGB color.| | b|integer(int32)|true|Color value from 0 to 255.| | g|integer(int32)|true|Color value from 0 to 255.| | r|integer(int32)|true|Color value from 0 to 255.| | diffuse|Color3|true|RGB color.| | emissive|Color3|true|RGB color.| | glossiness|integer(int32)|true|Glossiness from 0 to 128.| | opacity|integer(int32)|true|Opacity from 0 to 100.| | specular|Color3|true|RGB color.| | transform|Matrix4Nullablenull|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| | r0|Vector4|true|4D vector.| | w|number|true|w value.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | r1|Vector4|true|4D vector.| | r2|Vector4|true|4D vector.| | r3|Vector4|true|4D vector.| | visible|booleannull|false|Item visibility.| | id|string(uuid)|true|ID of the resource.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-item-override&#x60; ID.
     * @param {UpdateSceneItemOverrideRequest} updateSceneItemOverrideRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneItemOverride(
      id: string,
      updateSceneItemOverrideRequest: UpdateSceneItemOverrideRequest,
      options?: any
    ): AxiosPromise<SceneItemOverride> {
      return SceneItemOverridesApiFp(configuration)
        .updateSceneItemOverride(id, updateSceneItemOverrideRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createSceneItemOverride operation in SceneItemOverridesApi.
 * @export
 * @interface SceneItemOverridesApiCreateSceneItemOverrideRequest
 */
export interface SceneItemOverridesApiCreateSceneItemOverrideRequest {
  /**
   * The &#x60;scene-view&#x60; ID.
   * @type {string}
   * @memberof SceneItemOverridesApiCreateSceneItemOverride
   */
  readonly id: string;

  /**
   *
   * @type {CreateSceneItemOverrideRequest}
   * @memberof SceneItemOverridesApiCreateSceneItemOverride
   */
  readonly createSceneItemOverrideRequest: CreateSceneItemOverrideRequest;
}

/**
 * Request parameters for deleteSceneItemOverride operation in SceneItemOverridesApi.
 * @export
 * @interface SceneItemOverridesApiDeleteSceneItemOverrideRequest
 */
export interface SceneItemOverridesApiDeleteSceneItemOverrideRequest {
  /**
   * The &#x60;scene-item-override&#x60; ID.
   * @type {string}
   * @memberof SceneItemOverridesApiDeleteSceneItemOverride
   */
  readonly id: string;
}

/**
 * Request parameters for getSceneItemOverrides operation in SceneItemOverridesApi.
 * @export
 * @interface SceneItemOverridesApiGetSceneItemOverridesRequest
 */
export interface SceneItemOverridesApiGetSceneItemOverridesRequest {
  /**
   * The &#x60;scene-view&#x60; ID.
   * @type {string}
   * @memberof SceneItemOverridesApiGetSceneItemOverrides
   */
  readonly id: string;
}

/**
 * Request parameters for updateSceneItemOverride operation in SceneItemOverridesApi.
 * @export
 * @interface SceneItemOverridesApiUpdateSceneItemOverrideRequest
 */
export interface SceneItemOverridesApiUpdateSceneItemOverrideRequest {
  /**
   * The &#x60;scene-item-override&#x60; ID.
   * @type {string}
   * @memberof SceneItemOverridesApiUpdateSceneItemOverride
   */
  readonly id: string;

  /**
   *
   * @type {UpdateSceneItemOverrideRequest}
   * @memberof SceneItemOverridesApiUpdateSceneItemOverride
   */
  readonly updateSceneItemOverrideRequest: UpdateSceneItemOverrideRequest;
}

/**
 * SceneItemOverridesApi - object-oriented interface
 * @export
 * @class SceneItemOverridesApi
 * @extends {BaseAPI}
 */
export class SceneItemOverridesApi extends BaseAPI {
  /**
   *  Create a `scene-item-override` for a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneItemOverrideRequest_data|true|| | attributes|CreateSceneItemOverrideRequest_data_attributes|true|| | material|ColorMaterial|false|Color properties describing how a material looks.| | ambient|Color3|true|RGB color.| | b|integer(int32)|true|Color value from 0 to 255.| | g|integer(int32)|true|Color value from 0 to 255.| | r|integer(int32)|true|Color value from 0 to 255.| | diffuse|Color3|true|RGB color.| | emissive|Color3|true|RGB color.| | glossiness|integer(int32)|true|Glossiness from 0 to 128.| | opacity|integer(int32)|true|Opacity from 0 to 100.| | specular|Color3|true|RGB color.| | transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| | r0|Vector4|true|4D vector.| | w|number|true|w value.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | r1|Vector4|true|4D vector.| | r2|Vector4|true|4D vector.| | r3|Vector4|true|4D vector.| | visible|boolean|false|Item visibility.| | relationships|CreateSceneItemOverrideRequest_data_relationships|true|| | sceneItem|SceneItemRelationship|true|Relationship to a `scene-item`.| | data|SceneItemRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(scene-item)|true|Resource object type.| | type|string|true|Resource object type.|
   * @param {SceneItemOverridesApiCreateSceneItemOverrideRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemOverridesApi
   */
  public createSceneItemOverride(
    requestParameters: SceneItemOverridesApiCreateSceneItemOverrideRequest,
    options?: any
  ) {
    return SceneItemOverridesApiFp(this.configuration)
      .createSceneItemOverride(
        requestParameters.id,
        requestParameters.createSceneItemOverrideRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Delete a `scene-item-override`.
   * @param {SceneItemOverridesApiDeleteSceneItemOverrideRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemOverridesApi
   */
  public deleteSceneItemOverride(
    requestParameters: SceneItemOverridesApiDeleteSceneItemOverrideRequest,
    options?: any
  ) {
    return SceneItemOverridesApiFp(this.configuration)
      .deleteSceneItemOverride(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get `scene-item-overrides` for a `scene-view`.
   * @param {SceneItemOverridesApiGetSceneItemOverridesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemOverridesApi
   */
  public getSceneItemOverrides(
    requestParameters: SceneItemOverridesApiGetSceneItemOverridesRequest,
    options?: any
  ) {
    return SceneItemOverridesApiFp(this.configuration)
      .getSceneItemOverrides(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Update a `scene-item-override`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneItemOverrideRequest_data|true|| | attributes|UpdateSceneItemOverrideRequest_data_attributes|true|| | material|ColorMaterialNullablenull|false|Color properties describing how a material looks.| | ambient|Color3|true|RGB color.| | b|integer(int32)|true|Color value from 0 to 255.| | g|integer(int32)|true|Color value from 0 to 255.| | r|integer(int32)|true|Color value from 0 to 255.| | diffuse|Color3|true|RGB color.| | emissive|Color3|true|RGB color.| | glossiness|integer(int32)|true|Glossiness from 0 to 128.| | opacity|integer(int32)|true|Opacity from 0 to 100.| | specular|Color3|true|RGB color.| | transform|Matrix4Nullablenull|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| | r0|Vector4|true|4D vector.| | w|number|true|w value.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | r1|Vector4|true|4D vector.| | r2|Vector4|true|4D vector.| | r3|Vector4|true|4D vector.| | visible|booleannull|false|Item visibility.| | id|string(uuid)|true|ID of the resource.| | type|string|true|Resource object type.|
   * @param {SceneItemOverridesApiUpdateSceneItemOverrideRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemOverridesApi
   */
  public updateSceneItemOverride(
    requestParameters: SceneItemOverridesApiUpdateSceneItemOverrideRequest,
    options?: any
  ) {
    return SceneItemOverridesApiFp(this.configuration)
      .updateSceneItemOverride(
        requestParameters.id,
        requestParameters.updateSceneItemOverrideRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SceneItemsApi - axios parameter creator
 * @export
 */
export const SceneItemsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `scene-item` for a `scene`. Provide the source geometry either via `part-revision` or `geometry-set` UUID using `relationship.source` or by supplied IDs using `attributes.source`. Provide the hierarchical parent either via `scene-item` UUID using `relationship.source` or by supplied ID using `attributes.parent`. This API is asynchronous, returning the location of a `queued-scene-item`. Check the status via the getQueuedSceneItem API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneItemRequest_data|true|| | attributes|CreateSceneItemRequest_data_attributes|true|| | materialOverride|ColorMaterial|false|Color properties describing how a material looks.| | ambient|Color3|true|RGB color.| | b|integer(int32)|true|Color value from 0 to 255.| | g|integer(int32)|true|Color value from 0 to 255.| | r|integer(int32)|true|Color value from 0 to 255.| | diffuse|Color3|true|RGB color.| | emissive|Color3|true|RGB color.| | glossiness|integer(int32)|true|Glossiness from 0 to 128.| | opacity|integer(int32)|true|Opacity from 0 to 100.| | specular|Color3|true|RGB color.| | parent|string|false|ID provided for correlation. For example, an existing ID from a PLM system.| | source|PartRevisionSuppliedId|false|| | suppliedPartId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| | suppliedRevisionId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| | suppliedId|string|false|ID provided for correlation. For example, an existing ID from a PLM system.| | transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| | r0|Vector4|true|4D vector.| | w|number|true|w value.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | r1|Vector4|true|4D vector.| | r2|Vector4|true|4D vector.| | r3|Vector4|true|4D vector.| | visible|boolean|false|Item visibility.| | relationships|CreateSceneItemRequest_data_relationships|true|| | parent|SceneItemRelationship|false|Relationship to a `scene-item`.| | data|SceneItemRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(scene-item)|true|Resource object type.| | source|any|false|Relationship to a `geometry-set` or `part-revision`.| | *anonymous*|GeometrySetRelationship|false|Relationship to a `geometry-set`.| | data|GeometrySetRelationshipData|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(geometry-set)|true|Resource object type.| | *anonymous*|PartRevisionRelationship|false|Relationship to a `part-revision`.| | data|PartData_relationships_partRevisions|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(part-revision)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneItemRequest} createSceneItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneItem: async (
      id: string,
      createSceneItemRequest: CreateSceneItemRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling createSceneItem.'
        );
      }
      // verify required parameter 'createSceneItemRequest' is not null or undefined
      if (
        createSceneItemRequest === null ||
        createSceneItemRequest === undefined
      ) {
        throw new RequiredError(
          'createSceneItemRequest',
          'Required parameter createSceneItemRequest was null or undefined when calling createSceneItem.'
        );
      }
      const localVarPath = `/scenes/{id}/scene-items`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof createSceneItemRequest !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type']
            )
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createSceneItemRequest !== undefined ? createSceneItemRequest : {}
          )
        : createSceneItemRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Delete a `scene-item`.
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSceneItem: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteSceneItem.'
        );
      }
      const localVarPath = `/scene-items/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `queued-scene-item`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `scene-item`. Once created, commit the scene via the updateScene API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.
     * @param {string} id The &#x60;queued-scene-item&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedSceneItem: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getQueuedSceneItem.'
        );
      }
      const localVarPath = `/queued-scene-items/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `scene-item` by ID.
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneItem: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getSceneItem.'
        );
      }
      const localVarPath = `/scene-items/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get `scenes-items` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {string} [filterParent] Parent ID to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneItems: async (
      id: string,
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      filterParent?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getSceneItems.'
        );
      }
      const localVarPath = `/scenes/{id}/scene-items`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      if (filterSuppliedId !== undefined) {
        localVarQueryParameter['filter[suppliedId]'] = filterSuppliedId;
      }

      if (filterParent !== undefined) {
        localVarQueryParameter['filter[parent]'] = filterParent;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Update a `scene-item`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneItemRequest_data|true|| | attributes|UpdateSceneItemRequest_data_attributes|true|| | materialOverride|MaterialOverride|false|Color material override.| | value|ColorMaterial|false|Color properties describing how a material looks.| | ambient|Color3|true|RGB color.| | b|integer(int32)|true|Color value from 0 to 255.| | g|integer(int32)|true|Color value from 0 to 255.| | r|integer(int32)|true|Color value from 0 to 255.| | diffuse|Color3|true|RGB color.| | emissive|Color3|true|RGB color.| | glossiness|integer(int32)|true|Glossiness from 0 to 128.| | opacity|integer(int32)|true|Opacity from 0 to 100.| | specular|Color3|true|RGB color.| | transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| | r0|Vector4|true|4D vector.| | w|number|true|w value.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | r1|Vector4|true|4D vector.| | r2|Vector4|true|4D vector.| | r3|Vector4|true|4D vector.| | visible|boolean|false|Item visibility.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {UpdateSceneItemRequest} updateSceneItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneItem: async (
      id: string,
      updateSceneItemRequest: UpdateSceneItemRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateSceneItem.'
        );
      }
      // verify required parameter 'updateSceneItemRequest' is not null or undefined
      if (
        updateSceneItemRequest === null ||
        updateSceneItemRequest === undefined
      ) {
        throw new RequiredError(
          'updateSceneItemRequest',
          'Required parameter updateSceneItemRequest was null or undefined when calling updateSceneItem.'
        );
      }
      const localVarPath = `/scene-items/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof updateSceneItemRequest !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type']
            )
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            updateSceneItemRequest !== undefined ? updateSceneItemRequest : {}
          )
        : updateSceneItemRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SceneItemsApi - functional programming interface
 * @export
 */
export const SceneItemsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create a `scene-item` for a `scene`. Provide the source geometry either via `part-revision` or `geometry-set` UUID using `relationship.source` or by supplied IDs using `attributes.source`. Provide the hierarchical parent either via `scene-item` UUID using `relationship.source` or by supplied ID using `attributes.parent`. This API is asynchronous, returning the location of a `queued-scene-item`. Check the status via the getQueuedSceneItem API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneItemRequest_data|true|| | attributes|CreateSceneItemRequest_data_attributes|true|| | materialOverride|ColorMaterial|false|Color properties describing how a material looks.| | ambient|Color3|true|RGB color.| | b|integer(int32)|true|Color value from 0 to 255.| | g|integer(int32)|true|Color value from 0 to 255.| | r|integer(int32)|true|Color value from 0 to 255.| | diffuse|Color3|true|RGB color.| | emissive|Color3|true|RGB color.| | glossiness|integer(int32)|true|Glossiness from 0 to 128.| | opacity|integer(int32)|true|Opacity from 0 to 100.| | specular|Color3|true|RGB color.| | parent|string|false|ID provided for correlation. For example, an existing ID from a PLM system.| | source|PartRevisionSuppliedId|false|| | suppliedPartId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| | suppliedRevisionId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| | suppliedId|string|false|ID provided for correlation. For example, an existing ID from a PLM system.| | transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| | r0|Vector4|true|4D vector.| | w|number|true|w value.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | r1|Vector4|true|4D vector.| | r2|Vector4|true|4D vector.| | r3|Vector4|true|4D vector.| | visible|boolean|false|Item visibility.| | relationships|CreateSceneItemRequest_data_relationships|true|| | parent|SceneItemRelationship|false|Relationship to a `scene-item`.| | data|SceneItemRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(scene-item)|true|Resource object type.| | source|any|false|Relationship to a `geometry-set` or `part-revision`.| | *anonymous*|GeometrySetRelationship|false|Relationship to a `geometry-set`.| | data|GeometrySetRelationshipData|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(geometry-set)|true|Resource object type.| | *anonymous*|PartRevisionRelationship|false|Relationship to a `part-revision`.| | data|PartData_relationships_partRevisions|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(part-revision)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneItemRequest} createSceneItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneItem(
      id: string,
      createSceneItemRequest: CreateSceneItemRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await SceneItemsApiAxiosParamCreator(
        configuration
      ).createSceneItem(id, createSceneItemRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Delete a `scene-item`.
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSceneItem(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SceneItemsApiAxiosParamCreator(
        configuration
      ).deleteSceneItem(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `queued-scene-item`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `scene-item`. Once created, commit the scene via the updateScene API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.
     * @param {string} id The &#x60;queued-scene-item&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedSceneItem(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await SceneItemsApiAxiosParamCreator(
        configuration
      ).getQueuedSceneItem(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `scene-item` by ID.
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneItem(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneItem>
    > {
      const localVarAxiosArgs = await SceneItemsApiAxiosParamCreator(
        configuration
      ).getSceneItem(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get `scenes-items` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {string} [filterParent] Parent ID to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneItems(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      filterParent?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneItemList>
    > {
      const localVarAxiosArgs = await SceneItemsApiAxiosParamCreator(
        configuration
      ).getSceneItems(
        id,
        pageCursor,
        pageSize,
        filterSuppliedId,
        filterParent,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Update a `scene-item`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneItemRequest_data|true|| | attributes|UpdateSceneItemRequest_data_attributes|true|| | materialOverride|MaterialOverride|false|Color material override.| | value|ColorMaterial|false|Color properties describing how a material looks.| | ambient|Color3|true|RGB color.| | b|integer(int32)|true|Color value from 0 to 255.| | g|integer(int32)|true|Color value from 0 to 255.| | r|integer(int32)|true|Color value from 0 to 255.| | diffuse|Color3|true|RGB color.| | emissive|Color3|true|RGB color.| | glossiness|integer(int32)|true|Glossiness from 0 to 128.| | opacity|integer(int32)|true|Opacity from 0 to 100.| | specular|Color3|true|RGB color.| | transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| | r0|Vector4|true|4D vector.| | w|number|true|w value.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | r1|Vector4|true|4D vector.| | r2|Vector4|true|4D vector.| | r3|Vector4|true|4D vector.| | visible|boolean|false|Item visibility.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {UpdateSceneItemRequest} updateSceneItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSceneItem(
      id: string,
      updateSceneItemRequest: UpdateSceneItemRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneItem>
    > {
      const localVarAxiosArgs = await SceneItemsApiAxiosParamCreator(
        configuration
      ).updateSceneItem(id, updateSceneItemRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * SceneItemsApi - factory interface
 * @export
 */
export const SceneItemsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `scene-item` for a `scene`. Provide the source geometry either via `part-revision` or `geometry-set` UUID using `relationship.source` or by supplied IDs using `attributes.source`. Provide the hierarchical parent either via `scene-item` UUID using `relationship.source` or by supplied ID using `attributes.parent`. This API is asynchronous, returning the location of a `queued-scene-item`. Check the status via the getQueuedSceneItem API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneItemRequest_data|true|| | attributes|CreateSceneItemRequest_data_attributes|true|| | materialOverride|ColorMaterial|false|Color properties describing how a material looks.| | ambient|Color3|true|RGB color.| | b|integer(int32)|true|Color value from 0 to 255.| | g|integer(int32)|true|Color value from 0 to 255.| | r|integer(int32)|true|Color value from 0 to 255.| | diffuse|Color3|true|RGB color.| | emissive|Color3|true|RGB color.| | glossiness|integer(int32)|true|Glossiness from 0 to 128.| | opacity|integer(int32)|true|Opacity from 0 to 100.| | specular|Color3|true|RGB color.| | parent|string|false|ID provided for correlation. For example, an existing ID from a PLM system.| | source|PartRevisionSuppliedId|false|| | suppliedPartId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| | suppliedRevisionId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| | suppliedId|string|false|ID provided for correlation. For example, an existing ID from a PLM system.| | transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| | r0|Vector4|true|4D vector.| | w|number|true|w value.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | r1|Vector4|true|4D vector.| | r2|Vector4|true|4D vector.| | r3|Vector4|true|4D vector.| | visible|boolean|false|Item visibility.| | relationships|CreateSceneItemRequest_data_relationships|true|| | parent|SceneItemRelationship|false|Relationship to a `scene-item`.| | data|SceneItemRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(scene-item)|true|Resource object type.| | source|any|false|Relationship to a `geometry-set` or `part-revision`.| | *anonymous*|GeometrySetRelationship|false|Relationship to a `geometry-set`.| | data|GeometrySetRelationshipData|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(geometry-set)|true|Resource object type.| | *anonymous*|PartRevisionRelationship|false|Relationship to a `part-revision`.| | data|PartData_relationships_partRevisions|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(part-revision)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneItemRequest} createSceneItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneItem(
      id: string,
      createSceneItemRequest: CreateSceneItemRequest,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return SceneItemsApiFp(configuration)
        .createSceneItem(id, createSceneItemRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Delete a `scene-item`.
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSceneItem(id: string, options?: any): AxiosPromise<void> {
      return SceneItemsApiFp(configuration)
        .deleteSceneItem(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `queued-scene-item`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `scene-item`. Once created, commit the scene via the updateScene API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.
     * @param {string} id The &#x60;queued-scene-item&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedSceneItem(id: string, options?: any): AxiosPromise<QueuedJob> {
      return SceneItemsApiFp(configuration)
        .getQueuedSceneItem(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `scene-item` by ID.
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneItem(id: string, options?: any): AxiosPromise<SceneItem> {
      return SceneItemsApiFp(configuration)
        .getSceneItem(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get `scenes-items` for a `scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {string} [filterSuppliedId] Comma-separated list of supplied IDs to filter on.
     * @param {string} [filterParent] Parent ID to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneItems(
      id: string,
      pageCursor?: string,
      pageSize?: number,
      filterSuppliedId?: string,
      filterParent?: string,
      options?: any
    ): AxiosPromise<SceneItemList> {
      return SceneItemsApiFp(configuration)
        .getSceneItems(
          id,
          pageCursor,
          pageSize,
          filterSuppliedId,
          filterParent,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *  Update a `scene-item`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneItemRequest_data|true|| | attributes|UpdateSceneItemRequest_data_attributes|true|| | materialOverride|MaterialOverride|false|Color material override.| | value|ColorMaterial|false|Color properties describing how a material looks.| | ambient|Color3|true|RGB color.| | b|integer(int32)|true|Color value from 0 to 255.| | g|integer(int32)|true|Color value from 0 to 255.| | r|integer(int32)|true|Color value from 0 to 255.| | diffuse|Color3|true|RGB color.| | emissive|Color3|true|RGB color.| | glossiness|integer(int32)|true|Glossiness from 0 to 128.| | opacity|integer(int32)|true|Opacity from 0 to 100.| | specular|Color3|true|RGB color.| | transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| | r0|Vector4|true|4D vector.| | w|number|true|w value.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | r1|Vector4|true|4D vector.| | r2|Vector4|true|4D vector.| | r3|Vector4|true|4D vector.| | visible|boolean|false|Item visibility.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-item&#x60; ID.
     * @param {UpdateSceneItemRequest} updateSceneItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneItem(
      id: string,
      updateSceneItemRequest: UpdateSceneItemRequest,
      options?: any
    ): AxiosPromise<SceneItem> {
      return SceneItemsApiFp(configuration)
        .updateSceneItem(id, updateSceneItemRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createSceneItem operation in SceneItemsApi.
 * @export
 * @interface SceneItemsApiCreateSceneItemRequest
 */
export interface SceneItemsApiCreateSceneItemRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof SceneItemsApiCreateSceneItem
   */
  readonly id: string;

  /**
   *
   * @type {CreateSceneItemRequest}
   * @memberof SceneItemsApiCreateSceneItem
   */
  readonly createSceneItemRequest: CreateSceneItemRequest;
}

/**
 * Request parameters for deleteSceneItem operation in SceneItemsApi.
 * @export
 * @interface SceneItemsApiDeleteSceneItemRequest
 */
export interface SceneItemsApiDeleteSceneItemRequest {
  /**
   * The &#x60;scene-item&#x60; ID.
   * @type {string}
   * @memberof SceneItemsApiDeleteSceneItem
   */
  readonly id: string;
}

/**
 * Request parameters for getQueuedSceneItem operation in SceneItemsApi.
 * @export
 * @interface SceneItemsApiGetQueuedSceneItemRequest
 */
export interface SceneItemsApiGetQueuedSceneItemRequest {
  /**
   * The &#x60;queued-scene-item&#x60; ID.
   * @type {string}
   * @memberof SceneItemsApiGetQueuedSceneItem
   */
  readonly id: string;
}

/**
 * Request parameters for getSceneItem operation in SceneItemsApi.
 * @export
 * @interface SceneItemsApiGetSceneItemRequest
 */
export interface SceneItemsApiGetSceneItemRequest {
  /**
   * The &#x60;scene-item&#x60; ID.
   * @type {string}
   * @memberof SceneItemsApiGetSceneItem
   */
  readonly id: string;
}

/**
 * Request parameters for getSceneItems operation in SceneItemsApi.
 * @export
 * @interface SceneItemsApiGetSceneItemsRequest
 */
export interface SceneItemsApiGetSceneItemsRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof SceneItemsApiGetSceneItems
   */
  readonly id: string;

  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof SceneItemsApiGetSceneItems
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof SceneItemsApiGetSceneItems
   */
  readonly pageSize?: number;

  /**
   * Comma-separated list of supplied IDs to filter on.
   * @type {string}
   * @memberof SceneItemsApiGetSceneItems
   */
  readonly filterSuppliedId?: string;

  /**
   * Parent ID to filter on.
   * @type {string}
   * @memberof SceneItemsApiGetSceneItems
   */
  readonly filterParent?: string;
}

/**
 * Request parameters for updateSceneItem operation in SceneItemsApi.
 * @export
 * @interface SceneItemsApiUpdateSceneItemRequest
 */
export interface SceneItemsApiUpdateSceneItemRequest {
  /**
   * The &#x60;scene-item&#x60; ID.
   * @type {string}
   * @memberof SceneItemsApiUpdateSceneItem
   */
  readonly id: string;

  /**
   *
   * @type {UpdateSceneItemRequest}
   * @memberof SceneItemsApiUpdateSceneItem
   */
  readonly updateSceneItemRequest: UpdateSceneItemRequest;
}

/**
 * SceneItemsApi - object-oriented interface
 * @export
 * @class SceneItemsApi
 * @extends {BaseAPI}
 */
export class SceneItemsApi extends BaseAPI {
  /**
   *  Create a `scene-item` for a `scene`. Provide the source geometry either via `part-revision` or `geometry-set` UUID using `relationship.source` or by supplied IDs using `attributes.source`. Provide the hierarchical parent either via `scene-item` UUID using `relationship.source` or by supplied ID using `attributes.parent`. This API is asynchronous, returning the location of a `queued-scene-item`. Check the status via the getQueuedSceneItem API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneItemRequest_data|true|| | attributes|CreateSceneItemRequest_data_attributes|true|| | materialOverride|ColorMaterial|false|Color properties describing how a material looks.| | ambient|Color3|true|RGB color.| | b|integer(int32)|true|Color value from 0 to 255.| | g|integer(int32)|true|Color value from 0 to 255.| | r|integer(int32)|true|Color value from 0 to 255.| | diffuse|Color3|true|RGB color.| | emissive|Color3|true|RGB color.| | glossiness|integer(int32)|true|Glossiness from 0 to 128.| | opacity|integer(int32)|true|Opacity from 0 to 100.| | specular|Color3|true|RGB color.| | parent|string|false|ID provided for correlation. For example, an existing ID from a PLM system.| | source|PartRevisionSuppliedId|false|| | suppliedPartId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| | suppliedRevisionId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| | suppliedId|string|false|ID provided for correlation. For example, an existing ID from a PLM system.| | transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| | r0|Vector4|true|4D vector.| | w|number|true|w value.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | r1|Vector4|true|4D vector.| | r2|Vector4|true|4D vector.| | r3|Vector4|true|4D vector.| | visible|boolean|false|Item visibility.| | relationships|CreateSceneItemRequest_data_relationships|true|| | parent|SceneItemRelationship|false|Relationship to a `scene-item`.| | data|SceneItemRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(scene-item)|true|Resource object type.| | source|any|false|Relationship to a `geometry-set` or `part-revision`.| | *anonymous*|GeometrySetRelationship|false|Relationship to a `geometry-set`.| | data|GeometrySetRelationshipData|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(geometry-set)|true|Resource object type.| | *anonymous*|PartRevisionRelationship|false|Relationship to a `part-revision`.| | data|PartData_relationships_partRevisions|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(part-revision)|true|Resource object type.| | type|string|true|Resource object type.|
   * @param {SceneItemsApiCreateSceneItemRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemsApi
   */
  public createSceneItem(
    requestParameters: SceneItemsApiCreateSceneItemRequest,
    options?: any
  ) {
    return SceneItemsApiFp(this.configuration)
      .createSceneItem(
        requestParameters.id,
        requestParameters.createSceneItemRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Delete a `scene-item`.
   * @param {SceneItemsApiDeleteSceneItemRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemsApi
   */
  public deleteSceneItem(
    requestParameters: SceneItemsApiDeleteSceneItemRequest,
    options?: any
  ) {
    return SceneItemsApiFp(this.configuration)
      .deleteSceneItem(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `queued-scene-item`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `scene-item`. Once created, commit the scene via the updateScene API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.
   * @param {SceneItemsApiGetQueuedSceneItemRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemsApi
   */
  public getQueuedSceneItem(
    requestParameters: SceneItemsApiGetQueuedSceneItemRequest,
    options?: any
  ) {
    return SceneItemsApiFp(this.configuration)
      .getQueuedSceneItem(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `scene-item` by ID.
   * @param {SceneItemsApiGetSceneItemRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemsApi
   */
  public getSceneItem(
    requestParameters: SceneItemsApiGetSceneItemRequest,
    options?: any
  ) {
    return SceneItemsApiFp(this.configuration)
      .getSceneItem(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get `scenes-items` for a `scene`.
   * @param {SceneItemsApiGetSceneItemsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemsApi
   */
  public getSceneItems(
    requestParameters: SceneItemsApiGetSceneItemsRequest,
    options?: any
  ) {
    return SceneItemsApiFp(this.configuration)
      .getSceneItems(
        requestParameters.id,
        requestParameters.pageCursor,
        requestParameters.pageSize,
        requestParameters.filterSuppliedId,
        requestParameters.filterParent,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Update a `scene-item`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneItemRequest_data|true|| | attributes|UpdateSceneItemRequest_data_attributes|true|| | materialOverride|MaterialOverride|false|Color material override.| | value|ColorMaterial|false|Color properties describing how a material looks.| | ambient|Color3|true|RGB color.| | b|integer(int32)|true|Color value from 0 to 255.| | g|integer(int32)|true|Color value from 0 to 255.| | r|integer(int32)|true|Color value from 0 to 255.| | diffuse|Color3|true|RGB color.| | emissive|Color3|true|RGB color.| | glossiness|integer(int32)|true|Glossiness from 0 to 128.| | opacity|integer(int32)|true|Opacity from 0 to 100.| | specular|Color3|true|RGB color.| | transform|Matrix4|false|4x4 affine transformation matrix, see [Transformation Matrices](https://developer.vertexvis.com/docs/guides/rendering-scenes#transformation-matrices) for details.| | r0|Vector4|true|4D vector.| | w|number|true|w value.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | r1|Vector4|true|4D vector.| | r2|Vector4|true|4D vector.| | r3|Vector4|true|4D vector.| | visible|boolean|false|Item visibility.| | type|string|true|Resource object type.|
   * @param {SceneItemsApiUpdateSceneItemRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneItemsApi
   */
  public updateSceneItem(
    requestParameters: SceneItemsApiUpdateSceneItemRequest,
    options?: any
  ) {
    return SceneItemsApiFp(this.configuration)
      .updateSceneItem(
        requestParameters.id,
        requestParameters.updateSceneItemRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SceneTemplatesApi - axios parameter creator
 * @export
 */
export const SceneTemplatesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `scene-template`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneTemplateRequest_data|true|| | attributes|CreateSceneTemplateRequest_data_attributes|true|| | name|string|false|Name of the scene template.| | suppliedId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| | relationships|CreateGeometrySetRequest_data_relationships|true|| | source|FileRelationship|true|Relationship to a `file`.| | data|FileRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(file)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {CreateSceneTemplateRequest} createSceneTemplateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneTemplate: async (
      createSceneTemplateRequest: CreateSceneTemplateRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createSceneTemplateRequest' is not null or undefined
      if (
        createSceneTemplateRequest === null ||
        createSceneTemplateRequest === undefined
      ) {
        throw new RequiredError(
          'createSceneTemplateRequest',
          'Required parameter createSceneTemplateRequest was null or undefined when calling createSceneTemplate.'
        );
      }
      const localVarPath = `/scene-templates`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof createSceneTemplateRequest !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type']
            )
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createSceneTemplateRequest !== undefined
              ? createSceneTemplateRequest
              : {}
          )
        : createSceneTemplateRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `queued-scene-template`.
     * @param {string} id The &#x60;queued-scene-template&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedSceneTemplate: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getQueuedSceneTemplate.'
        );
      }
      const localVarPath = `/queued-scene-templates/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `scene-template` by ID.
     * @param {string} id The &#x60;scene-template&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneTemplate: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getSceneTemplate.'
        );
      }
      const localVarPath = `/scene-templates/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get `scene-templates`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneTemplates: async (
      pageCursor?: string,
      pageSize?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/scene-templates`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SceneTemplatesApi - functional programming interface
 * @export
 */
export const SceneTemplatesApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create a `scene-template`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneTemplateRequest_data|true|| | attributes|CreateSceneTemplateRequest_data_attributes|true|| | name|string|false|Name of the scene template.| | suppliedId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| | relationships|CreateGeometrySetRequest_data_relationships|true|| | source|FileRelationship|true|Relationship to a `file`.| | data|FileRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(file)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {CreateSceneTemplateRequest} createSceneTemplateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneTemplate(
      createSceneTemplateRequest: CreateSceneTemplateRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await SceneTemplatesApiAxiosParamCreator(
        configuration
      ).createSceneTemplate(createSceneTemplateRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `queued-scene-template`.
     * @param {string} id The &#x60;queued-scene-template&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedSceneTemplate(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await SceneTemplatesApiAxiosParamCreator(
        configuration
      ).getQueuedSceneTemplate(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `scene-template` by ID.
     * @param {string} id The &#x60;scene-template&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneTemplate(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneTemplate>
    > {
      const localVarAxiosArgs = await SceneTemplatesApiAxiosParamCreator(
        configuration
      ).getSceneTemplate(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get `scene-templates`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneTemplates(
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SceneTemplateList>
    > {
      const localVarAxiosArgs = await SceneTemplatesApiAxiosParamCreator(
        configuration
      ).getSceneTemplates(pageCursor, pageSize, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * SceneTemplatesApi - factory interface
 * @export
 */
export const SceneTemplatesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `scene-template`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneTemplateRequest_data|true|| | attributes|CreateSceneTemplateRequest_data_attributes|true|| | name|string|false|Name of the scene template.| | suppliedId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| | relationships|CreateGeometrySetRequest_data_relationships|true|| | source|FileRelationship|true|Relationship to a `file`.| | data|FileRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(file)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {CreateSceneTemplateRequest} createSceneTemplateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneTemplate(
      createSceneTemplateRequest: CreateSceneTemplateRequest,
      options?: any
    ): AxiosPromise<QueuedJob> {
      return SceneTemplatesApiFp(configuration)
        .createSceneTemplate(createSceneTemplateRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `queued-scene-template`.
     * @param {string} id The &#x60;queued-scene-template&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedSceneTemplate(id: string, options?: any): AxiosPromise<QueuedJob> {
      return SceneTemplatesApiFp(configuration)
        .getQueuedSceneTemplate(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `scene-template` by ID.
     * @param {string} id The &#x60;scene-template&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneTemplate(id: string, options?: any): AxiosPromise<SceneTemplate> {
      return SceneTemplatesApiFp(configuration)
        .getSceneTemplate(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get `scene-templates`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneTemplates(
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<SceneTemplateList> {
      return SceneTemplatesApiFp(configuration)
        .getSceneTemplates(pageCursor, pageSize, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createSceneTemplate operation in SceneTemplatesApi.
 * @export
 * @interface SceneTemplatesApiCreateSceneTemplateRequest
 */
export interface SceneTemplatesApiCreateSceneTemplateRequest {
  /**
   *
   * @type {CreateSceneTemplateRequest}
   * @memberof SceneTemplatesApiCreateSceneTemplate
   */
  readonly createSceneTemplateRequest: CreateSceneTemplateRequest;
}

/**
 * Request parameters for getQueuedSceneTemplate operation in SceneTemplatesApi.
 * @export
 * @interface SceneTemplatesApiGetQueuedSceneTemplateRequest
 */
export interface SceneTemplatesApiGetQueuedSceneTemplateRequest {
  /**
   * The &#x60;queued-scene-template&#x60; ID.
   * @type {string}
   * @memberof SceneTemplatesApiGetQueuedSceneTemplate
   */
  readonly id: string;
}

/**
 * Request parameters for getSceneTemplate operation in SceneTemplatesApi.
 * @export
 * @interface SceneTemplatesApiGetSceneTemplateRequest
 */
export interface SceneTemplatesApiGetSceneTemplateRequest {
  /**
   * The &#x60;scene-template&#x60; ID.
   * @type {string}
   * @memberof SceneTemplatesApiGetSceneTemplate
   */
  readonly id: string;
}

/**
 * Request parameters for getSceneTemplates operation in SceneTemplatesApi.
 * @export
 * @interface SceneTemplatesApiGetSceneTemplatesRequest
 */
export interface SceneTemplatesApiGetSceneTemplatesRequest {
  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof SceneTemplatesApiGetSceneTemplates
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof SceneTemplatesApiGetSceneTemplates
   */
  readonly pageSize?: number;
}

/**
 * SceneTemplatesApi - object-oriented interface
 * @export
 * @class SceneTemplatesApi
 * @extends {BaseAPI}
 */
export class SceneTemplatesApi extends BaseAPI {
  /**
   *  Create a `scene-template`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneTemplateRequest_data|true|| | attributes|CreateSceneTemplateRequest_data_attributes|true|| | name|string|false|Name of the scene template.| | suppliedId|string|true|ID provided for correlation. For example, an existing ID from a PLM system.| | relationships|CreateGeometrySetRequest_data_relationships|true|| | source|FileRelationship|true|Relationship to a `file`.| | data|FileRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(file)|true|Resource object type.| | type|string|true|Resource object type.|
   * @param {SceneTemplatesApiCreateSceneTemplateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneTemplatesApi
   */
  public createSceneTemplate(
    requestParameters: SceneTemplatesApiCreateSceneTemplateRequest,
    options?: any
  ) {
    return SceneTemplatesApiFp(this.configuration)
      .createSceneTemplate(
        requestParameters.createSceneTemplateRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `queued-scene-template`.
   * @param {SceneTemplatesApiGetQueuedSceneTemplateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneTemplatesApi
   */
  public getQueuedSceneTemplate(
    requestParameters: SceneTemplatesApiGetQueuedSceneTemplateRequest,
    options?: any
  ) {
    return SceneTemplatesApiFp(this.configuration)
      .getQueuedSceneTemplate(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `scene-template` by ID.
   * @param {SceneTemplatesApiGetSceneTemplateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneTemplatesApi
   */
  public getSceneTemplate(
    requestParameters: SceneTemplatesApiGetSceneTemplateRequest,
    options?: any
  ) {
    return SceneTemplatesApiFp(this.configuration)
      .getSceneTemplate(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get `scene-templates`.
   * @param {SceneTemplatesApiGetSceneTemplatesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneTemplatesApi
   */
  public getSceneTemplates(
    requestParameters: SceneTemplatesApiGetSceneTemplatesRequest = {},
    options?: any
  ) {
    return SceneTemplatesApiFp(this.configuration)
      .getSceneTemplates(
        requestParameters.pageCursor,
        requestParameters.pageSize,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SceneViewsApi - axios parameter creator
 * @export
 */
export const SceneViewsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `scene-view` of a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneViewRequest_data|true|| | attributes|CreateSceneViewRequest_data_attributes|true|| | camera|Camera|false|Camera placement in 3D space.| | lookAt|Vector3|true|3D vector.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | position|Vector3|true|3D vector.| | up|Vector3|true|3D vector.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneViewRequest} createSceneViewRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneView: async (
      id: string,
      createSceneViewRequest: CreateSceneViewRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling createSceneView.'
        );
      }
      // verify required parameter 'createSceneViewRequest' is not null or undefined
      if (
        createSceneViewRequest === null ||
        createSceneViewRequest === undefined
      ) {
        throw new RequiredError(
          'createSceneViewRequest',
          'Required parameter createSceneViewRequest was null or undefined when calling createSceneView.'
        );
      }
      const localVarPath = `/scenes/{id}/scene-views`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof createSceneViewRequest !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type']
            )
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createSceneViewRequest !== undefined ? createSceneViewRequest : {}
          )
        : createSceneViewRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Delete a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSceneView: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteSceneView.'
        );
      }
      const localVarPath = `/scene-views/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `scene-view` by ID.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneView: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getSceneView.'
        );
      }
      const localVarPath = `/scene-views/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a rendered image of a `scene-view`. If a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {number} [height] The height of the image to render.
     * @param {number} [width] The width of the image to render.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    renderSceneView: async (
      id: string,
      height?: number,
      width?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling renderSceneView.'
        );
      }
      const localVarPath = `/scene-views/{id}/image`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (height !== undefined) {
        localVarQueryParameter['height'] = height;
      }

      if (width !== undefined) {
        localVarQueryParameter['width'] = width;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Update a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneViewRequest_data|true|| | attributes|UpdateSceneViewRequest_data_attributes|true|| | camera|any|false|| | *anonymous*|Camera|false|Camera placement in 3D space.| | lookAt|Vector3|true|3D vector.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | position|Vector3|true|3D vector.| | up|Vector3|true|3D vector.| | *anonymous*|CameraFit|false|Fit camera in 3D space based on items in scene.| | type|enum(fit-visible-scene-items)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {UpdateSceneViewRequest} updateSceneViewRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneView: async (
      id: string,
      updateSceneViewRequest: UpdateSceneViewRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateSceneView.'
        );
      }
      // verify required parameter 'updateSceneViewRequest' is not null or undefined
      if (
        updateSceneViewRequest === null ||
        updateSceneViewRequest === undefined
      ) {
        throw new RequiredError(
          'updateSceneViewRequest',
          'Required parameter updateSceneViewRequest was null or undefined when calling updateSceneView.'
        );
      }
      const localVarPath = `/scene-views/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof updateSceneViewRequest !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type']
            )
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            updateSceneViewRequest !== undefined ? updateSceneViewRequest : {}
          )
        : updateSceneViewRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SceneViewsApi - functional programming interface
 * @export
 */
export const SceneViewsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create a `scene-view` of a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneViewRequest_data|true|| | attributes|CreateSceneViewRequest_data_attributes|true|| | camera|Camera|false|Camera placement in 3D space.| | lookAt|Vector3|true|3D vector.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | position|Vector3|true|3D vector.| | up|Vector3|true|3D vector.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneViewRequest} createSceneViewRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneView(
      id: string,
      createSceneViewRequest: CreateSceneViewRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneView>
    > {
      const localVarAxiosArgs = await SceneViewsApiAxiosParamCreator(
        configuration
      ).createSceneView(id, createSceneViewRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Delete a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSceneView(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SceneViewsApiAxiosParamCreator(
        configuration
      ).deleteSceneView(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `scene-view` by ID.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSceneView(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneView>
    > {
      const localVarAxiosArgs = await SceneViewsApiAxiosParamCreator(
        configuration
      ).getSceneView(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a rendered image of a `scene-view`. If a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {number} [height] The height of the image to render.
     * @param {number} [width] The width of the image to render.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async renderSceneView(
      id: string,
      height?: number,
      width?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs = await SceneViewsApiAxiosParamCreator(
        configuration
      ).renderSceneView(id, height, width, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Update a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneViewRequest_data|true|| | attributes|UpdateSceneViewRequest_data_attributes|true|| | camera|any|false|| | *anonymous*|Camera|false|Camera placement in 3D space.| | lookAt|Vector3|true|3D vector.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | position|Vector3|true|3D vector.| | up|Vector3|true|3D vector.| | *anonymous*|CameraFit|false|Fit camera in 3D space based on items in scene.| | type|enum(fit-visible-scene-items)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {UpdateSceneViewRequest} updateSceneViewRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSceneView(
      id: string,
      updateSceneViewRequest: UpdateSceneViewRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneView>
    > {
      const localVarAxiosArgs = await SceneViewsApiAxiosParamCreator(
        configuration
      ).updateSceneView(id, updateSceneViewRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * SceneViewsApi - factory interface
 * @export
 */
export const SceneViewsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `scene-view` of a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneViewRequest_data|true|| | attributes|CreateSceneViewRequest_data_attributes|true|| | camera|Camera|false|Camera placement in 3D space.| | lookAt|Vector3|true|3D vector.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | position|Vector3|true|3D vector.| | up|Vector3|true|3D vector.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateSceneViewRequest} createSceneViewRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneView(
      id: string,
      createSceneViewRequest: CreateSceneViewRequest,
      options?: any
    ): AxiosPromise<SceneView> {
      return SceneViewsApiFp(configuration)
        .createSceneView(id, createSceneViewRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Delete a `scene-view`.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSceneView(id: string, options?: any): AxiosPromise<void> {
      return SceneViewsApiFp(configuration)
        .deleteSceneView(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `scene-view` by ID.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSceneView(id: string, options?: any): AxiosPromise<SceneView> {
      return SceneViewsApiFp(configuration)
        .getSceneView(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a rendered image of a `scene-view`. If a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {number} [height] The height of the image to render.
     * @param {number} [width] The width of the image to render.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    renderSceneView(
      id: string,
      height?: number,
      width?: number,
      options?: any
    ): AxiosPromise<any> {
      return SceneViewsApiFp(configuration)
        .renderSceneView(id, height, width, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Update a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneViewRequest_data|true|| | attributes|UpdateSceneViewRequest_data_attributes|true|| | camera|any|false|| | *anonymous*|Camera|false|Camera placement in 3D space.| | lookAt|Vector3|true|3D vector.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | position|Vector3|true|3D vector.| | up|Vector3|true|3D vector.| | *anonymous*|CameraFit|false|Fit camera in 3D space based on items in scene.| | type|enum(fit-visible-scene-items)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene-view&#x60; ID.
     * @param {UpdateSceneViewRequest} updateSceneViewRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSceneView(
      id: string,
      updateSceneViewRequest: UpdateSceneViewRequest,
      options?: any
    ): AxiosPromise<SceneView> {
      return SceneViewsApiFp(configuration)
        .updateSceneView(id, updateSceneViewRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createSceneView operation in SceneViewsApi.
 * @export
 * @interface SceneViewsApiCreateSceneViewRequest
 */
export interface SceneViewsApiCreateSceneViewRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof SceneViewsApiCreateSceneView
   */
  readonly id: string;

  /**
   *
   * @type {CreateSceneViewRequest}
   * @memberof SceneViewsApiCreateSceneView
   */
  readonly createSceneViewRequest: CreateSceneViewRequest;
}

/**
 * Request parameters for deleteSceneView operation in SceneViewsApi.
 * @export
 * @interface SceneViewsApiDeleteSceneViewRequest
 */
export interface SceneViewsApiDeleteSceneViewRequest {
  /**
   * The &#x60;scene-view&#x60; ID.
   * @type {string}
   * @memberof SceneViewsApiDeleteSceneView
   */
  readonly id: string;
}

/**
 * Request parameters for getSceneView operation in SceneViewsApi.
 * @export
 * @interface SceneViewsApiGetSceneViewRequest
 */
export interface SceneViewsApiGetSceneViewRequest {
  /**
   * The &#x60;scene-view&#x60; ID.
   * @type {string}
   * @memberof SceneViewsApiGetSceneView
   */
  readonly id: string;
}

/**
 * Request parameters for renderSceneView operation in SceneViewsApi.
 * @export
 * @interface SceneViewsApiRenderSceneViewRequest
 */
export interface SceneViewsApiRenderSceneViewRequest {
  /**
   * The &#x60;scene-view&#x60; ID.
   * @type {string}
   * @memberof SceneViewsApiRenderSceneView
   */
  readonly id: string;

  /**
   * The height of the image to render.
   * @type {number}
   * @memberof SceneViewsApiRenderSceneView
   */
  readonly height?: number;

  /**
   * The width of the image to render.
   * @type {number}
   * @memberof SceneViewsApiRenderSceneView
   */
  readonly width?: number;
}

/**
 * Request parameters for updateSceneView operation in SceneViewsApi.
 * @export
 * @interface SceneViewsApiUpdateSceneViewRequest
 */
export interface SceneViewsApiUpdateSceneViewRequest {
  /**
   * The &#x60;scene-view&#x60; ID.
   * @type {string}
   * @memberof SceneViewsApiUpdateSceneView
   */
  readonly id: string;

  /**
   *
   * @type {UpdateSceneViewRequest}
   * @memberof SceneViewsApiUpdateSceneView
   */
  readonly updateSceneViewRequest: UpdateSceneViewRequest;
}

/**
 * SceneViewsApi - object-oriented interface
 * @export
 * @class SceneViewsApi
 * @extends {BaseAPI}
 */
export class SceneViewsApi extends BaseAPI {
  /**
   *  Create a `scene-view` of a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneViewRequest_data|true|| | attributes|CreateSceneViewRequest_data_attributes|true|| | camera|Camera|false|Camera placement in 3D space.| | lookAt|Vector3|true|3D vector.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | position|Vector3|true|3D vector.| | up|Vector3|true|3D vector.| | type|string|true|Resource object type.|
   * @param {SceneViewsApiCreateSceneViewRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewsApi
   */
  public createSceneView(
    requestParameters: SceneViewsApiCreateSceneViewRequest,
    options?: any
  ) {
    return SceneViewsApiFp(this.configuration)
      .createSceneView(
        requestParameters.id,
        requestParameters.createSceneViewRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Delete a `scene-view`.
   * @param {SceneViewsApiDeleteSceneViewRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewsApi
   */
  public deleteSceneView(
    requestParameters: SceneViewsApiDeleteSceneViewRequest,
    options?: any
  ) {
    return SceneViewsApiFp(this.configuration)
      .deleteSceneView(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `scene-view` by ID.
   * @param {SceneViewsApiGetSceneViewRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewsApi
   */
  public getSceneView(
    requestParameters: SceneViewsApiGetSceneViewRequest,
    options?: any
  ) {
    return SceneViewsApiFp(this.configuration)
      .getSceneView(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a rendered image of a `scene-view`. If a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
   * @param {SceneViewsApiRenderSceneViewRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewsApi
   */
  public renderSceneView(
    requestParameters: SceneViewsApiRenderSceneViewRequest,
    options?: any
  ) {
    return SceneViewsApiFp(this.configuration)
      .renderSceneView(
        requestParameters.id,
        requestParameters.height,
        requestParameters.width,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Update a `scene-view`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneViewRequest_data|true|| | attributes|UpdateSceneViewRequest_data_attributes|true|| | camera|any|false|| | *anonymous*|Camera|false|Camera placement in 3D space.| | lookAt|Vector3|true|3D vector.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | position|Vector3|true|3D vector.| | up|Vector3|true|3D vector.| | *anonymous*|CameraFit|false|Fit camera in 3D space based on items in scene.| | type|enum(fit-visible-scene-items)|true|Resource object type.| | type|string|true|Resource object type.|
   * @param {SceneViewsApiUpdateSceneViewRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SceneViewsApi
   */
  public updateSceneView(
    requestParameters: SceneViewsApiUpdateSceneViewRequest,
    options?: any
  ) {
    return SceneViewsApiFp(this.configuration)
      .updateSceneView(
        requestParameters.id,
        requestParameters.updateSceneViewRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ScenesApi - axios parameter creator
 * @export
 */
export const ScenesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `scene`. Once created, add scene items via the createSceneItem API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneRequest_data|true|| | attributes|CreateSceneViewRequest_data_attributes|true|| | camera|Camera|false|Camera placement in 3D space.| | lookAt|Vector3|true|3D vector.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | position|Vector3|true|3D vector.| | up|Vector3|true|3D vector.| | relationships|CreateSceneRequest_data_relationships|false|| | source|SceneTemplateRelationship|true|Relationship to a `scene-template`.| | data|SceneTemplateRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(scene-template)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {CreateSceneRequest} createSceneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createScene: async (
      createSceneRequest: CreateSceneRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createSceneRequest' is not null or undefined
      if (createSceneRequest === null || createSceneRequest === undefined) {
        throw new RequiredError(
          'createSceneRequest',
          'Required parameter createSceneRequest was null or undefined when calling createScene.'
        );
      }
      const localVarPath = `/scenes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof createSceneRequest !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type']
            )
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createSceneRequest !== undefined ? createSceneRequest : {}
          )
        : createSceneRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `queued-scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedScene: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getQueuedScene.'
        );
      }
      const localVarPath = `/queued-scenes/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `scene` by ID.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScene: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getScene.'
        );
      }
      const localVarPath = `/scenes/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get `scenes`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScenes: async (
      pageCursor?: string,
      pageSize?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/scenes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a rendered image of a `scene`. If only a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {number} [height] The height of the image to render.
     * @param {number} [width] The width of the image to render.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    renderScene: async (
      id: string,
      height?: number,
      width?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling renderScene.'
        );
      }
      const localVarPath = `/scenes/{id}/image`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (height !== undefined) {
        localVarQueryParameter['height'] = height;
      }

      if (width !== undefined) {
        localVarQueryParameter['width'] = width;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Update a `scene` camera and/or state. Once updated, view the scene via the renderScene API or with the Viewer SDK. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneRequest_data|true|| | attributes|UpdateSceneRequest_data_attributes|true|| | camera|any|false|| | *anonymous*|Camera|false|Camera placement in 3D space.| | lookAt|Vector3|true|3D vector.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | position|Vector3|true|3D vector.| | up|Vector3|true|3D vector.| | *anonymous*|CameraFit|false|Fit camera in 3D space based on items in scene.| | type|enum(fit-visible-scene-items)|true|Resource object type.| | state|enum(draft, commit)|false|State of the scene.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {UpdateSceneRequest} updateSceneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateScene: async (
      id: string,
      updateSceneRequest: UpdateSceneRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateScene.'
        );
      }
      // verify required parameter 'updateSceneRequest' is not null or undefined
      if (updateSceneRequest === null || updateSceneRequest === undefined) {
        throw new RequiredError(
          'updateSceneRequest',
          'Required parameter updateSceneRequest was null or undefined when calling updateScene.'
        );
      }
      const localVarPath = `/scenes/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof updateSceneRequest !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type']
            )
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            updateSceneRequest !== undefined ? updateSceneRequest : {}
          )
        : updateSceneRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ScenesApi - functional programming interface
 * @export
 */
export const ScenesApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create a `scene`. Once created, add scene items via the createSceneItem API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneRequest_data|true|| | attributes|CreateSceneViewRequest_data_attributes|true|| | camera|Camera|false|Camera placement in 3D space.| | lookAt|Vector3|true|3D vector.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | position|Vector3|true|3D vector.| | up|Vector3|true|3D vector.| | relationships|CreateSceneRequest_data_relationships|false|| | source|SceneTemplateRelationship|true|Relationship to a `scene-template`.| | data|SceneTemplateRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(scene-template)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {CreateSceneRequest} createSceneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createScene(
      createSceneRequest: CreateSceneRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scene>
    > {
      const localVarAxiosArgs = await ScenesApiAxiosParamCreator(
        configuration
      ).createScene(createSceneRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `queued-scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedScene(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await ScenesApiAxiosParamCreator(
        configuration
      ).getQueuedScene(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `scene` by ID.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getScene(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scene>
    > {
      const localVarAxiosArgs = await ScenesApiAxiosParamCreator(
        configuration
      ).getScene(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get `scenes`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getScenes(
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SceneList>
    > {
      const localVarAxiosArgs = await ScenesApiAxiosParamCreator(
        configuration
      ).getScenes(pageCursor, pageSize, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a rendered image of a `scene`. If only a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {number} [height] The height of the image to render.
     * @param {number} [width] The width of the image to render.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async renderScene(
      id: string,
      height?: number,
      width?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs = await ScenesApiAxiosParamCreator(
        configuration
      ).renderScene(id, height, width, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Update a `scene` camera and/or state. Once updated, view the scene via the renderScene API or with the Viewer SDK. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneRequest_data|true|| | attributes|UpdateSceneRequest_data_attributes|true|| | camera|any|false|| | *anonymous*|Camera|false|Camera placement in 3D space.| | lookAt|Vector3|true|3D vector.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | position|Vector3|true|3D vector.| | up|Vector3|true|3D vector.| | *anonymous*|CameraFit|false|Fit camera in 3D space based on items in scene.| | type|enum(fit-visible-scene-items)|true|Resource object type.| | state|enum(draft, commit)|false|State of the scene.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {UpdateSceneRequest} updateSceneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateScene(
      id: string,
      updateSceneRequest: UpdateSceneRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scene>
    > {
      const localVarAxiosArgs = await ScenesApiAxiosParamCreator(
        configuration
      ).updateScene(id, updateSceneRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * ScenesApi - factory interface
 * @export
 */
export const ScenesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `scene`. Once created, add scene items via the createSceneItem API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneRequest_data|true|| | attributes|CreateSceneViewRequest_data_attributes|true|| | camera|Camera|false|Camera placement in 3D space.| | lookAt|Vector3|true|3D vector.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | position|Vector3|true|3D vector.| | up|Vector3|true|3D vector.| | relationships|CreateSceneRequest_data_relationships|false|| | source|SceneTemplateRelationship|true|Relationship to a `scene-template`.| | data|SceneTemplateRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(scene-template)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {CreateSceneRequest} createSceneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createScene(
      createSceneRequest: CreateSceneRequest,
      options?: any
    ): AxiosPromise<Scene> {
      return ScenesApiFp(configuration)
        .createScene(createSceneRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `queued-scene`.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedScene(id: string, options?: any): AxiosPromise<QueuedJob> {
      return ScenesApiFp(configuration)
        .getQueuedScene(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `scene` by ID.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScene(id: string, options?: any): AxiosPromise<Scene> {
      return ScenesApiFp(configuration)
        .getScene(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get `scenes`.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScenes(
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<SceneList> {
      return ScenesApiFp(configuration)
        .getScenes(pageCursor, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a rendered image of a `scene`. If only a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {number} [height] The height of the image to render.
     * @param {number} [width] The width of the image to render.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    renderScene(
      id: string,
      height?: number,
      width?: number,
      options?: any
    ): AxiosPromise<any> {
      return ScenesApiFp(configuration)
        .renderScene(id, height, width, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Update a `scene` camera and/or state. Once updated, view the scene via the renderScene API or with the Viewer SDK. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneRequest_data|true|| | attributes|UpdateSceneRequest_data_attributes|true|| | camera|any|false|| | *anonymous*|Camera|false|Camera placement in 3D space.| | lookAt|Vector3|true|3D vector.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | position|Vector3|true|3D vector.| | up|Vector3|true|3D vector.| | *anonymous*|CameraFit|false|Fit camera in 3D space based on items in scene.| | type|enum(fit-visible-scene-items)|true|Resource object type.| | state|enum(draft, commit)|false|State of the scene.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {UpdateSceneRequest} updateSceneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateScene(
      id: string,
      updateSceneRequest: UpdateSceneRequest,
      options?: any
    ): AxiosPromise<Scene> {
      return ScenesApiFp(configuration)
        .updateScene(id, updateSceneRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createScene operation in ScenesApi.
 * @export
 * @interface ScenesApiCreateSceneRequest
 */
export interface ScenesApiCreateSceneRequest {
  /**
   *
   * @type {CreateSceneRequest}
   * @memberof ScenesApiCreateScene
   */
  readonly createSceneRequest: CreateSceneRequest;
}

/**
 * Request parameters for getQueuedScene operation in ScenesApi.
 * @export
 * @interface ScenesApiGetQueuedSceneRequest
 */
export interface ScenesApiGetQueuedSceneRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof ScenesApiGetQueuedScene
   */
  readonly id: string;
}

/**
 * Request parameters for getScene operation in ScenesApi.
 * @export
 * @interface ScenesApiGetSceneRequest
 */
export interface ScenesApiGetSceneRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof ScenesApiGetScene
   */
  readonly id: string;
}

/**
 * Request parameters for getScenes operation in ScenesApi.
 * @export
 * @interface ScenesApiGetScenesRequest
 */
export interface ScenesApiGetScenesRequest {
  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof ScenesApiGetScenes
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof ScenesApiGetScenes
   */
  readonly pageSize?: number;
}

/**
 * Request parameters for renderScene operation in ScenesApi.
 * @export
 * @interface ScenesApiRenderSceneRequest
 */
export interface ScenesApiRenderSceneRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof ScenesApiRenderScene
   */
  readonly id: string;

  /**
   * The height of the image to render.
   * @type {number}
   * @memberof ScenesApiRenderScene
   */
  readonly height?: number;

  /**
   * The width of the image to render.
   * @type {number}
   * @memberof ScenesApiRenderScene
   */
  readonly width?: number;
}

/**
 * Request parameters for updateScene operation in ScenesApi.
 * @export
 * @interface ScenesApiUpdateSceneRequest
 */
export interface ScenesApiUpdateSceneRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof ScenesApiUpdateScene
   */
  readonly id: string;

  /**
   *
   * @type {UpdateSceneRequest}
   * @memberof ScenesApiUpdateScene
   */
  readonly updateSceneRequest: UpdateSceneRequest;
}

/**
 * ScenesApi - object-oriented interface
 * @export
 * @class ScenesApi
 * @extends {BaseAPI}
 */
export class ScenesApi extends BaseAPI {
  /**
   *  Create a `scene`. Once created, add scene items via the createSceneItem API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateSceneRequest_data|true|| | attributes|CreateSceneViewRequest_data_attributes|true|| | camera|Camera|false|Camera placement in 3D space.| | lookAt|Vector3|true|3D vector.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | position|Vector3|true|3D vector.| | up|Vector3|true|3D vector.| | relationships|CreateSceneRequest_data_relationships|false|| | source|SceneTemplateRelationship|true|Relationship to a `scene-template`.| | data|SceneTemplateRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(scene-template)|true|Resource object type.| | type|string|true|Resource object type.|
   * @param {ScenesApiCreateSceneRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public createScene(
    requestParameters: ScenesApiCreateSceneRequest,
    options?: any
  ) {
    return ScenesApiFp(this.configuration)
      .createScene(requestParameters.createSceneRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `queued-scene`.
   * @param {ScenesApiGetQueuedSceneRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public getQueuedScene(
    requestParameters: ScenesApiGetQueuedSceneRequest,
    options?: any
  ) {
    return ScenesApiFp(this.configuration)
      .getQueuedScene(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `scene` by ID.
   * @param {ScenesApiGetSceneRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public getScene(requestParameters: ScenesApiGetSceneRequest, options?: any) {
    return ScenesApiFp(this.configuration)
      .getScene(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get `scenes`.
   * @param {ScenesApiGetScenesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public getScenes(
    requestParameters: ScenesApiGetScenesRequest = {},
    options?: any
  ) {
    return ScenesApiFp(this.configuration)
      .getScenes(
        requestParameters.pageCursor,
        requestParameters.pageSize,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a rendered image of a `scene`. If only a single pixel is returned, ensure the `scene` is in the `commit` state and contains scene items.
   * @param {ScenesApiRenderSceneRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public renderScene(
    requestParameters: ScenesApiRenderSceneRequest,
    options?: any
  ) {
    return ScenesApiFp(this.configuration)
      .renderScene(
        requestParameters.id,
        requestParameters.height,
        requestParameters.width,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Update a `scene` camera and/or state. Once updated, view the scene via the renderScene API or with the Viewer SDK. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|UpdateSceneRequest_data|true|| | attributes|UpdateSceneRequest_data_attributes|true|| | camera|any|false|| | *anonymous*|Camera|false|Camera placement in 3D space.| | lookAt|Vector3|true|3D vector.| | x|number|true|x-axis coordinate.| | y|number|true|y-axis coordinate.| | z|number|true|z-axis coordinate.| | position|Vector3|true|3D vector.| | up|Vector3|true|3D vector.| | *anonymous*|CameraFit|false|Fit camera in 3D space based on items in scene.| | type|enum(fit-visible-scene-items)|true|Resource object type.| | state|enum(draft, commit)|false|State of the scene.| | type|string|true|Resource object type.|
   * @param {ScenesApiUpdateSceneRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public updateScene(
    requestParameters: ScenesApiUpdateSceneRequest,
    options?: any
  ) {
    return ScenesApiFp(this.configuration)
      .updateScene(
        requestParameters.id,
        requestParameters.updateSceneRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * StreamKeysApi - axios parameter creator
 * @export
 */
export const StreamKeysApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `stream-key` for a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateStreamKeyRequest_data|true|| | attributes|CreateStreamKeyRequest_data_attributes|true|| | expiry|integer(int32)|false|Number of seconds before the `stream-key` expires.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateStreamKeyRequest} createStreamKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneStreamKey: async (
      id: string,
      createStreamKeyRequest: CreateStreamKeyRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling createSceneStreamKey.'
        );
      }
      // verify required parameter 'createStreamKeyRequest' is not null or undefined
      if (
        createStreamKeyRequest === null ||
        createStreamKeyRequest === undefined
      ) {
        throw new RequiredError(
          'createStreamKeyRequest',
          'Required parameter createStreamKeyRequest was null or undefined when calling createSceneStreamKey.'
        );
      }
      const localVarPath = `/scenes/{id}/stream-keys`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof createStreamKeyRequest !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type']
            )
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createStreamKeyRequest !== undefined ? createStreamKeyRequest : {}
          )
        : createStreamKeyRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Delete a `stream-key`.
     * @param {string} id The &#x60;stream-key&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteStreamKey: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteStreamKey.'
        );
      }
      const localVarPath = `/stream-keys/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get `stream-key`s.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStreamKeys: async (
      pageCursor?: string,
      pageSize?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/stream-keys`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (pageCursor !== undefined) {
        localVarQueryParameter['page[cursor]'] = pageCursor;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page[size]'] = pageSize;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StreamKeysApi - functional programming interface
 * @export
 */
export const StreamKeysApiFp = function (configuration?: Configuration) {
  return {
    /**
     *  Create a `stream-key` for a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateStreamKeyRequest_data|true|| | attributes|CreateStreamKeyRequest_data_attributes|true|| | expiry|integer(int32)|false|Number of seconds before the `stream-key` expires.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateStreamKeyRequest} createStreamKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSceneStreamKey(
      id: string,
      createStreamKeyRequest: CreateStreamKeyRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamKey>
    > {
      const localVarAxiosArgs = await StreamKeysApiAxiosParamCreator(
        configuration
      ).createSceneStreamKey(id, createStreamKeyRequest, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Delete a `stream-key`.
     * @param {string} id The &#x60;stream-key&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteStreamKey(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await StreamKeysApiAxiosParamCreator(
        configuration
      ).deleteStreamKey(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get `stream-key`s.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStreamKeys(
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamKeyList>
    > {
      const localVarAxiosArgs = await StreamKeysApiAxiosParamCreator(
        configuration
      ).getStreamKeys(pageCursor, pageSize, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * StreamKeysApi - factory interface
 * @export
 */
export const StreamKeysApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `stream-key` for a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateStreamKeyRequest_data|true|| | attributes|CreateStreamKeyRequest_data_attributes|true|| | expiry|integer(int32)|false|Number of seconds before the `stream-key` expires.| | type|string|true|Resource object type.|
     * @param {string} id The &#x60;scene&#x60; ID.
     * @param {CreateStreamKeyRequest} createStreamKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSceneStreamKey(
      id: string,
      createStreamKeyRequest: CreateStreamKeyRequest,
      options?: any
    ): AxiosPromise<StreamKey> {
      return StreamKeysApiFp(configuration)
        .createSceneStreamKey(id, createStreamKeyRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Delete a `stream-key`.
     * @param {string} id The &#x60;stream-key&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteStreamKey(id: string, options?: any): AxiosPromise<void> {
      return StreamKeysApiFp(configuration)
        .deleteStreamKey(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get `stream-key`s.
     * @param {string} [pageCursor] The cursor for the next page of items.
     * @param {number} [pageSize] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStreamKeys(
      pageCursor?: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<StreamKeyList> {
      return StreamKeysApiFp(configuration)
        .getStreamKeys(pageCursor, pageSize, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createSceneStreamKey operation in StreamKeysApi.
 * @export
 * @interface StreamKeysApiCreateSceneStreamKeyRequest
 */
export interface StreamKeysApiCreateSceneStreamKeyRequest {
  /**
   * The &#x60;scene&#x60; ID.
   * @type {string}
   * @memberof StreamKeysApiCreateSceneStreamKey
   */
  readonly id: string;

  /**
   *
   * @type {CreateStreamKeyRequest}
   * @memberof StreamKeysApiCreateSceneStreamKey
   */
  readonly createStreamKeyRequest: CreateStreamKeyRequest;
}

/**
 * Request parameters for deleteStreamKey operation in StreamKeysApi.
 * @export
 * @interface StreamKeysApiDeleteStreamKeyRequest
 */
export interface StreamKeysApiDeleteStreamKeyRequest {
  /**
   * The &#x60;stream-key&#x60; ID.
   * @type {string}
   * @memberof StreamKeysApiDeleteStreamKey
   */
  readonly id: string;
}

/**
 * Request parameters for getStreamKeys operation in StreamKeysApi.
 * @export
 * @interface StreamKeysApiGetStreamKeysRequest
 */
export interface StreamKeysApiGetStreamKeysRequest {
  /**
   * The cursor for the next page of items.
   * @type {string}
   * @memberof StreamKeysApiGetStreamKeys
   */
  readonly pageCursor?: string;

  /**
   * The number of items to return.
   * @type {number}
   * @memberof StreamKeysApiGetStreamKeys
   */
  readonly pageSize?: number;
}

/**
 * StreamKeysApi - object-oriented interface
 * @export
 * @class StreamKeysApi
 * @extends {BaseAPI}
 */
export class StreamKeysApi extends BaseAPI {
  /**
   *  Create a `stream-key` for a `scene`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateStreamKeyRequest_data|true|| | attributes|CreateStreamKeyRequest_data_attributes|true|| | expiry|integer(int32)|false|Number of seconds before the `stream-key` expires.| | type|string|true|Resource object type.|
   * @param {StreamKeysApiCreateSceneStreamKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StreamKeysApi
   */
  public createSceneStreamKey(
    requestParameters: StreamKeysApiCreateSceneStreamKeyRequest,
    options?: any
  ) {
    return StreamKeysApiFp(this.configuration)
      .createSceneStreamKey(
        requestParameters.id,
        requestParameters.createStreamKeyRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Delete a `stream-key`.
   * @param {StreamKeysApiDeleteStreamKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StreamKeysApi
   */
  public deleteStreamKey(
    requestParameters: StreamKeysApiDeleteStreamKeyRequest,
    options?: any
  ) {
    return StreamKeysApiFp(this.configuration)
      .deleteStreamKey(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get `stream-key`s.
   * @param {StreamKeysApiGetStreamKeysRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StreamKeysApi
   */
  public getStreamKeys(
    requestParameters: StreamKeysApiGetStreamKeysRequest = {},
    options?: any
  ) {
    return StreamKeysApiFp(this.configuration)
      .getStreamKeys(
        requestParameters.pageCursor,
        requestParameters.pageSize,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TranslationInspectionsApi - axios parameter creator
 * @export
 */
export const TranslationInspectionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `translation-inspection`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateTranslationInspectionRequest_data|true|| | relationships|CreateGeometrySetRequest_data_relationships|true|| | source|FileRelationship|true|Relationship to a `file`.| | data|FileRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(file)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {CreateTranslationInspectionRequest} createTranslationInspectionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTranslationInspection: async (
      createTranslationInspectionRequest: CreateTranslationInspectionRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createTranslationInspectionRequest' is not null or undefined
      if (
        createTranslationInspectionRequest === null ||
        createTranslationInspectionRequest === undefined
      ) {
        throw new RequiredError(
          'createTranslationInspectionRequest',
          'Required parameter createTranslationInspectionRequest was null or undefined when calling createTranslationInspection.'
        );
      }
      const localVarPath = `/translation-inspections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const nonString = typeof createTranslationInspectionRequest !== 'string';
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type']
            )
          : nonString;
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            createTranslationInspectionRequest !== undefined
              ? createTranslationInspectionRequest
              : {}
          )
        : createTranslationInspectionRequest || '';

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `translation-inspection` by ID.
     * @param {string} id The &#x60;translation-inspection&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInspectionJob: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getInspectionJob.'
        );
      }
      const localVarPath = `/translation-inspections/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     *  Get a `queued-translation`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `part-revision`. Once created, create scenes via the createScene API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.
     * @param {string} id The &#x60;queued-translation&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedTranslation: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getQueuedTranslation.'
        );
      }
      const localVarPath = `/queued-translations/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken('OAuth2', [])
            : await configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key]);
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString();
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TranslationInspectionsApi - functional programming interface
 * @export
 */
export const TranslationInspectionsApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     *  Create a `translation-inspection`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateTranslationInspectionRequest_data|true|| | relationships|CreateGeometrySetRequest_data_relationships|true|| | source|FileRelationship|true|Relationship to a `file`.| | data|FileRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(file)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {CreateTranslationInspectionRequest} createTranslationInspectionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTranslationInspection(
      createTranslationInspectionRequest: CreateTranslationInspectionRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<TranslationInspectionJob>
    > {
      const localVarAxiosArgs = await TranslationInspectionsApiAxiosParamCreator(
        configuration
      ).createTranslationInspection(
        createTranslationInspectionRequest,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `translation-inspection` by ID.
     * @param {string} id The &#x60;translation-inspection&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInspectionJob(
      id: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<TranslationInspectionJob>
    > {
      const localVarAxiosArgs = await TranslationInspectionsApiAxiosParamCreator(
        configuration
      ).getInspectionJob(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *  Get a `queued-translation`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `part-revision`. Once created, create scenes via the createScene API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.
     * @param {string} id The &#x60;queued-translation&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedTranslation(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueuedJob>
    > {
      const localVarAxiosArgs = await TranslationInspectionsApiAxiosParamCreator(
        configuration
      ).getQueuedTranslation(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * TranslationInspectionsApi - factory interface
 * @export
 */
export const TranslationInspectionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *  Create a `translation-inspection`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateTranslationInspectionRequest_data|true|| | relationships|CreateGeometrySetRequest_data_relationships|true|| | source|FileRelationship|true|Relationship to a `file`.| | data|FileRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(file)|true|Resource object type.| | type|string|true|Resource object type.|
     * @param {CreateTranslationInspectionRequest} createTranslationInspectionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTranslationInspection(
      createTranslationInspectionRequest: CreateTranslationInspectionRequest,
      options?: any
    ): AxiosPromise<TranslationInspectionJob> {
      return TranslationInspectionsApiFp(configuration)
        .createTranslationInspection(
          createTranslationInspectionRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `translation-inspection` by ID.
     * @param {string} id The &#x60;translation-inspection&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInspectionJob(
      id: string,
      options?: any
    ): AxiosPromise<TranslationInspectionJob> {
      return TranslationInspectionsApiFp(configuration)
        .getInspectionJob(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Get a `queued-translation`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `part-revision`. Once created, create scenes via the createScene API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.
     * @param {string} id The &#x60;queued-translation&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedTranslation(id: string, options?: any): AxiosPromise<QueuedJob> {
      return TranslationInspectionsApiFp(configuration)
        .getQueuedTranslation(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for createTranslationInspection operation in TranslationInspectionsApi.
 * @export
 * @interface TranslationInspectionsApiCreateTranslationInspectionRequest
 */
export interface TranslationInspectionsApiCreateTranslationInspectionRequest {
  /**
   *
   * @type {CreateTranslationInspectionRequest}
   * @memberof TranslationInspectionsApiCreateTranslationInspection
   */
  readonly createTranslationInspectionRequest: CreateTranslationInspectionRequest;
}

/**
 * Request parameters for getInspectionJob operation in TranslationInspectionsApi.
 * @export
 * @interface TranslationInspectionsApiGetInspectionJobRequest
 */
export interface TranslationInspectionsApiGetInspectionJobRequest {
  /**
   * The &#x60;translation-inspection&#x60; ID.
   * @type {string}
   * @memberof TranslationInspectionsApiGetInspectionJob
   */
  readonly id: string;
}

/**
 * Request parameters for getQueuedTranslation operation in TranslationInspectionsApi.
 * @export
 * @interface TranslationInspectionsApiGetQueuedTranslationRequest
 */
export interface TranslationInspectionsApiGetQueuedTranslationRequest {
  /**
   * The &#x60;queued-translation&#x60; ID.
   * @type {string}
   * @memberof TranslationInspectionsApiGetQueuedTranslation
   */
  readonly id: string;
}

/**
 * TranslationInspectionsApi - object-oriented interface
 * @export
 * @class TranslationInspectionsApi
 * @extends {BaseAPI}
 */
export class TranslationInspectionsApi extends BaseAPI {
  /**
   *  Create a `translation-inspection`.  ###### Body Params  |Name|Type|Required|Description| |---|---|---|---| |data|CreateTranslationInspectionRequest_data|true|| | relationships|CreateGeometrySetRequest_data_relationships|true|| | source|FileRelationship|true|Relationship to a `file`.| | data|FileRelationship_data|true|| | id|string(uuid)|true|ID of the resource.| | type|enum(file)|true|Resource object type.| | type|string|true|Resource object type.|
   * @param {TranslationInspectionsApiCreateTranslationInspectionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranslationInspectionsApi
   */
  public createTranslationInspection(
    requestParameters: TranslationInspectionsApiCreateTranslationInspectionRequest,
    options?: any
  ) {
    return TranslationInspectionsApiFp(this.configuration)
      .createTranslationInspection(
        requestParameters.createTranslationInspectionRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `translation-inspection` by ID.
   * @param {TranslationInspectionsApiGetInspectionJobRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranslationInspectionsApi
   */
  public getInspectionJob(
    requestParameters: TranslationInspectionsApiGetInspectionJobRequest,
    options?: any
  ) {
    return TranslationInspectionsApiFp(this.configuration)
      .getInspectionJob(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Get a `queued-translation`. The response is either the status if `running` or `error` or, upon completion, redirects to the created `part-revision`. Once created, create scenes via the createScene API. For details, see our [Rendering scenes](https://developer.vertexvis.com/docs/guides/rendering-scenes) guide.
   * @param {TranslationInspectionsApiGetQueuedTranslationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranslationInspectionsApi
   */
  public getQueuedTranslation(
    requestParameters: TranslationInspectionsApiGetQueuedTranslationRequest,
    options?: any
  ) {
    return TranslationInspectionsApiFp(this.configuration)
      .getQueuedTranslation(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
